// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/web3tea/curio-dashboard/graph/model"
	"github.com/web3tea/curio-dashboard/types"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Actor() ActorResolver
	Config() ConfigResolver
	IPNIAdvertisement() IPNIAdvertisementResolver
	IPNIProvider() IPNIProviderResolver
	IPNIStats() IPNIStatsResolver
	Machine() MachineResolver
	MachineDetail() MachineDetailResolver
	MachineSummary() MachineSummaryResolver
	MessageWait() MessageWaitResolver
	Metadata() MetadataResolver
	Miner() MinerResolver
	MinerBalance() MinerBalanceResolver
	MiningCountSummary() MiningCountSummaryResolver
	Mutation() MutationResolver
	PipelineSummary() PipelineSummaryResolver
	Porep() PorepResolver
	Query() QueryResolver
	Sector() SectorResolver
	SectorLocation() SectorLocationResolver
	SectorMeta() SectorMetaResolver
	Storage() StorageResolver
	StoragePath() StoragePathResolver
	Subscription() SubscriptionResolver
	Task() TaskResolver
	TaskHistory() TaskHistoryResolver
	WdpostProofs() WdpostProofsResolver
}

type DirectiveRoot struct {
	HasRole func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	Actor struct {
		ActorAvailableBalance func(childComplexity int) int
		ActorBalance          func(childComplexity int) int
		Address               func(childComplexity int) int
		Deadlines             func(childComplexity int) int
		ID                    func(childComplexity int) int
		Layers                func(childComplexity int) int
		QualityAdjustedPower  func(childComplexity int) int
		RawBytePower          func(childComplexity int) int
		WorkerBalance         func(childComplexity int) int
	}

	ActorDeadline struct {
		Current    func(childComplexity int) int
		Empty      func(childComplexity int) int
		Faulty     func(childComplexity int) int
		PartFaulty func(childComplexity int) int
		Proven     func(childComplexity int) int
	}

	Alert struct {
		ID          func(childComplexity int) int
		MachineName func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	ChainHead struct {
		Height    func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	CidGravityStatus struct {
		Miner  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	ClientFilter struct {
		Active             func(childComplexity int) int
		Info               func(childComplexity int) int
		MaxDealSizePerHour func(childComplexity int) int
		MaxDealsPerHour    func(childComplexity int) int
		Name               func(childComplexity int) int
		Peers              func(childComplexity int) int
		PricingFilters     func(childComplexity int) int
		Wallets            func(childComplexity int) int
	}

	Config struct {
		Config func(childComplexity int) int
		ID     func(childComplexity int) int
		Title  func(childComplexity int) int
		UsedBy func(childComplexity int) int
	}

	DealCountSummary struct {
		Boost  func(childComplexity int) int
		Direct func(childComplexity int) int
		Legacy func(childComplexity int) int
	}

	DealInfo struct {
		AnnounceToIpni    func(childComplexity int) int
		ChainDealID       func(childComplexity int) int
		ClientPeerID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		EndEpoch          func(childComplexity int) int
		Error             func(childComplexity int) int
		FastRetrieval     func(childComplexity int) int
		ID                func(childComplexity int) int
		Indexed           func(childComplexity int) int
		IsDdo             func(childComplexity int) int
		IsLegacy          func(childComplexity int) int
		Miner             func(childComplexity int) int
		Offline           func(childComplexity int) int
		PieceCid          func(childComplexity int) int
		PieceSize         func(childComplexity int) int
		PublishCid        func(childComplexity int) int
		Sector            func(childComplexity int) int
		SignedProposalCid func(childComplexity int) int
		SpID              func(childComplexity int) int
		StartEpoch        func(childComplexity int) int
		URL               func(childComplexity int) int
		URLHeaders        func(childComplexity int) int
		Urls              func(childComplexity int) int
		Verified          func(childComplexity int) int
	}

	DefaultFilterBehaviour struct {
		AllowDealsFromUnknownClients             func(childComplexity int) int
		IsCidGravityEnabled                      func(childComplexity int) int
		IsDealRejectedWhenCidGravityNotReachable func(childComplexity int) int
	}

	GaugeCountValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	IPNIAdvertisement struct {
		AdCid          func(childComplexity int) int
		Addresses      func(childComplexity int) int
		ContextID      func(childComplexity int) int
		Entries        func(childComplexity int) int
		IsRm           func(childComplexity int) int
		IsSkip         func(childComplexity int) int
		OrderNumber    func(childComplexity int) int
		PieceCid       func(childComplexity int) int
		PieceSize      func(childComplexity int) int
		Previous       func(childComplexity int) int
		Provider       func(childComplexity int) int
		ProviderPeerID func(childComplexity int) int
		Signature      func(childComplexity int) int
	}

	IPNIHead struct {
		Head     func(childComplexity int) int
		Provider func(childComplexity int) int
	}

	IPNIPeerID struct {
		PeerID func(childComplexity int) int
		SpID   func(childComplexity int) int
	}

	IPNIProvider struct {
		AdCount func(childComplexity int) int
		Head    func(childComplexity int) int
		PeerID  func(childComplexity int) int
		SpID    func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	IPNIStats struct {
		Indexed                     func(childComplexity int) int
		PendingTasks                func(childComplexity int) int
		PreviousIndexed             func(childComplexity int) int
		PreviousPendingTasks        func(childComplexity int) int
		PreviousProviders           func(childComplexity int) int
		PreviousSkipped             func(childComplexity int) int
		PreviousTotalAdvertisements func(childComplexity int) int
		Providers                   func(childComplexity int) int
		Skipped                     func(childComplexity int) int
		TotalAdvertisements         func(childComplexity int) int
	}

	IPNITask struct {
		Complete     func(childComplexity int) int
		ContextID    func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		IsRm         func(childComplexity int) int
		Provider     func(childComplexity int) int
		RegSealProof func(childComplexity int) int
		Sector       func(childComplexity int) int
		SectorOffset func(childComplexity int) int
		SpID         func(childComplexity int) int
		TaskID       func(childComplexity int) int
	}

	Machine struct {
		CPU           func(childComplexity int) int
		Detail        func(childComplexity int) int
		Gpu           func(childComplexity int) int
		HostAndPort   func(childComplexity int) int
		ID            func(childComplexity int) int
		LastContact   func(childComplexity int) int
		Metrics       func(childComplexity int) int
		RAM           func(childComplexity int) int
		Storages      func(childComplexity int) int
		TaskHistories func(childComplexity int, last int) int
		Tasks         func(childComplexity int) int
	}

	MachineDetail struct {
		ID          func(childComplexity int) int
		Layers      func(childComplexity int) int
		LayersArray func(childComplexity int) int
		MachineID   func(childComplexity int) int
		MachineName func(childComplexity int) int
		Miners      func(childComplexity int) int
		MinersArray func(childComplexity int) int
		StartupTime func(childComplexity int) int
		Tasks       func(childComplexity int) int
		TasksArray  func(childComplexity int) int
	}

	MachineMetrics struct {
		ActiveTasks                func(childComplexity int) int
		AddedTasks                 func(childComplexity int) int
		CPUUsage                   func(childComplexity int) int
		GoRoutines                 func(childComplexity int) int
		GoThreads                  func(childComplexity int) int
		GoVersion                  func(childComplexity int) int
		GpuUsage                   func(childComplexity int) int
		ProcessCPUSecondsTotal     func(childComplexity int) int
		ProcessMaxFds              func(childComplexity int) int
		ProcessOpenFds             func(childComplexity int) int
		ProcessResidentMemoryBytes func(childComplexity int) int
		ProcessStartTimeSeconds    func(childComplexity int) int
		ProcessVirtualMemoryBytes  func(childComplexity int) int
		RAMUsage                   func(childComplexity int) int
		TasksCompleted             func(childComplexity int) int
		TasksStarted               func(childComplexity int) int
	}

	MachineSummary struct {
		Total            func(childComplexity int) int
		TotalCPU         func(childComplexity int) int
		TotalDown        func(childComplexity int) int
		TotalGpu         func(childComplexity int) int
		TotalRAM         func(childComplexity int) int
		TotalUp          func(childComplexity int) int
		UniqueHostsDown  func(childComplexity int) int
		UniqueHostsTotal func(childComplexity int) int
		UniqueHostsUp    func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	MarketAllowFilter struct {
		Status func(childComplexity int) int
		Wallet func(childComplexity int) int
	}

	MarketBalance struct {
		Balance  func(childComplexity int) int
		Balances func(childComplexity int) int
		Miner    func(childComplexity int) int
	}

	MarketMk12Deal struct {
		AnnounceToIpni    func(childComplexity int) int
		ChainDealID       func(childComplexity int) int
		ClientPeerID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		EndEpoch          func(childComplexity int) int
		Error             func(childComplexity int) int
		FastRetrieval     func(childComplexity int) int
		Label             func(childComplexity int) int
		Offline           func(childComplexity int) int
		PieceCid          func(childComplexity int) int
		PieceSize         func(childComplexity int) int
		Proposal          func(childComplexity int) int
		ProposalCid       func(childComplexity int) int
		ProposalSignature func(childComplexity int) int
		PublishCid        func(childComplexity int) int
		SignedProposalCid func(childComplexity int) int
		SpID              func(childComplexity int) int
		StartEpoch        func(childComplexity int) int
		URL               func(childComplexity int) int
		URLHeaders        func(childComplexity int) int
		UUID              func(childComplexity int) int
		Verified          func(childComplexity int) int
	}

	MarketMk12StorageAsk struct {
		CreatedAt     func(childComplexity int) int
		Expiry        func(childComplexity int) int
		MaxSize       func(childComplexity int) int
		MinSize       func(childComplexity int) int
		Price         func(childComplexity int) int
		Sequence      func(childComplexity int) int
		SpID          func(childComplexity int) int
		VerifiedPrice func(childComplexity int) int
	}

	MessageSend struct {
		FromKey      func(childComplexity int) int
		Nonce        func(childComplexity int) int
		SendError    func(childComplexity int) int
		SendReason   func(childComplexity int) int
		SendSuccess  func(childComplexity int) int
		SendTaskID   func(childComplexity int) int
		SendTime     func(childComplexity int) int
		SignedCid    func(childComplexity int) int
		SignedData   func(childComplexity int) int
		SignedJSON   func(childComplexity int) int
		ToAddr       func(childComplexity int) int
		UnsignedCid  func(childComplexity int) int
		UnsignedData func(childComplexity int) int
	}

	MessageWait struct {
		CreatedAt            func(childComplexity int) int
		ExecutedMsgCid       func(childComplexity int) int
		ExecutedMsgData      func(childComplexity int) int
		ExecutedRcptExitcode func(childComplexity int) int
		ExecutedRcptGasUsed  func(childComplexity int) int
		ExecutedRcptReturn   func(childComplexity int) int
		ExecutedTskCid       func(childComplexity int) int
		ExecutedTskEpoch     func(childComplexity int) int
		SignedMessageCid     func(childComplexity int) int
		WaiterMachine        func(childComplexity int) int
		WaiterMachineID      func(childComplexity int) int
	}

	Metadata struct {
		GenesisTimestamp func(childComplexity int) int
		NetworkName      func(childComplexity int) int
	}

	Miner struct {
		Balance func(childComplexity int) int
		ID      func(childComplexity int) int
		Info    func(childComplexity int) int
		Power   func(childComplexity int) int
	}

	MinerBalance struct {
		Available         func(childComplexity int) int
		Balance           func(childComplexity int) int
		ID                func(childComplexity int) int
		InitialPledge     func(childComplexity int) int
		PreCommitDeposits func(childComplexity int) int
		Vesting           func(childComplexity int) int
	}

	MinerBeneficiaryTerm struct {
		Expiration func(childComplexity int) int
		Quota      func(childComplexity int) int
		UsedQuota  func(childComplexity int) int
	}

	MinerInfo struct {
		Beneficiary                func(childComplexity int) int
		BeneficiaryTerm            func(childComplexity int) int
		ConsensusFaultElapsed      func(childComplexity int) int
		ControlAddresses           func(childComplexity int) int
		MultiAddrs                 func(childComplexity int) int
		NewWorker                  func(childComplexity int) int
		Owner                      func(childComplexity int) int
		PeerID                     func(childComplexity int) int
		PendingBeneficiaryChange   func(childComplexity int) int
		PendingOwnerAddress        func(childComplexity int) int
		SectorSize                 func(childComplexity int) int
		WindowPoStPartitionSectors func(childComplexity int) int
		WindowPoStProofType        func(childComplexity int) int
		Worker                     func(childComplexity int) int
		WorkerChangeEpoch          func(childComplexity int) int
	}

	MinerPendingBeneficiaryChange struct {
		ApprovedByBeneficiary func(childComplexity int) int
		ApprovedByNominee     func(childComplexity int) int
		NewBeneficiary        func(childComplexity int) int
		NewExpiration         func(childComplexity int) int
		NewQuota              func(childComplexity int) int
	}

	MinerPower struct {
		HasMinPower func(childComplexity int) int
		ID          func(childComplexity int) int
		MinerPower  func(childComplexity int) int
		TotalPower  func(childComplexity int) int
	}

	MiningCount struct {
		Exclude func(childComplexity int) int
		Include func(childComplexity int) int
	}

	MiningCountAggregated struct {
		Included func(childComplexity int) int
		Time     func(childComplexity int) int
		Total    func(childComplexity int) int
		Won      func(childComplexity int) int
	}

	MiningCountSummary struct {
		Actor    func(childComplexity int) int
		End      func(childComplexity int) int
		Included func(childComplexity int) int
		Previous func(childComplexity int) int
		Start    func(childComplexity int) int
		Total    func(childComplexity int) int
		Won      func(childComplexity int) int
	}

	MiningStatusSummay struct {
		Included      func(childComplexity int) int
		LastMinedAt   func(childComplexity int) int
		Total         func(childComplexity int) int
		Won           func(childComplexity int) int
		WonChangeRate func(childComplexity int) int
	}

	MiningSummaryDay struct {
		Day      func(childComplexity int) int
		Miner    func(childComplexity int) int
		WonBlock func(childComplexity int) int
	}

	MiningTask struct {
		BaseComputeTime func(childComplexity int) int
		Epoch           func(childComplexity int) int
		Included        func(childComplexity int) int
		MinedAt         func(childComplexity int) int
		MinedCid        func(childComplexity int) int
		MinedHeader     func(childComplexity int) int
		SpID            func(childComplexity int) int
		SubmittedAt     func(childComplexity int) int
		TaskID          func(childComplexity int) int
		Won             func(childComplexity int) int
	}

	Mutation struct {
		CreateConfig               func(childComplexity int, title string, config string) int
		DealSealNow                func(childComplexity int, miner types.Address, sectorNumber uint64) int
		MarketAddBalance           func(childComplexity int, miner types.Address, wallet types.Address, amount types.FIL) int
		MarketAddClientFilter      func(childComplexity int, input model.ClientFilterInput) int
		MarketAddPriceFilter       func(childComplexity int, input model.PriceFilterInput) int
		MarketDeleteAllowFilter    func(childComplexity int, wallet types.Address) int
		MarketDeleteClientFilter   func(childComplexity int, name string) int
		MarketDeletePriceFilter    func(childComplexity int, name string) int
		MarketSetAllowFilter       func(childComplexity int, wallet types.Address, status bool) int
		MarketToggleAllowFilter    func(childComplexity int, wallet types.Address) int
		MarketToggleClientFilter   func(childComplexity int, name string) int
		MarketUpdateClientFilter   func(childComplexity int, input model.ClientFilterInput) int
		MarketUpdatePriceFilter    func(childComplexity int, input model.PriceFilterInput) int
		RemoveConfig               func(childComplexity int, title string) int
		RemoveSector               func(childComplexity int, miner types.Address, sectorNumber int) int
		RestartAllFailedSectors    func(childComplexity int) int
		RestartSector              func(childComplexity int, miner types.Address, sectorNumber int) int
		UpdateConfig               func(childComplexity int, title string, config string) int
		UpdateMarketMk12StorageAsk func(childComplexity int, input model.MarketMk12StorageAskInput) int
	}

	NodeHealthSummary struct {
		OfflineNodes     func(childComplexity int) int
		OnlineNodes      func(childComplexity int) int
		UnscheduledNodes func(childComplexity int) int
	}

	NodeInfo struct {
		Address   func(childComplexity int) int
		ID        func(childComplexity int) int
		Layers    func(childComplexity int) int
		Reachable func(childComplexity int) int
		SyncState func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	OpenSectorPiece struct {
		CreatedAt                     func(childComplexity int) int
		DataDeleteOnFinalize          func(childComplexity int) int
		DataHeaders                   func(childComplexity int) int
		DataRawSize                   func(childComplexity int) int
		DataURL                       func(childComplexity int) int
		DirectEndEpoch                func(childComplexity int) int
		DirectPieceActivationManifest func(childComplexity int) int
		DirectStartEpoch              func(childComplexity int) int
		F05DealEndEpoch               func(childComplexity int) int
		F05DealID                     func(childComplexity int) int
		F05DealProposal               func(childComplexity int) int
		F05DealStartEpoch             func(childComplexity int) int
		F05PublishCid                 func(childComplexity int) int
		IsSnap                        func(childComplexity int) int
		PieceCid                      func(childComplexity int) int
		PieceIndex                    func(childComplexity int) int
		PieceSize                     func(childComplexity int) int
		SectorNumber                  func(childComplexity int) int
		SpID                          func(childComplexity int) int
	}

	PipelineSummary struct {
		CommitMsg    func(childComplexity int) int
		Done         func(childComplexity int) int
		Failed       func(childComplexity int) int
		ID           func(childComplexity int) int
		Porep        func(childComplexity int) int
		PrecommitMsg func(childComplexity int) int
		Sdr          func(childComplexity int) int
		Trees        func(childComplexity int) int
		WaitSeed     func(childComplexity int) int
	}

	Porep struct {
		AfterCommitMsg           func(childComplexity int) int
		AfterCommitMsgSuccess    func(childComplexity int) int
		AfterFinalize            func(childComplexity int) int
		AfterMoveStorage         func(childComplexity int) int
		AfterPorep               func(childComplexity int) int
		AfterPrecommitMsg        func(childComplexity int) int
		AfterPrecommitMsgSuccess func(childComplexity int) int
		AfterSdr                 func(childComplexity int) int
		AfterSynth               func(childComplexity int) int
		AfterTreeC               func(childComplexity int) int
		AfterTreeD               func(childComplexity int) int
		AfterTreeR               func(childComplexity int) int
		CommitMsgCid             func(childComplexity int) int
		CommitMsgTsk             func(childComplexity int) int
		CommitReadyAt            func(childComplexity int) int
		CompactStages            func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		CurrentTask              func(childComplexity int) int
		Failed                   func(childComplexity int) int
		FailedAt                 func(childComplexity int) int
		FailedReason             func(childComplexity int) int
		FailedReasonMsg          func(childComplexity int) int
		ID                       func(childComplexity int) int
		PorepProof               func(childComplexity int) int
		PrecommitMsgCid          func(childComplexity int) int
		PrecommitMsgTsk          func(childComplexity int) int
		PrecommitReadyAt         func(childComplexity int) int
		RegSealProof             func(childComplexity int) int
		SectorNumber             func(childComplexity int) int
		SeedEpoch                func(childComplexity int) int
		SeedValue                func(childComplexity int) int
		SpID                     func(childComplexity int) int
		Stage                    func(childComplexity int) int
		Status                   func(childComplexity int) int
		TaskIDCommitMsg          func(childComplexity int) int
		TaskIDFinalize           func(childComplexity int) int
		TaskIDMoveStorage        func(childComplexity int) int
		TaskIDPorep              func(childComplexity int) int
		TaskIDPrecommitMsg       func(childComplexity int) int
		TaskIDSdr                func(childComplexity int) int
		TaskIDSynth              func(childComplexity int) int
		TaskIDTreeC              func(childComplexity int) int
		TaskIDTreeD              func(childComplexity int) int
		TaskIDTreeR              func(childComplexity int) int
		TicketEpoch              func(childComplexity int) int
		TicketValue              func(childComplexity int) int
		TreeDCid                 func(childComplexity int) int
		TreeRCid                 func(childComplexity int) int
		UserSectorDurationEpochs func(childComplexity int) int
	}

	PowerClaim struct {
		QualityAdjPower func(childComplexity int) int
		RawBytePower    func(childComplexity int) int
	}

	PriceFilter struct {
		MaxDurationDays func(childComplexity int) int
		MaximumSize     func(childComplexity int) int
		MinDurationDays func(childComplexity int) int
		MinimumSize     func(childComplexity int) int
		Name            func(childComplexity int) int
		Price           func(childComplexity int) int
		Verified        func(childComplexity int) int
	}

	PrometheusResponse struct {
		Data func(childComplexity int) int
	}

	Query struct {
		Actor                        func(childComplexity int, address types.Address) int
		Actors                       func(childComplexity int) int
		Alerts                       func(childComplexity int) int
		Config                       func(childComplexity int, layer string) int
		Configs                      func(childComplexity int) int
		DealsPending                 func(childComplexity int) int
		IpniAdvertisement            func(childComplexity int, orderNumber int) int
		IpniAdvertisements           func(childComplexity int, offset int, limit int, provider *string, isSkip *bool, isRemoved *bool) int
		IpniAdvertisementsCount      func(childComplexity int, provider *string, isSkip *bool, isRemoved *bool) int
		IpniProviders                func(childComplexity int) int
		IpniStats                    func(childComplexity int) int
		IpniTask                     func(childComplexity int, taskID int) int
		IpniTasks                    func(childComplexity int, limit *int, spID *types.ActorID, isRm *bool) int
		IpniTasksCount               func(childComplexity int, spID *types.ActorID, isRm *bool) int
		Machine                      func(childComplexity int, id int) int
		MachineByHostAndPort         func(childComplexity int, hostAndPort string) int
		MachineSummary               func(childComplexity int) int
		Machines                     func(childComplexity int) int
		MakretPriceFilters           func(childComplexity int) int
		MarketAllowFilter            func(childComplexity int, wallet types.Address) int
		MarketAllowFilters           func(childComplexity int) int
		MarketBalance                func(childComplexity int, miner types.Address) int
		MarketBalances               func(childComplexity int) int
		MarketCheckClientFilter      func(childComplexity int, name string) int
		MarketCheckPriceFilter       func(childComplexity int, name string) int
		MarketClientFilter           func(childComplexity int, name string) int
		MarketClientFilters          func(childComplexity int) int
		MarketDealCountSummary       func(childComplexity int) int
		MarketDealInfo               func(childComplexity int, id string) int
		MarketDefaultFilterBehaviour func(childComplexity int) int
		MarketMk12Deals              func(childComplexity int, filter model.MarketMk12DealFilterInput, limit int, offset int) int
		MarketMk12DealsCount         func(childComplexity int, filter model.MarketMk12DealFilterInput) int
		MarketMk12StorageAsk         func(childComplexity int, spID types.Address) int
		MarketMk12StorageAsks        func(childComplexity int) int
		MarketMk12StorageAsksCount   func(childComplexity int) int
		MarketPriceFilter            func(childComplexity int, name string) int
		MessageSend                  func(childComplexity int, sendTaskID *int, fromKey *string, nonce *int, signedCid *string) int
		MessageSends                 func(childComplexity int, account *types.Address, offset int, limit int) int
		MessageSendsCount            func(childComplexity int, account *types.Address) int
		MessageWait                  func(childComplexity int, signedMessageCid string) int
		MessageWaits                 func(childComplexity int, waiterMachineID *int, offset int, limit int) int
		MessageWaitsCount            func(childComplexity int, waiterMachineID *int) int
		Metadata                     func(childComplexity int) int
		Miner                        func(childComplexity int, address types.Address) int
		MinerPower                   func(childComplexity int, address *types.Address) int
		MiningCount                  func(childComplexity int, start time.Time, end time.Time, actor *types.Address) int
		MiningCountAggregate         func(childComplexity int, start time.Time, end time.Time, actor *types.Address, interval model.MiningTaskAggregateInterval) int
		MiningCountSummary           func(childComplexity int, start time.Time, end time.Time, actor *types.Address) int
		MiningStatusSummay           func(childComplexity int, spID *types.ActorID, start time.Time, end time.Time) int
		MiningSummaryByDay           func(childComplexity int, start time.Time, end time.Time) int
		MiningWins                   func(childComplexity int, start *time.Time, end *time.Time, actor *types.Address, include *bool, offset int, limit int) int
		MiningWinsCount              func(childComplexity int, start *time.Time, end *time.Time, actor *types.Address, include *bool) int
		NodeHealthSummary            func(childComplexity int) int
		NodesInfo                    func(childComplexity int) int
		PipelinesSummary             func(childComplexity int) int
		Porep                        func(childComplexity int, sp types.Address, sectorNumber int) int
		Poreps                       func(childComplexity int) int
		PrometheusQuery              func(childComplexity int, query string, time *time.Time) int
		PrometheusQueryRange         func(childComplexity int, query string, start time.Time, end time.Time, step int) int
		RunningTaskSummary           func(childComplexity int) int
		Sector                       func(childComplexity int, actor types.Address, sectorNumber int) int
		SectorSummary                func(childComplexity int) int
		Sectors                      func(childComplexity int, actor *types.Address, sectorNumber *int, offset int, limit int) int
		SectorsCount                 func(childComplexity int, actor *types.Address) int
		Storage                      func(childComplexity int, id string) int
		StorageStats                 func(childComplexity int) int
		Storages                     func(childComplexity int) int
		Task                         func(childComplexity int, id int) int
		TaskDurationStats            func(childComplexity int, name string, start time.Time, end time.Time) int
		TaskHistories                func(childComplexity int, start *time.Time, end *time.Time, hostPort *string, name *string, result *bool, offset int, limit int) int
		TaskHistoriesAggregate       func(childComplexity int, start time.Time, end time.Time, interval model.TaskHistoriesAggregateInterval) int
		TaskHistoriesCount           func(childComplexity int, start *time.Time, end *time.Time, hostPort *string, name *string, result *bool) int
		TaskNames                    func(childComplexity int) int
		TaskSuccessRate              func(childComplexity int, name *string, start time.Time, end time.Time) int
		Tasks                        func(childComplexity int) int
		TasksCount                   func(childComplexity int) int
		TasksDurationStats           func(childComplexity int, start time.Time, end time.Time) int
		TasksStats                   func(childComplexity int, start time.Time, end time.Time, machine *string) int
		WdpostProof                  func(childComplexity int, spID types.Address, provingPeriodStart int, deadline int, partition int) int
		WdpostProofs                 func(childComplexity int, spID *types.Address, offset int, limit int) int
		WdpostProofsCount            func(childComplexity int, spID *types.Address) int
	}

	RunningTaskSummary struct {
		AverageWaitTime func(childComplexity int) int
		Queued          func(childComplexity int) int
		Running         func(childComplexity int) int
	}

	Sector struct {
		Events    func(childComplexity int) int
		ID        func(childComplexity int) int
		Locations func(childComplexity int) int
		Meta      func(childComplexity int) int
		Pieces    func(childComplexity int) int
		Porep     func(childComplexity int) int
		SectorNum func(childComplexity int) int
		SpID      func(childComplexity int) int
		Status    func(childComplexity int) int
		Tasks     func(childComplexity int) int
	}

	SectorLocation struct {
		IsPrimary      func(childComplexity int) int
		MinerID        func(childComplexity int) int
		ReadRefs       func(childComplexity int) int
		ReadTs         func(childComplexity int) int
		SectorFiletype func(childComplexity int) int
		SectorNum      func(childComplexity int) int
		Storage        func(childComplexity int) int
		StorageID      func(childComplexity int) int
		WriteLockOwner func(childComplexity int) int
		WriteTs        func(childComplexity int) int
	}

	SectorMeta struct {
		CurSealedCid    func(childComplexity int) int
		CurUnsealedCid  func(childComplexity int) int
		Deadline        func(childComplexity int) int
		ExpirationEpoch func(childComplexity int) int
		ID              func(childComplexity int) int
		IsCc            func(childComplexity int) int
		MsgCidCommit    func(childComplexity int) int
		MsgCidPrecommit func(childComplexity int) int
		MsgCidUpdate    func(childComplexity int) int
		OrigSealedCid   func(childComplexity int) int
		OrigUnsealedCid func(childComplexity int) int
		Partition       func(childComplexity int) int
		RegSealProof    func(childComplexity int) int
		SectorNum       func(childComplexity int) int
		SeedEpoch       func(childComplexity int) int
		SeedValue       func(childComplexity int) int
		SpID            func(childComplexity int) int
		TicketEpoch     func(childComplexity int) int
		TicketValue     func(childComplexity int) int
	}

	SectorMetaPiece struct {
		DdoPam            func(childComplexity int) int
		F05DealID         func(childComplexity int) int
		F05DealProposal   func(childComplexity int) int
		OrigEndEpoch      func(childComplexity int) int
		PieceCid          func(childComplexity int) int
		PieceNum          func(childComplexity int) int
		PieceSize         func(childComplexity int) int
		RawDataSize       func(childComplexity int) int
		RequestedKeepData func(childComplexity int) int
		SectorNum         func(childComplexity int) int
		SpID              func(childComplexity int) int
		StartEpoch        func(childComplexity int) int
	}

	SectorSummary struct {
		Active  func(childComplexity int) int
		Failed  func(childComplexity int) int
		Sealing func(childComplexity int) int
	}

	Storage struct {
		ID       func(childComplexity int) int
		Liveness func(childComplexity int) int
		Path     func(childComplexity int) int
	}

	StorageLiveness struct {
		LastChecked    func(childComplexity int) int
		LastDead       func(childComplexity int) int
		LastDeadReason func(childComplexity int) int
		LastLive       func(childComplexity int) int
		StorageID      func(childComplexity int) int
		URL            func(childComplexity int) int
	}

	StoragePath struct {
		AllowMiners   func(childComplexity int) int
		AllowTo       func(childComplexity int) int
		AllowTypes    func(childComplexity int) int
		Available     func(childComplexity int) int
		CanSeal       func(childComplexity int) int
		CanStore      func(childComplexity int) int
		Capacity      func(childComplexity int) int
		DenyMiners    func(childComplexity int) int
		DenyTypes     func(childComplexity int) int
		FsAvailable   func(childComplexity int) int
		Groups        func(childComplexity int) int
		HeartbeatErr  func(childComplexity int) int
		ID            func(childComplexity int) int
		LastHeartbeat func(childComplexity int) int
		MaxStorage    func(childComplexity int) int
		Reserved      func(childComplexity int) int
		StorageID     func(childComplexity int) int
		Type          func(childComplexity int) int
		Urls          func(childComplexity int) int
		Used          func(childComplexity int) int
		Weight        func(childComplexity int) int
	}

	StorageStats struct {
		TotalAvailable   func(childComplexity int) int
		TotalCapacity    func(childComplexity int) int
		TotalFsAvailable func(childComplexity int) int
		TotalReserved    func(childComplexity int) int
		TotalUsed        func(childComplexity int) int
		Type             func(childComplexity int) int
	}

	StorageUsage struct {
		Available   func(childComplexity int) int
		FsAvailable func(childComplexity int) int
		Reserved    func(childComplexity int) int
		Time        func(childComplexity int) int
		Used        func(childComplexity int) int
	}

	Subscription struct {
		Alerts        func(childComplexity int, offset int) int
		ChainHead     func(childComplexity int) int
		CompletedTask func(childComplexity int, machine *string, last int) int
		NewTask       func(childComplexity int, machineID *int, last int) int
	}

	Task struct {
		AddedBy        func(childComplexity int) int
		AddedByID      func(childComplexity int) int
		Histories      func(childComplexity int) int
		ID             func(childComplexity int) int
		InitiatedBy    func(childComplexity int) int
		InitiatedByID  func(childComplexity int) int
		Name           func(childComplexity int) int
		Owner          func(childComplexity int) int
		OwnerID        func(childComplexity int) int
		PostedTime     func(childComplexity int) int
		PreviousTask   func(childComplexity int) int
		PreviousTaskID func(childComplexity int) int
		UpdateTime     func(childComplexity int) int
	}

	TaskAggregate struct {
		Failure func(childComplexity int) int
		Success func(childComplexity int) int
		Time    func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	TaskCompactStage struct {
		Name   func(childComplexity int) int
		Status func(childComplexity int) int
		TaskID func(childComplexity int) int
	}

	TaskDurationStats struct {
		AvgDurationSeconds    func(childComplexity int) int
		MaxDurationSeconds    func(childComplexity int) int
		MedianDurationSeconds func(childComplexity int) int
		MinDurationSeconds    func(childComplexity int) int
		Name                  func(childComplexity int) int
		P90DurationSeconds    func(childComplexity int) int
		P95DurationSeconds    func(childComplexity int) int
		P99DurationSeconds    func(childComplexity int) int
		TotalTasks            func(childComplexity int) int
	}

	TaskHistory struct {
		CompletedBy            func(childComplexity int) int
		CompletedByHostAndPort func(childComplexity int) int
		Err                    func(childComplexity int) int
		ID                     func(childComplexity int) int
		Name                   func(childComplexity int) int
		Posted                 func(childComplexity int) int
		Result                 func(childComplexity int) int
		TaskID                 func(childComplexity int) int
		WorkEnd                func(childComplexity int) int
		WorkStart              func(childComplexity int) int
	}

	TaskNameAggregate struct {
		Failure func(childComplexity int) int
		Name    func(childComplexity int) int
		Success func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	TaskStats struct {
		Failure func(childComplexity int) int
		Name    func(childComplexity int) int
		Success func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	TaskSuccessRate struct {
		Failure     func(childComplexity int) int
		Success     func(childComplexity int) int
		SuccessRate func(childComplexity int) int
		Total       func(childComplexity int) int
	}

	TaskSummary struct {
		FalseCount func(childComplexity int) int
		Name       func(childComplexity int) int
		TotalCount func(childComplexity int) int
		TrueCount  func(childComplexity int) int
	}

	TaskSummaryDay struct {
		Day        func(childComplexity int) int
		FalseCount func(childComplexity int) int
		TotalCount func(childComplexity int) int
		TrueCount  func(childComplexity int) int
	}

	WalletBalance struct {
		Address func(childComplexity int) int
		Balance func(childComplexity int) int
	}

	WdpostProofs struct {
		Deadline           func(childComplexity int) int
		ID                 func(childComplexity int) int
		MessageCid         func(childComplexity int) int
		Partition          func(childComplexity int) int
		ProofParams        func(childComplexity int) int
		ProvingPeriodStart func(childComplexity int) int
		SpID               func(childComplexity int) int
		SubmitAtEpoch      func(childComplexity int) int
		SubmitByEpoch      func(childComplexity int) int
		SubmitTaskID       func(childComplexity int) int
		TestTaskID         func(childComplexity int) int
	}
}

type ActorResolver interface {
	ID(ctx context.Context, obj *model.Actor) (string, error)

	QualityAdjustedPower(ctx context.Context, obj *model.Actor) (*types.BigInt, error)
	RawBytePower(ctx context.Context, obj *model.Actor) (*types.BigInt, error)
	ActorBalance(ctx context.Context, obj *model.Actor) (*types.BigInt, error)
	ActorAvailableBalance(ctx context.Context, obj *model.Actor) (*types.BigInt, error)
	WorkerBalance(ctx context.Context, obj *model.Actor) (*types.BigInt, error)
	Deadlines(ctx context.Context, obj *model.Actor) ([]*model.ActorDeadline, error)
}
type ConfigResolver interface {
	UsedBy(ctx context.Context, obj *model.Config) ([]*model.MachineDetail, error)
}
type IPNIAdvertisementResolver interface {
	Provider(ctx context.Context, obj *model.IPNIAdvertisement) (*model.IPNIPeerID, error)
}
type IPNIProviderResolver interface {
	Head(ctx context.Context, obj *model.IPNIProvider) (string, error)
	AdCount(ctx context.Context, obj *model.IPNIProvider) (int, error)
	Status(ctx context.Context, obj *model.IPNIProvider) (model.IPNIProviderStatus, error)
}
type IPNIStatsResolver interface {
	TotalAdvertisements(ctx context.Context, obj *model.IPNIStats) (int, error)
	PreviousTotalAdvertisements(ctx context.Context, obj *model.IPNIStats) (int, error)
	Providers(ctx context.Context, obj *model.IPNIStats) (int, error)
	PreviousProviders(ctx context.Context, obj *model.IPNIStats) (int, error)
	Indexed(ctx context.Context, obj *model.IPNIStats) (int, error)
	PreviousIndexed(ctx context.Context, obj *model.IPNIStats) (int, error)
	Skipped(ctx context.Context, obj *model.IPNIStats) (int, error)
	PreviousSkipped(ctx context.Context, obj *model.IPNIStats) (int, error)
	PendingTasks(ctx context.Context, obj *model.IPNIStats) (int, error)
	PreviousPendingTasks(ctx context.Context, obj *model.IPNIStats) (int, error)
}
type MachineResolver interface {
	Detail(ctx context.Context, obj *model.Machine) (*model.MachineDetail, error)
	Tasks(ctx context.Context, obj *model.Machine) ([]*model.Task, error)
	TaskHistories(ctx context.Context, obj *model.Machine, last int) ([]*model.TaskHistory, error)
	Storages(ctx context.Context, obj *model.Machine) ([]*model.StoragePath, error)
	Metrics(ctx context.Context, obj *model.Machine) (*model.MachineMetrics, error)
}
type MachineDetailResolver interface {
	TasksArray(ctx context.Context, obj *model.MachineDetail) ([]string, error)

	LayersArray(ctx context.Context, obj *model.MachineDetail) ([]string, error)

	MinersArray(ctx context.Context, obj *model.MachineDetail) ([]string, error)
}
type MachineSummaryResolver interface {
	Total(ctx context.Context, obj *model.MachineSummary) (int, error)
	TotalUp(ctx context.Context, obj *model.MachineSummary) (int, error)
	TotalDown(ctx context.Context, obj *model.MachineSummary) (int, error)
	UniqueHostsTotal(ctx context.Context, obj *model.MachineSummary) (int, error)
	UniqueHostsUp(ctx context.Context, obj *model.MachineSummary) (int, error)
	UniqueHostsDown(ctx context.Context, obj *model.MachineSummary) (int, error)
	TotalRAM(ctx context.Context, obj *model.MachineSummary) (int, error)
	TotalCPU(ctx context.Context, obj *model.MachineSummary) (int, error)
	TotalGpu(ctx context.Context, obj *model.MachineSummary) (float64, error)
	UpdatedAt(ctx context.Context, obj *model.MachineSummary) (*time.Time, error)
}
type MessageWaitResolver interface {
	WaiterMachine(ctx context.Context, obj *model.MessageWait) (*model.Machine, error)
}
type MetadataResolver interface {
	NetworkName(ctx context.Context, obj *model.Metadata) (string, error)
	GenesisTimestamp(ctx context.Context, obj *model.Metadata) (uint64, error)
}
type MinerResolver interface {
	Info(ctx context.Context, obj *model.Miner) (*model.MinerInfo, error)
	Power(ctx context.Context, obj *model.Miner) (*model.MinerPower, error)
	Balance(ctx context.Context, obj *model.Miner) (*model.MinerBalance, error)
}
type MinerBalanceResolver interface {
	Balance(ctx context.Context, obj *model.MinerBalance) (*types.BigInt, error)
	Available(ctx context.Context, obj *model.MinerBalance) (*types.BigInt, error)
	InitialPledge(ctx context.Context, obj *model.MinerBalance) (*types.BigInt, error)
	Vesting(ctx context.Context, obj *model.MinerBalance) (*types.BigInt, error)
	PreCommitDeposits(ctx context.Context, obj *model.MinerBalance) (*types.BigInt, error)
}
type MiningCountSummaryResolver interface {
	Previous(ctx context.Context, obj *model.MiningCountSummary) (*model.MiningCountSummary, error)
}
type MutationResolver interface {
	CreateConfig(ctx context.Context, title string, config string) (*model.Config, error)
	UpdateConfig(ctx context.Context, title string, config string) (*model.Config, error)
	RemoveConfig(ctx context.Context, title string) (*model.Config, error)
	DealSealNow(ctx context.Context, miner types.Address, sectorNumber uint64) (bool, error)
	MarketAddBalance(ctx context.Context, miner types.Address, wallet types.Address, amount types.FIL) (*model.MarketBalance, error)
	UpdateMarketMk12StorageAsk(ctx context.Context, input model.MarketMk12StorageAskInput) (*model.MarketMk12StorageAsk, error)
	MarketAddPriceFilter(ctx context.Context, input model.PriceFilterInput) (bool, error)
	MarketUpdatePriceFilter(ctx context.Context, input model.PriceFilterInput) (*model.PriceFilter, error)
	MarketDeletePriceFilter(ctx context.Context, name string) (bool, error)
	MarketAddClientFilter(ctx context.Context, input model.ClientFilterInput) (bool, error)
	MarketUpdateClientFilter(ctx context.Context, input model.ClientFilterInput) (*model.ClientFilter, error)
	MarketDeleteClientFilter(ctx context.Context, name string) (bool, error)
	MarketToggleClientFilter(ctx context.Context, name string) (bool, error)
	MarketSetAllowFilter(ctx context.Context, wallet types.Address, status bool) (*model.MarketAllowFilter, error)
	MarketDeleteAllowFilter(ctx context.Context, wallet types.Address) (bool, error)
	MarketToggleAllowFilter(ctx context.Context, wallet types.Address) (bool, error)
	RemoveSector(ctx context.Context, miner types.Address, sectorNumber int) (bool, error)
	RestartSector(ctx context.Context, miner types.Address, sectorNumber int) (bool, error)
	RestartAllFailedSectors(ctx context.Context) (bool, error)
}
type PipelineSummaryResolver interface {
	Sdr(ctx context.Context, obj *model.PipelineSummary) (int, error)
	Trees(ctx context.Context, obj *model.PipelineSummary) (int, error)
	PrecommitMsg(ctx context.Context, obj *model.PipelineSummary) (int, error)
	WaitSeed(ctx context.Context, obj *model.PipelineSummary) (int, error)
	Porep(ctx context.Context, obj *model.PipelineSummary) (int, error)
	CommitMsg(ctx context.Context, obj *model.PipelineSummary) (int, error)
	Done(ctx context.Context, obj *model.PipelineSummary) (int, error)
	Failed(ctx context.Context, obj *model.PipelineSummary) (int, error)
}
type PorepResolver interface {
	ID(ctx context.Context, obj *model.Porep) (string, error)

	Status(ctx context.Context, obj *model.Porep) (model.TaskStatus, error)
	Stage(ctx context.Context, obj *model.Porep) (model.PorepStage, error)
	CurrentTask(ctx context.Context, obj *model.Porep) (*model.Task, error)
	CompactStages(ctx context.Context, obj *model.Porep) ([]*model.TaskCompactStage, error)
}
type QueryResolver interface {
	Actors(ctx context.Context) ([]*model.Actor, error)
	Actor(ctx context.Context, address types.Address) (*model.Actor, error)
	Alerts(ctx context.Context) ([]*model.Alert, error)
	Config(ctx context.Context, layer string) (*model.Config, error)
	Configs(ctx context.Context) ([]*model.Config, error)
	MarketMk12Deals(ctx context.Context, filter model.MarketMk12DealFilterInput, limit int, offset int) ([]*model.MarketMk12Deal, error)
	MarketMk12DealsCount(ctx context.Context, filter model.MarketMk12DealFilterInput) (int, error)
	MarketDealInfo(ctx context.Context, id string) (*model.DealInfo, error)
	MarketDealCountSummary(ctx context.Context) (*model.DealCountSummary, error)
	DealsPending(ctx context.Context) ([]*model.OpenSectorPiece, error)
	IpniStats(ctx context.Context) (*model.IPNIStats, error)
	IpniAdvertisement(ctx context.Context, orderNumber int) (*model.IPNIAdvertisement, error)
	IpniAdvertisements(ctx context.Context, offset int, limit int, provider *string, isSkip *bool, isRemoved *bool) ([]*model.IPNIAdvertisement, error)
	IpniAdvertisementsCount(ctx context.Context, provider *string, isSkip *bool, isRemoved *bool) (int, error)
	IpniTask(ctx context.Context, taskID int) (*model.IPNITask, error)
	IpniTasks(ctx context.Context, limit *int, spID *types.ActorID, isRm *bool) ([]*model.IPNITask, error)
	IpniTasksCount(ctx context.Context, spID *types.ActorID, isRm *bool) (int, error)
	IpniProviders(ctx context.Context) ([]*model.IPNIProvider, error)
	Machine(ctx context.Context, id int) (*model.Machine, error)
	MachineByHostAndPort(ctx context.Context, hostAndPort string) (*model.Machine, error)
	Machines(ctx context.Context) ([]*model.Machine, error)
	MachineSummary(ctx context.Context) (*model.MachineSummary, error)
	MarketBalance(ctx context.Context, miner types.Address) (*model.MarketBalance, error)
	MarketBalances(ctx context.Context) ([]*model.MarketBalance, error)
	MarketMk12StorageAsks(ctx context.Context) ([]*model.MarketMk12StorageAsk, error)
	MarketMk12StorageAsk(ctx context.Context, spID types.Address) (*model.MarketMk12StorageAsk, error)
	MarketMk12StorageAsksCount(ctx context.Context) (int, error)
	MakretPriceFilters(ctx context.Context) ([]*model.PriceFilter, error)
	MarketPriceFilter(ctx context.Context, name string) (*model.PriceFilter, error)
	MarketCheckPriceFilter(ctx context.Context, name string) (bool, error)
	MarketClientFilters(ctx context.Context) ([]*model.ClientFilter, error)
	MarketClientFilter(ctx context.Context, name string) (*model.ClientFilter, error)
	MarketCheckClientFilter(ctx context.Context, name string) (bool, error)
	MarketAllowFilters(ctx context.Context) ([]*model.MarketAllowFilter, error)
	MarketAllowFilter(ctx context.Context, wallet types.Address) (*model.MarketAllowFilter, error)
	MarketDefaultFilterBehaviour(ctx context.Context) (*model.DefaultFilterBehaviour, error)
	MessageSends(ctx context.Context, account *types.Address, offset int, limit int) ([]*model.MessageSend, error)
	MessageSendsCount(ctx context.Context, account *types.Address) (int, error)
	MessageSend(ctx context.Context, sendTaskID *int, fromKey *string, nonce *int, signedCid *string) (*model.MessageSend, error)
	MessageWaits(ctx context.Context, waiterMachineID *int, offset int, limit int) ([]*model.MessageWait, error)
	MessageWaitsCount(ctx context.Context, waiterMachineID *int) (int, error)
	MessageWait(ctx context.Context, signedMessageCid string) (*model.MessageWait, error)
	Metadata(ctx context.Context) (*model.Metadata, error)
	Miner(ctx context.Context, address types.Address) (*model.Miner, error)
	MinerPower(ctx context.Context, address *types.Address) (*model.MinerPower, error)
	MiningSummaryByDay(ctx context.Context, start time.Time, end time.Time) ([]*model.MiningSummaryDay, error)
	MiningCount(ctx context.Context, start time.Time, end time.Time, actor *types.Address) (*model.MiningCount, error)
	MiningWins(ctx context.Context, start *time.Time, end *time.Time, actor *types.Address, include *bool, offset int, limit int) ([]*model.MiningTask, error)
	MiningWinsCount(ctx context.Context, start *time.Time, end *time.Time, actor *types.Address, include *bool) (int, error)
	MiningCountSummary(ctx context.Context, start time.Time, end time.Time, actor *types.Address) (*model.MiningCountSummary, error)
	MiningCountAggregate(ctx context.Context, start time.Time, end time.Time, actor *types.Address, interval model.MiningTaskAggregateInterval) ([]*model.MiningCountAggregated, error)
	MiningStatusSummay(ctx context.Context, spID *types.ActorID, start time.Time, end time.Time) (*model.MiningStatusSummay, error)
	NodesInfo(ctx context.Context) ([]*model.NodeInfo, error)
	NodeHealthSummary(ctx context.Context) (*model.NodeHealthSummary, error)
	Poreps(ctx context.Context) ([]*model.Porep, error)
	Porep(ctx context.Context, sp types.Address, sectorNumber int) (*model.Porep, error)
	PipelinesSummary(ctx context.Context) ([]*model.PipelineSummary, error)
	PrometheusQuery(ctx context.Context, query string, time *time.Time) (*model.PrometheusResponse, error)
	PrometheusQueryRange(ctx context.Context, query string, start time.Time, end time.Time, step int) (*model.PrometheusResponse, error)
	Sectors(ctx context.Context, actor *types.Address, sectorNumber *int, offset int, limit int) ([]*model.Sector, error)
	SectorsCount(ctx context.Context, actor *types.Address) (int, error)
	Sector(ctx context.Context, actor types.Address, sectorNumber int) (*model.Sector, error)
	SectorSummary(ctx context.Context) (*model.SectorSummary, error)
	Storage(ctx context.Context, id string) (*model.Storage, error)
	Storages(ctx context.Context) ([]*model.Storage, error)
	StorageStats(ctx context.Context) ([]*model.StorageStats, error)
	Task(ctx context.Context, id int) (*model.Task, error)
	Tasks(ctx context.Context) ([]*model.Task, error)
	TasksCount(ctx context.Context) (int, error)
	TaskHistories(ctx context.Context, start *time.Time, end *time.Time, hostPort *string, name *string, result *bool, offset int, limit int) ([]*model.TaskHistory, error)
	TaskHistoriesCount(ctx context.Context, start *time.Time, end *time.Time, hostPort *string, name *string, result *bool) (int, error)
	TaskHistoriesAggregate(ctx context.Context, start time.Time, end time.Time, interval model.TaskHistoriesAggregateInterval) ([]*model.TaskAggregate, error)
	TasksStats(ctx context.Context, start time.Time, end time.Time, machine *string) ([]*model.TaskStats, error)
	TaskNames(ctx context.Context) ([]string, error)
	TaskSuccessRate(ctx context.Context, name *string, start time.Time, end time.Time) (*model.TaskSuccessRate, error)
	RunningTaskSummary(ctx context.Context) (*model.RunningTaskSummary, error)
	TaskDurationStats(ctx context.Context, name string, start time.Time, end time.Time) (*model.TaskDurationStats, error)
	TasksDurationStats(ctx context.Context, start time.Time, end time.Time) ([]*model.TaskDurationStats, error)
	WdpostProof(ctx context.Context, spID types.Address, provingPeriodStart int, deadline int, partition int) (*model.WdpostProofs, error)
	WdpostProofs(ctx context.Context, spID *types.Address, offset int, limit int) ([]*model.WdpostProofs, error)
	WdpostProofsCount(ctx context.Context, spID *types.Address) (int, error)
}
type SectorResolver interface {
	ID(ctx context.Context, obj *model.Sector) (string, error)

	Status(ctx context.Context, obj *model.Sector) (model.TaskStatus, error)
	Meta(ctx context.Context, obj *model.Sector) (*model.SectorMeta, error)
	Porep(ctx context.Context, obj *model.Sector) (*model.Porep, error)
	Locations(ctx context.Context, obj *model.Sector) ([]*model.SectorLocation, error)
	Pieces(ctx context.Context, obj *model.Sector) ([]*model.SectorMetaPiece, error)
	Tasks(ctx context.Context, obj *model.Sector) ([]*model.Task, error)
	Events(ctx context.Context, obj *model.Sector) ([]*model.TaskHistory, error)
}
type SectorLocationResolver interface {
	Storage(ctx context.Context, obj *model.SectorLocation) (*model.Storage, error)
}
type SectorMetaResolver interface {
	ID(ctx context.Context, obj *model.SectorMeta) (string, error)
}
type StorageResolver interface {
	Path(ctx context.Context, obj *model.Storage) (*model.StoragePath, error)
	Liveness(ctx context.Context, obj *model.Storage) (*model.StorageLiveness, error)
}
type StoragePathResolver interface {
	Type(ctx context.Context, obj *model.StoragePath) (model.StorageType, error)
}
type SubscriptionResolver interface {
	Alerts(ctx context.Context, offset int) (<-chan *model.Alert, error)
	ChainHead(ctx context.Context) (<-chan *model.ChainHead, error)
	CompletedTask(ctx context.Context, machine *string, last int) (<-chan *model.TaskHistory, error)
	NewTask(ctx context.Context, machineID *int, last int) (<-chan *model.Task, error)
}
type TaskResolver interface {
	InitiatedBy(ctx context.Context, obj *model.Task) (*model.Machine, error)

	Owner(ctx context.Context, obj *model.Task) (*model.Machine, error)

	AddedBy(ctx context.Context, obj *model.Task) (*model.Machine, error)

	PreviousTask(ctx context.Context, obj *model.Task) (*model.TaskHistory, error)

	Histories(ctx context.Context, obj *model.Task) ([]*model.TaskHistory, error)
}
type TaskHistoryResolver interface {
	CompletedBy(ctx context.Context, obj *model.TaskHistory) (*model.Machine, error)
}
type WdpostProofsResolver interface {
	ID(ctx context.Context, obj *model.WdpostProofs) (string, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Actor.actorAvailableBalance":
		if e.complexity.Actor.ActorAvailableBalance == nil {
			break
		}

		return e.complexity.Actor.ActorAvailableBalance(childComplexity), true

	case "Actor.actorBalance":
		if e.complexity.Actor.ActorBalance == nil {
			break
		}

		return e.complexity.Actor.ActorBalance(childComplexity), true

	case "Actor.address":
		if e.complexity.Actor.Address == nil {
			break
		}

		return e.complexity.Actor.Address(childComplexity), true

	case "Actor.deadlines":
		if e.complexity.Actor.Deadlines == nil {
			break
		}

		return e.complexity.Actor.Deadlines(childComplexity), true

	case "Actor.id":
		if e.complexity.Actor.ID == nil {
			break
		}

		return e.complexity.Actor.ID(childComplexity), true

	case "Actor.layers":
		if e.complexity.Actor.Layers == nil {
			break
		}

		return e.complexity.Actor.Layers(childComplexity), true

	case "Actor.qualityAdjustedPower":
		if e.complexity.Actor.QualityAdjustedPower == nil {
			break
		}

		return e.complexity.Actor.QualityAdjustedPower(childComplexity), true

	case "Actor.rawBytePower":
		if e.complexity.Actor.RawBytePower == nil {
			break
		}

		return e.complexity.Actor.RawBytePower(childComplexity), true

	case "Actor.workerBalance":
		if e.complexity.Actor.WorkerBalance == nil {
			break
		}

		return e.complexity.Actor.WorkerBalance(childComplexity), true

	case "ActorDeadline.current":
		if e.complexity.ActorDeadline.Current == nil {
			break
		}

		return e.complexity.ActorDeadline.Current(childComplexity), true

	case "ActorDeadline.empty":
		if e.complexity.ActorDeadline.Empty == nil {
			break
		}

		return e.complexity.ActorDeadline.Empty(childComplexity), true

	case "ActorDeadline.faulty":
		if e.complexity.ActorDeadline.Faulty == nil {
			break
		}

		return e.complexity.ActorDeadline.Faulty(childComplexity), true

	case "ActorDeadline.partFaulty":
		if e.complexity.ActorDeadline.PartFaulty == nil {
			break
		}

		return e.complexity.ActorDeadline.PartFaulty(childComplexity), true

	case "ActorDeadline.proven":
		if e.complexity.ActorDeadline.Proven == nil {
			break
		}

		return e.complexity.ActorDeadline.Proven(childComplexity), true

	case "Alert.id":
		if e.complexity.Alert.ID == nil {
			break
		}

		return e.complexity.Alert.ID(childComplexity), true

	case "Alert.machineName":
		if e.complexity.Alert.MachineName == nil {
			break
		}

		return e.complexity.Alert.MachineName(childComplexity), true

	case "Alert.message":
		if e.complexity.Alert.Message == nil {
			break
		}

		return e.complexity.Alert.Message(childComplexity), true

	case "ChainHead.height":
		if e.complexity.ChainHead.Height == nil {
			break
		}

		return e.complexity.ChainHead.Height(childComplexity), true

	case "ChainHead.timestamp":
		if e.complexity.ChainHead.Timestamp == nil {
			break
		}

		return e.complexity.ChainHead.Timestamp(childComplexity), true

	case "CidGravityStatus.miner":
		if e.complexity.CidGravityStatus.Miner == nil {
			break
		}

		return e.complexity.CidGravityStatus.Miner(childComplexity), true

	case "CidGravityStatus.status":
		if e.complexity.CidGravityStatus.Status == nil {
			break
		}

		return e.complexity.CidGravityStatus.Status(childComplexity), true

	case "ClientFilter.active":
		if e.complexity.ClientFilter.Active == nil {
			break
		}

		return e.complexity.ClientFilter.Active(childComplexity), true

	case "ClientFilter.info":
		if e.complexity.ClientFilter.Info == nil {
			break
		}

		return e.complexity.ClientFilter.Info(childComplexity), true

	case "ClientFilter.maxDealSizePerHour":
		if e.complexity.ClientFilter.MaxDealSizePerHour == nil {
			break
		}

		return e.complexity.ClientFilter.MaxDealSizePerHour(childComplexity), true

	case "ClientFilter.maxDealsPerHour":
		if e.complexity.ClientFilter.MaxDealsPerHour == nil {
			break
		}

		return e.complexity.ClientFilter.MaxDealsPerHour(childComplexity), true

	case "ClientFilter.name":
		if e.complexity.ClientFilter.Name == nil {
			break
		}

		return e.complexity.ClientFilter.Name(childComplexity), true

	case "ClientFilter.peers":
		if e.complexity.ClientFilter.Peers == nil {
			break
		}

		return e.complexity.ClientFilter.Peers(childComplexity), true

	case "ClientFilter.pricingFilters":
		if e.complexity.ClientFilter.PricingFilters == nil {
			break
		}

		return e.complexity.ClientFilter.PricingFilters(childComplexity), true

	case "ClientFilter.wallets":
		if e.complexity.ClientFilter.Wallets == nil {
			break
		}

		return e.complexity.ClientFilter.Wallets(childComplexity), true

	case "Config.config":
		if e.complexity.Config.Config == nil {
			break
		}

		return e.complexity.Config.Config(childComplexity), true

	case "Config.id":
		if e.complexity.Config.ID == nil {
			break
		}

		return e.complexity.Config.ID(childComplexity), true

	case "Config.title":
		if e.complexity.Config.Title == nil {
			break
		}

		return e.complexity.Config.Title(childComplexity), true

	case "Config.usedBy":
		if e.complexity.Config.UsedBy == nil {
			break
		}

		return e.complexity.Config.UsedBy(childComplexity), true

	case "DealCountSummary.boost":
		if e.complexity.DealCountSummary.Boost == nil {
			break
		}

		return e.complexity.DealCountSummary.Boost(childComplexity), true

	case "DealCountSummary.direct":
		if e.complexity.DealCountSummary.Direct == nil {
			break
		}

		return e.complexity.DealCountSummary.Direct(childComplexity), true

	case "DealCountSummary.legacy":
		if e.complexity.DealCountSummary.Legacy == nil {
			break
		}

		return e.complexity.DealCountSummary.Legacy(childComplexity), true

	case "DealInfo.announceToIpni":
		if e.complexity.DealInfo.AnnounceToIpni == nil {
			break
		}

		return e.complexity.DealInfo.AnnounceToIpni(childComplexity), true

	case "DealInfo.chainDealId":
		if e.complexity.DealInfo.ChainDealID == nil {
			break
		}

		return e.complexity.DealInfo.ChainDealID(childComplexity), true

	case "DealInfo.clientPeerId":
		if e.complexity.DealInfo.ClientPeerID == nil {
			break
		}

		return e.complexity.DealInfo.ClientPeerID(childComplexity), true

	case "DealInfo.createdAt":
		if e.complexity.DealInfo.CreatedAt == nil {
			break
		}

		return e.complexity.DealInfo.CreatedAt(childComplexity), true

	case "DealInfo.endEpoch":
		if e.complexity.DealInfo.EndEpoch == nil {
			break
		}

		return e.complexity.DealInfo.EndEpoch(childComplexity), true

	case "DealInfo.error":
		if e.complexity.DealInfo.Error == nil {
			break
		}

		return e.complexity.DealInfo.Error(childComplexity), true

	case "DealInfo.fastRetrieval":
		if e.complexity.DealInfo.FastRetrieval == nil {
			break
		}

		return e.complexity.DealInfo.FastRetrieval(childComplexity), true

	case "DealInfo.id":
		if e.complexity.DealInfo.ID == nil {
			break
		}

		return e.complexity.DealInfo.ID(childComplexity), true

	case "DealInfo.indexed":
		if e.complexity.DealInfo.Indexed == nil {
			break
		}

		return e.complexity.DealInfo.Indexed(childComplexity), true

	case "DealInfo.isDdo":
		if e.complexity.DealInfo.IsDdo == nil {
			break
		}

		return e.complexity.DealInfo.IsDdo(childComplexity), true

	case "DealInfo.isLegacy":
		if e.complexity.DealInfo.IsLegacy == nil {
			break
		}

		return e.complexity.DealInfo.IsLegacy(childComplexity), true

	case "DealInfo.miner":
		if e.complexity.DealInfo.Miner == nil {
			break
		}

		return e.complexity.DealInfo.Miner(childComplexity), true

	case "DealInfo.offline":
		if e.complexity.DealInfo.Offline == nil {
			break
		}

		return e.complexity.DealInfo.Offline(childComplexity), true

	case "DealInfo.pieceCid":
		if e.complexity.DealInfo.PieceCid == nil {
			break
		}

		return e.complexity.DealInfo.PieceCid(childComplexity), true

	case "DealInfo.pieceSize":
		if e.complexity.DealInfo.PieceSize == nil {
			break
		}

		return e.complexity.DealInfo.PieceSize(childComplexity), true

	case "DealInfo.publishCid":
		if e.complexity.DealInfo.PublishCid == nil {
			break
		}

		return e.complexity.DealInfo.PublishCid(childComplexity), true

	case "DealInfo.sector":
		if e.complexity.DealInfo.Sector == nil {
			break
		}

		return e.complexity.DealInfo.Sector(childComplexity), true

	case "DealInfo.signedProposalCid":
		if e.complexity.DealInfo.SignedProposalCid == nil {
			break
		}

		return e.complexity.DealInfo.SignedProposalCid(childComplexity), true

	case "DealInfo.spId":
		if e.complexity.DealInfo.SpID == nil {
			break
		}

		return e.complexity.DealInfo.SpID(childComplexity), true

	case "DealInfo.startEpoch":
		if e.complexity.DealInfo.StartEpoch == nil {
			break
		}

		return e.complexity.DealInfo.StartEpoch(childComplexity), true

	case "DealInfo.url":
		if e.complexity.DealInfo.URL == nil {
			break
		}

		return e.complexity.DealInfo.URL(childComplexity), true

	case "DealInfo.urlHeaders":
		if e.complexity.DealInfo.URLHeaders == nil {
			break
		}

		return e.complexity.DealInfo.URLHeaders(childComplexity), true

	case "DealInfo.urls":
		if e.complexity.DealInfo.Urls == nil {
			break
		}

		return e.complexity.DealInfo.Urls(childComplexity), true

	case "DealInfo.verified":
		if e.complexity.DealInfo.Verified == nil {
			break
		}

		return e.complexity.DealInfo.Verified(childComplexity), true

	case "DefaultFilterBehaviour.allowDealsFromUnknownClients":
		if e.complexity.DefaultFilterBehaviour.AllowDealsFromUnknownClients == nil {
			break
		}

		return e.complexity.DefaultFilterBehaviour.AllowDealsFromUnknownClients(childComplexity), true

	case "DefaultFilterBehaviour.isCidGravityEnabled":
		if e.complexity.DefaultFilterBehaviour.IsCidGravityEnabled == nil {
			break
		}

		return e.complexity.DefaultFilterBehaviour.IsCidGravityEnabled(childComplexity), true

	case "DefaultFilterBehaviour.isDealRejectedWhenCidGravityNotReachable":
		if e.complexity.DefaultFilterBehaviour.IsDealRejectedWhenCidGravityNotReachable == nil {
			break
		}

		return e.complexity.DefaultFilterBehaviour.IsDealRejectedWhenCidGravityNotReachable(childComplexity), true

	case "GaugeCountValue.key":
		if e.complexity.GaugeCountValue.Key == nil {
			break
		}

		return e.complexity.GaugeCountValue.Key(childComplexity), true

	case "GaugeCountValue.value":
		if e.complexity.GaugeCountValue.Value == nil {
			break
		}

		return e.complexity.GaugeCountValue.Value(childComplexity), true

	case "IPNIAdvertisement.adCid":
		if e.complexity.IPNIAdvertisement.AdCid == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.AdCid(childComplexity), true

	case "IPNIAdvertisement.addresses":
		if e.complexity.IPNIAdvertisement.Addresses == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.Addresses(childComplexity), true

	case "IPNIAdvertisement.contextId":
		if e.complexity.IPNIAdvertisement.ContextID == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.ContextID(childComplexity), true

	case "IPNIAdvertisement.entries":
		if e.complexity.IPNIAdvertisement.Entries == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.Entries(childComplexity), true

	case "IPNIAdvertisement.isRm":
		if e.complexity.IPNIAdvertisement.IsRm == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.IsRm(childComplexity), true

	case "IPNIAdvertisement.isSkip":
		if e.complexity.IPNIAdvertisement.IsSkip == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.IsSkip(childComplexity), true

	case "IPNIAdvertisement.orderNumber":
		if e.complexity.IPNIAdvertisement.OrderNumber == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.OrderNumber(childComplexity), true

	case "IPNIAdvertisement.pieceCid":
		if e.complexity.IPNIAdvertisement.PieceCid == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.PieceCid(childComplexity), true

	case "IPNIAdvertisement.pieceSize":
		if e.complexity.IPNIAdvertisement.PieceSize == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.PieceSize(childComplexity), true

	case "IPNIAdvertisement.previous":
		if e.complexity.IPNIAdvertisement.Previous == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.Previous(childComplexity), true

	case "IPNIAdvertisement.provider":
		if e.complexity.IPNIAdvertisement.Provider == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.Provider(childComplexity), true

	case "IPNIAdvertisement.providerPeerID":
		if e.complexity.IPNIAdvertisement.ProviderPeerID == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.ProviderPeerID(childComplexity), true

	case "IPNIAdvertisement.signature":
		if e.complexity.IPNIAdvertisement.Signature == nil {
			break
		}

		return e.complexity.IPNIAdvertisement.Signature(childComplexity), true

	case "IPNIHead.head":
		if e.complexity.IPNIHead.Head == nil {
			break
		}

		return e.complexity.IPNIHead.Head(childComplexity), true

	case "IPNIHead.provider":
		if e.complexity.IPNIHead.Provider == nil {
			break
		}

		return e.complexity.IPNIHead.Provider(childComplexity), true

	case "IPNIPeerID.peerID":
		if e.complexity.IPNIPeerID.PeerID == nil {
			break
		}

		return e.complexity.IPNIPeerID.PeerID(childComplexity), true

	case "IPNIPeerID.spID":
		if e.complexity.IPNIPeerID.SpID == nil {
			break
		}

		return e.complexity.IPNIPeerID.SpID(childComplexity), true

	case "IPNIProvider.adCount":
		if e.complexity.IPNIProvider.AdCount == nil {
			break
		}

		return e.complexity.IPNIProvider.AdCount(childComplexity), true

	case "IPNIProvider.head":
		if e.complexity.IPNIProvider.Head == nil {
			break
		}

		return e.complexity.IPNIProvider.Head(childComplexity), true

	case "IPNIProvider.peerID":
		if e.complexity.IPNIProvider.PeerID == nil {
			break
		}

		return e.complexity.IPNIProvider.PeerID(childComplexity), true

	case "IPNIProvider.spID":
		if e.complexity.IPNIProvider.SpID == nil {
			break
		}

		return e.complexity.IPNIProvider.SpID(childComplexity), true

	case "IPNIProvider.status":
		if e.complexity.IPNIProvider.Status == nil {
			break
		}

		return e.complexity.IPNIProvider.Status(childComplexity), true

	case "IPNIStats.indexed":
		if e.complexity.IPNIStats.Indexed == nil {
			break
		}

		return e.complexity.IPNIStats.Indexed(childComplexity), true

	case "IPNIStats.pendingTasks":
		if e.complexity.IPNIStats.PendingTasks == nil {
			break
		}

		return e.complexity.IPNIStats.PendingTasks(childComplexity), true

	case "IPNIStats.previousIndexed":
		if e.complexity.IPNIStats.PreviousIndexed == nil {
			break
		}

		return e.complexity.IPNIStats.PreviousIndexed(childComplexity), true

	case "IPNIStats.previousPendingTasks":
		if e.complexity.IPNIStats.PreviousPendingTasks == nil {
			break
		}

		return e.complexity.IPNIStats.PreviousPendingTasks(childComplexity), true

	case "IPNIStats.previousProviders":
		if e.complexity.IPNIStats.PreviousProviders == nil {
			break
		}

		return e.complexity.IPNIStats.PreviousProviders(childComplexity), true

	case "IPNIStats.previousSkipped":
		if e.complexity.IPNIStats.PreviousSkipped == nil {
			break
		}

		return e.complexity.IPNIStats.PreviousSkipped(childComplexity), true

	case "IPNIStats.previousTotalAdvertisements":
		if e.complexity.IPNIStats.PreviousTotalAdvertisements == nil {
			break
		}

		return e.complexity.IPNIStats.PreviousTotalAdvertisements(childComplexity), true

	case "IPNIStats.providers":
		if e.complexity.IPNIStats.Providers == nil {
			break
		}

		return e.complexity.IPNIStats.Providers(childComplexity), true

	case "IPNIStats.skipped":
		if e.complexity.IPNIStats.Skipped == nil {
			break
		}

		return e.complexity.IPNIStats.Skipped(childComplexity), true

	case "IPNIStats.totalAdvertisements":
		if e.complexity.IPNIStats.TotalAdvertisements == nil {
			break
		}

		return e.complexity.IPNIStats.TotalAdvertisements(childComplexity), true

	case "IPNITask.complete":
		if e.complexity.IPNITask.Complete == nil {
			break
		}

		return e.complexity.IPNITask.Complete(childComplexity), true

	case "IPNITask.contextId":
		if e.complexity.IPNITask.ContextID == nil {
			break
		}

		return e.complexity.IPNITask.ContextID(childComplexity), true

	case "IPNITask.createdAt":
		if e.complexity.IPNITask.CreatedAt == nil {
			break
		}

		return e.complexity.IPNITask.CreatedAt(childComplexity), true

	case "IPNITask.isRm":
		if e.complexity.IPNITask.IsRm == nil {
			break
		}

		return e.complexity.IPNITask.IsRm(childComplexity), true

	case "IPNITask.provider":
		if e.complexity.IPNITask.Provider == nil {
			break
		}

		return e.complexity.IPNITask.Provider(childComplexity), true

	case "IPNITask.regSealProof":
		if e.complexity.IPNITask.RegSealProof == nil {
			break
		}

		return e.complexity.IPNITask.RegSealProof(childComplexity), true

	case "IPNITask.sector":
		if e.complexity.IPNITask.Sector == nil {
			break
		}

		return e.complexity.IPNITask.Sector(childComplexity), true

	case "IPNITask.sectorOffset":
		if e.complexity.IPNITask.SectorOffset == nil {
			break
		}

		return e.complexity.IPNITask.SectorOffset(childComplexity), true

	case "IPNITask.spId":
		if e.complexity.IPNITask.SpID == nil {
			break
		}

		return e.complexity.IPNITask.SpID(childComplexity), true

	case "IPNITask.taskId":
		if e.complexity.IPNITask.TaskID == nil {
			break
		}

		return e.complexity.IPNITask.TaskID(childComplexity), true

	case "Machine.cpu":
		if e.complexity.Machine.CPU == nil {
			break
		}

		return e.complexity.Machine.CPU(childComplexity), true

	case "Machine.detail":
		if e.complexity.Machine.Detail == nil {
			break
		}

		return e.complexity.Machine.Detail(childComplexity), true

	case "Machine.gpu":
		if e.complexity.Machine.Gpu == nil {
			break
		}

		return e.complexity.Machine.Gpu(childComplexity), true

	case "Machine.hostAndPort":
		if e.complexity.Machine.HostAndPort == nil {
			break
		}

		return e.complexity.Machine.HostAndPort(childComplexity), true

	case "Machine.id":
		if e.complexity.Machine.ID == nil {
			break
		}

		return e.complexity.Machine.ID(childComplexity), true

	case "Machine.lastContact":
		if e.complexity.Machine.LastContact == nil {
			break
		}

		return e.complexity.Machine.LastContact(childComplexity), true

	case "Machine.metrics":
		if e.complexity.Machine.Metrics == nil {
			break
		}

		return e.complexity.Machine.Metrics(childComplexity), true

	case "Machine.ram":
		if e.complexity.Machine.RAM == nil {
			break
		}

		return e.complexity.Machine.RAM(childComplexity), true

	case "Machine.storages":
		if e.complexity.Machine.Storages == nil {
			break
		}

		return e.complexity.Machine.Storages(childComplexity), true

	case "Machine.taskHistories":
		if e.complexity.Machine.TaskHistories == nil {
			break
		}

		args, err := ec.field_Machine_taskHistories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Machine.TaskHistories(childComplexity, args["last"].(int)), true

	case "Machine.tasks":
		if e.complexity.Machine.Tasks == nil {
			break
		}

		return e.complexity.Machine.Tasks(childComplexity), true

	case "MachineDetail.id":
		if e.complexity.MachineDetail.ID == nil {
			break
		}

		return e.complexity.MachineDetail.ID(childComplexity), true

	case "MachineDetail.layers":
		if e.complexity.MachineDetail.Layers == nil {
			break
		}

		return e.complexity.MachineDetail.Layers(childComplexity), true

	case "MachineDetail.layersArray":
		if e.complexity.MachineDetail.LayersArray == nil {
			break
		}

		return e.complexity.MachineDetail.LayersArray(childComplexity), true

	case "MachineDetail.machineId":
		if e.complexity.MachineDetail.MachineID == nil {
			break
		}

		return e.complexity.MachineDetail.MachineID(childComplexity), true

	case "MachineDetail.machineName":
		if e.complexity.MachineDetail.MachineName == nil {
			break
		}

		return e.complexity.MachineDetail.MachineName(childComplexity), true

	case "MachineDetail.miners":
		if e.complexity.MachineDetail.Miners == nil {
			break
		}

		return e.complexity.MachineDetail.Miners(childComplexity), true

	case "MachineDetail.minersArray":
		if e.complexity.MachineDetail.MinersArray == nil {
			break
		}

		return e.complexity.MachineDetail.MinersArray(childComplexity), true

	case "MachineDetail.startupTime":
		if e.complexity.MachineDetail.StartupTime == nil {
			break
		}

		return e.complexity.MachineDetail.StartupTime(childComplexity), true

	case "MachineDetail.tasks":
		if e.complexity.MachineDetail.Tasks == nil {
			break
		}

		return e.complexity.MachineDetail.Tasks(childComplexity), true

	case "MachineDetail.tasksArray":
		if e.complexity.MachineDetail.TasksArray == nil {
			break
		}

		return e.complexity.MachineDetail.TasksArray(childComplexity), true

	case "MachineMetrics.activeTasks":
		if e.complexity.MachineMetrics.ActiveTasks == nil {
			break
		}

		return e.complexity.MachineMetrics.ActiveTasks(childComplexity), true

	case "MachineMetrics.addedTasks":
		if e.complexity.MachineMetrics.AddedTasks == nil {
			break
		}

		return e.complexity.MachineMetrics.AddedTasks(childComplexity), true

	case "MachineMetrics.cpuUsage":
		if e.complexity.MachineMetrics.CPUUsage == nil {
			break
		}

		return e.complexity.MachineMetrics.CPUUsage(childComplexity), true

	case "MachineMetrics.goRoutines":
		if e.complexity.MachineMetrics.GoRoutines == nil {
			break
		}

		return e.complexity.MachineMetrics.GoRoutines(childComplexity), true

	case "MachineMetrics.goThreads":
		if e.complexity.MachineMetrics.GoThreads == nil {
			break
		}

		return e.complexity.MachineMetrics.GoThreads(childComplexity), true

	case "MachineMetrics.goVersion":
		if e.complexity.MachineMetrics.GoVersion == nil {
			break
		}

		return e.complexity.MachineMetrics.GoVersion(childComplexity), true

	case "MachineMetrics.gpuUsage":
		if e.complexity.MachineMetrics.GpuUsage == nil {
			break
		}

		return e.complexity.MachineMetrics.GpuUsage(childComplexity), true

	case "MachineMetrics.processCpuSecondsTotal":
		if e.complexity.MachineMetrics.ProcessCPUSecondsTotal == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessCPUSecondsTotal(childComplexity), true

	case "MachineMetrics.processMaxFds":
		if e.complexity.MachineMetrics.ProcessMaxFds == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessMaxFds(childComplexity), true

	case "MachineMetrics.processOpenFds":
		if e.complexity.MachineMetrics.ProcessOpenFds == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessOpenFds(childComplexity), true

	case "MachineMetrics.processResidentMemoryBytes":
		if e.complexity.MachineMetrics.ProcessResidentMemoryBytes == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessResidentMemoryBytes(childComplexity), true

	case "MachineMetrics.processStartTimeSeconds":
		if e.complexity.MachineMetrics.ProcessStartTimeSeconds == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessStartTimeSeconds(childComplexity), true

	case "MachineMetrics.processVirtualMemoryBytes":
		if e.complexity.MachineMetrics.ProcessVirtualMemoryBytes == nil {
			break
		}

		return e.complexity.MachineMetrics.ProcessVirtualMemoryBytes(childComplexity), true

	case "MachineMetrics.ramUsage":
		if e.complexity.MachineMetrics.RAMUsage == nil {
			break
		}

		return e.complexity.MachineMetrics.RAMUsage(childComplexity), true

	case "MachineMetrics.tasksCompleted":
		if e.complexity.MachineMetrics.TasksCompleted == nil {
			break
		}

		return e.complexity.MachineMetrics.TasksCompleted(childComplexity), true

	case "MachineMetrics.tasksStarted":
		if e.complexity.MachineMetrics.TasksStarted == nil {
			break
		}

		return e.complexity.MachineMetrics.TasksStarted(childComplexity), true

	case "MachineSummary.total":
		if e.complexity.MachineSummary.Total == nil {
			break
		}

		return e.complexity.MachineSummary.Total(childComplexity), true

	case "MachineSummary.totalCpu":
		if e.complexity.MachineSummary.TotalCPU == nil {
			break
		}

		return e.complexity.MachineSummary.TotalCPU(childComplexity), true

	case "MachineSummary.totalDown":
		if e.complexity.MachineSummary.TotalDown == nil {
			break
		}

		return e.complexity.MachineSummary.TotalDown(childComplexity), true

	case "MachineSummary.totalGpu":
		if e.complexity.MachineSummary.TotalGpu == nil {
			break
		}

		return e.complexity.MachineSummary.TotalGpu(childComplexity), true

	case "MachineSummary.totalRam":
		if e.complexity.MachineSummary.TotalRAM == nil {
			break
		}

		return e.complexity.MachineSummary.TotalRAM(childComplexity), true

	case "MachineSummary.totalUp":
		if e.complexity.MachineSummary.TotalUp == nil {
			break
		}

		return e.complexity.MachineSummary.TotalUp(childComplexity), true

	case "MachineSummary.uniqueHostsDown":
		if e.complexity.MachineSummary.UniqueHostsDown == nil {
			break
		}

		return e.complexity.MachineSummary.UniqueHostsDown(childComplexity), true

	case "MachineSummary.uniqueHostsTotal":
		if e.complexity.MachineSummary.UniqueHostsTotal == nil {
			break
		}

		return e.complexity.MachineSummary.UniqueHostsTotal(childComplexity), true

	case "MachineSummary.uniqueHostsUp":
		if e.complexity.MachineSummary.UniqueHostsUp == nil {
			break
		}

		return e.complexity.MachineSummary.UniqueHostsUp(childComplexity), true

	case "MachineSummary.updatedAt":
		if e.complexity.MachineSummary.UpdatedAt == nil {
			break
		}

		return e.complexity.MachineSummary.UpdatedAt(childComplexity), true

	case "MarketAllowFilter.status":
		if e.complexity.MarketAllowFilter.Status == nil {
			break
		}

		return e.complexity.MarketAllowFilter.Status(childComplexity), true

	case "MarketAllowFilter.wallet":
		if e.complexity.MarketAllowFilter.Wallet == nil {
			break
		}

		return e.complexity.MarketAllowFilter.Wallet(childComplexity), true

	case "MarketBalance.balance":
		if e.complexity.MarketBalance.Balance == nil {
			break
		}

		return e.complexity.MarketBalance.Balance(childComplexity), true

	case "MarketBalance.balances":
		if e.complexity.MarketBalance.Balances == nil {
			break
		}

		return e.complexity.MarketBalance.Balances(childComplexity), true

	case "MarketBalance.miner":
		if e.complexity.MarketBalance.Miner == nil {
			break
		}

		return e.complexity.MarketBalance.Miner(childComplexity), true

	case "MarketMk12Deal.announceToIpni":
		if e.complexity.MarketMk12Deal.AnnounceToIpni == nil {
			break
		}

		return e.complexity.MarketMk12Deal.AnnounceToIpni(childComplexity), true

	case "MarketMk12Deal.chainDealId":
		if e.complexity.MarketMk12Deal.ChainDealID == nil {
			break
		}

		return e.complexity.MarketMk12Deal.ChainDealID(childComplexity), true

	case "MarketMk12Deal.clientPeerId":
		if e.complexity.MarketMk12Deal.ClientPeerID == nil {
			break
		}

		return e.complexity.MarketMk12Deal.ClientPeerID(childComplexity), true

	case "MarketMk12Deal.createdAt":
		if e.complexity.MarketMk12Deal.CreatedAt == nil {
			break
		}

		return e.complexity.MarketMk12Deal.CreatedAt(childComplexity), true

	case "MarketMk12Deal.endEpoch":
		if e.complexity.MarketMk12Deal.EndEpoch == nil {
			break
		}

		return e.complexity.MarketMk12Deal.EndEpoch(childComplexity), true

	case "MarketMk12Deal.error":
		if e.complexity.MarketMk12Deal.Error == nil {
			break
		}

		return e.complexity.MarketMk12Deal.Error(childComplexity), true

	case "MarketMk12Deal.fastRetrieval":
		if e.complexity.MarketMk12Deal.FastRetrieval == nil {
			break
		}

		return e.complexity.MarketMk12Deal.FastRetrieval(childComplexity), true

	case "MarketMk12Deal.label":
		if e.complexity.MarketMk12Deal.Label == nil {
			break
		}

		return e.complexity.MarketMk12Deal.Label(childComplexity), true

	case "MarketMk12Deal.offline":
		if e.complexity.MarketMk12Deal.Offline == nil {
			break
		}

		return e.complexity.MarketMk12Deal.Offline(childComplexity), true

	case "MarketMk12Deal.pieceCid":
		if e.complexity.MarketMk12Deal.PieceCid == nil {
			break
		}

		return e.complexity.MarketMk12Deal.PieceCid(childComplexity), true

	case "MarketMk12Deal.pieceSize":
		if e.complexity.MarketMk12Deal.PieceSize == nil {
			break
		}

		return e.complexity.MarketMk12Deal.PieceSize(childComplexity), true

	case "MarketMk12Deal.proposal":
		if e.complexity.MarketMk12Deal.Proposal == nil {
			break
		}

		return e.complexity.MarketMk12Deal.Proposal(childComplexity), true

	case "MarketMk12Deal.proposalCid":
		if e.complexity.MarketMk12Deal.ProposalCid == nil {
			break
		}

		return e.complexity.MarketMk12Deal.ProposalCid(childComplexity), true

	case "MarketMk12Deal.proposalSignature":
		if e.complexity.MarketMk12Deal.ProposalSignature == nil {
			break
		}

		return e.complexity.MarketMk12Deal.ProposalSignature(childComplexity), true

	case "MarketMk12Deal.publishCid":
		if e.complexity.MarketMk12Deal.PublishCid == nil {
			break
		}

		return e.complexity.MarketMk12Deal.PublishCid(childComplexity), true

	case "MarketMk12Deal.signedProposalCid":
		if e.complexity.MarketMk12Deal.SignedProposalCid == nil {
			break
		}

		return e.complexity.MarketMk12Deal.SignedProposalCid(childComplexity), true

	case "MarketMk12Deal.spId":
		if e.complexity.MarketMk12Deal.SpID == nil {
			break
		}

		return e.complexity.MarketMk12Deal.SpID(childComplexity), true

	case "MarketMk12Deal.startEpoch":
		if e.complexity.MarketMk12Deal.StartEpoch == nil {
			break
		}

		return e.complexity.MarketMk12Deal.StartEpoch(childComplexity), true

	case "MarketMk12Deal.url":
		if e.complexity.MarketMk12Deal.URL == nil {
			break
		}

		return e.complexity.MarketMk12Deal.URL(childComplexity), true

	case "MarketMk12Deal.urlHeaders":
		if e.complexity.MarketMk12Deal.URLHeaders == nil {
			break
		}

		return e.complexity.MarketMk12Deal.URLHeaders(childComplexity), true

	case "MarketMk12Deal.uuid":
		if e.complexity.MarketMk12Deal.UUID == nil {
			break
		}

		return e.complexity.MarketMk12Deal.UUID(childComplexity), true

	case "MarketMk12Deal.verified":
		if e.complexity.MarketMk12Deal.Verified == nil {
			break
		}

		return e.complexity.MarketMk12Deal.Verified(childComplexity), true

	case "MarketMk12StorageAsk.createdAt":
		if e.complexity.MarketMk12StorageAsk.CreatedAt == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.CreatedAt(childComplexity), true

	case "MarketMk12StorageAsk.expiry":
		if e.complexity.MarketMk12StorageAsk.Expiry == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.Expiry(childComplexity), true

	case "MarketMk12StorageAsk.maxSize":
		if e.complexity.MarketMk12StorageAsk.MaxSize == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.MaxSize(childComplexity), true

	case "MarketMk12StorageAsk.minSize":
		if e.complexity.MarketMk12StorageAsk.MinSize == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.MinSize(childComplexity), true

	case "MarketMk12StorageAsk.price":
		if e.complexity.MarketMk12StorageAsk.Price == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.Price(childComplexity), true

	case "MarketMk12StorageAsk.sequence":
		if e.complexity.MarketMk12StorageAsk.Sequence == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.Sequence(childComplexity), true

	case "MarketMk12StorageAsk.spId":
		if e.complexity.MarketMk12StorageAsk.SpID == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.SpID(childComplexity), true

	case "MarketMk12StorageAsk.verifiedPrice":
		if e.complexity.MarketMk12StorageAsk.VerifiedPrice == nil {
			break
		}

		return e.complexity.MarketMk12StorageAsk.VerifiedPrice(childComplexity), true

	case "MessageSend.fromKey":
		if e.complexity.MessageSend.FromKey == nil {
			break
		}

		return e.complexity.MessageSend.FromKey(childComplexity), true

	case "MessageSend.nonce":
		if e.complexity.MessageSend.Nonce == nil {
			break
		}

		return e.complexity.MessageSend.Nonce(childComplexity), true

	case "MessageSend.sendError":
		if e.complexity.MessageSend.SendError == nil {
			break
		}

		return e.complexity.MessageSend.SendError(childComplexity), true

	case "MessageSend.sendReason":
		if e.complexity.MessageSend.SendReason == nil {
			break
		}

		return e.complexity.MessageSend.SendReason(childComplexity), true

	case "MessageSend.sendSuccess":
		if e.complexity.MessageSend.SendSuccess == nil {
			break
		}

		return e.complexity.MessageSend.SendSuccess(childComplexity), true

	case "MessageSend.sendTaskId":
		if e.complexity.MessageSend.SendTaskID == nil {
			break
		}

		return e.complexity.MessageSend.SendTaskID(childComplexity), true

	case "MessageSend.sendTime":
		if e.complexity.MessageSend.SendTime == nil {
			break
		}

		return e.complexity.MessageSend.SendTime(childComplexity), true

	case "MessageSend.signedCid":
		if e.complexity.MessageSend.SignedCid == nil {
			break
		}

		return e.complexity.MessageSend.SignedCid(childComplexity), true

	case "MessageSend.signedData":
		if e.complexity.MessageSend.SignedData == nil {
			break
		}

		return e.complexity.MessageSend.SignedData(childComplexity), true

	case "MessageSend.signedJson":
		if e.complexity.MessageSend.SignedJSON == nil {
			break
		}

		return e.complexity.MessageSend.SignedJSON(childComplexity), true

	case "MessageSend.toAddr":
		if e.complexity.MessageSend.ToAddr == nil {
			break
		}

		return e.complexity.MessageSend.ToAddr(childComplexity), true

	case "MessageSend.unsignedCid":
		if e.complexity.MessageSend.UnsignedCid == nil {
			break
		}

		return e.complexity.MessageSend.UnsignedCid(childComplexity), true

	case "MessageSend.unsignedData":
		if e.complexity.MessageSend.UnsignedData == nil {
			break
		}

		return e.complexity.MessageSend.UnsignedData(childComplexity), true

	case "MessageWait.createdAt":
		if e.complexity.MessageWait.CreatedAt == nil {
			break
		}

		return e.complexity.MessageWait.CreatedAt(childComplexity), true

	case "MessageWait.executedMsgCid":
		if e.complexity.MessageWait.ExecutedMsgCid == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedMsgCid(childComplexity), true

	case "MessageWait.executedMsgData":
		if e.complexity.MessageWait.ExecutedMsgData == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedMsgData(childComplexity), true

	case "MessageWait.executedRcptExitcode":
		if e.complexity.MessageWait.ExecutedRcptExitcode == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedRcptExitcode(childComplexity), true

	case "MessageWait.executedRcptGasUsed":
		if e.complexity.MessageWait.ExecutedRcptGasUsed == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedRcptGasUsed(childComplexity), true

	case "MessageWait.executedRcptReturn":
		if e.complexity.MessageWait.ExecutedRcptReturn == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedRcptReturn(childComplexity), true

	case "MessageWait.executedTskCid":
		if e.complexity.MessageWait.ExecutedTskCid == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedTskCid(childComplexity), true

	case "MessageWait.executedTskEpoch":
		if e.complexity.MessageWait.ExecutedTskEpoch == nil {
			break
		}

		return e.complexity.MessageWait.ExecutedTskEpoch(childComplexity), true

	case "MessageWait.signedMessageCid":
		if e.complexity.MessageWait.SignedMessageCid == nil {
			break
		}

		return e.complexity.MessageWait.SignedMessageCid(childComplexity), true

	case "MessageWait.waiterMachine":
		if e.complexity.MessageWait.WaiterMachine == nil {
			break
		}

		return e.complexity.MessageWait.WaiterMachine(childComplexity), true

	case "MessageWait.waiterMachineId":
		if e.complexity.MessageWait.WaiterMachineID == nil {
			break
		}

		return e.complexity.MessageWait.WaiterMachineID(childComplexity), true

	case "Metadata.genesisTimestamp":
		if e.complexity.Metadata.GenesisTimestamp == nil {
			break
		}

		return e.complexity.Metadata.GenesisTimestamp(childComplexity), true

	case "Metadata.networkName":
		if e.complexity.Metadata.NetworkName == nil {
			break
		}

		return e.complexity.Metadata.NetworkName(childComplexity), true

	case "Miner.balance":
		if e.complexity.Miner.Balance == nil {
			break
		}

		return e.complexity.Miner.Balance(childComplexity), true

	case "Miner.id":
		if e.complexity.Miner.ID == nil {
			break
		}

		return e.complexity.Miner.ID(childComplexity), true

	case "Miner.info":
		if e.complexity.Miner.Info == nil {
			break
		}

		return e.complexity.Miner.Info(childComplexity), true

	case "Miner.power":
		if e.complexity.Miner.Power == nil {
			break
		}

		return e.complexity.Miner.Power(childComplexity), true

	case "MinerBalance.available":
		if e.complexity.MinerBalance.Available == nil {
			break
		}

		return e.complexity.MinerBalance.Available(childComplexity), true

	case "MinerBalance.balance":
		if e.complexity.MinerBalance.Balance == nil {
			break
		}

		return e.complexity.MinerBalance.Balance(childComplexity), true

	case "MinerBalance.id":
		if e.complexity.MinerBalance.ID == nil {
			break
		}

		return e.complexity.MinerBalance.ID(childComplexity), true

	case "MinerBalance.initialPledge":
		if e.complexity.MinerBalance.InitialPledge == nil {
			break
		}

		return e.complexity.MinerBalance.InitialPledge(childComplexity), true

	case "MinerBalance.preCommitDeposits":
		if e.complexity.MinerBalance.PreCommitDeposits == nil {
			break
		}

		return e.complexity.MinerBalance.PreCommitDeposits(childComplexity), true

	case "MinerBalance.vesting":
		if e.complexity.MinerBalance.Vesting == nil {
			break
		}

		return e.complexity.MinerBalance.Vesting(childComplexity), true

	case "MinerBeneficiaryTerm.expiration":
		if e.complexity.MinerBeneficiaryTerm.Expiration == nil {
			break
		}

		return e.complexity.MinerBeneficiaryTerm.Expiration(childComplexity), true

	case "MinerBeneficiaryTerm.quota":
		if e.complexity.MinerBeneficiaryTerm.Quota == nil {
			break
		}

		return e.complexity.MinerBeneficiaryTerm.Quota(childComplexity), true

	case "MinerBeneficiaryTerm.usedQuota":
		if e.complexity.MinerBeneficiaryTerm.UsedQuota == nil {
			break
		}

		return e.complexity.MinerBeneficiaryTerm.UsedQuota(childComplexity), true

	case "MinerInfo.beneficiary":
		if e.complexity.MinerInfo.Beneficiary == nil {
			break
		}

		return e.complexity.MinerInfo.Beneficiary(childComplexity), true

	case "MinerInfo.beneficiaryTerm":
		if e.complexity.MinerInfo.BeneficiaryTerm == nil {
			break
		}

		return e.complexity.MinerInfo.BeneficiaryTerm(childComplexity), true

	case "MinerInfo.consensusFaultElapsed":
		if e.complexity.MinerInfo.ConsensusFaultElapsed == nil {
			break
		}

		return e.complexity.MinerInfo.ConsensusFaultElapsed(childComplexity), true

	case "MinerInfo.controlAddresses":
		if e.complexity.MinerInfo.ControlAddresses == nil {
			break
		}

		return e.complexity.MinerInfo.ControlAddresses(childComplexity), true

	case "MinerInfo.multiAddrs":
		if e.complexity.MinerInfo.MultiAddrs == nil {
			break
		}

		return e.complexity.MinerInfo.MultiAddrs(childComplexity), true

	case "MinerInfo.newWorker":
		if e.complexity.MinerInfo.NewWorker == nil {
			break
		}

		return e.complexity.MinerInfo.NewWorker(childComplexity), true

	case "MinerInfo.owner":
		if e.complexity.MinerInfo.Owner == nil {
			break
		}

		return e.complexity.MinerInfo.Owner(childComplexity), true

	case "MinerInfo.peerId":
		if e.complexity.MinerInfo.PeerID == nil {
			break
		}

		return e.complexity.MinerInfo.PeerID(childComplexity), true

	case "MinerInfo.pendingBeneficiaryChange":
		if e.complexity.MinerInfo.PendingBeneficiaryChange == nil {
			break
		}

		return e.complexity.MinerInfo.PendingBeneficiaryChange(childComplexity), true

	case "MinerInfo.pendingOwnerAddress":
		if e.complexity.MinerInfo.PendingOwnerAddress == nil {
			break
		}

		return e.complexity.MinerInfo.PendingOwnerAddress(childComplexity), true

	case "MinerInfo.sectorSize":
		if e.complexity.MinerInfo.SectorSize == nil {
			break
		}

		return e.complexity.MinerInfo.SectorSize(childComplexity), true

	case "MinerInfo.windowPoStPartitionSectors":
		if e.complexity.MinerInfo.WindowPoStPartitionSectors == nil {
			break
		}

		return e.complexity.MinerInfo.WindowPoStPartitionSectors(childComplexity), true

	case "MinerInfo.windowPoStProofType":
		if e.complexity.MinerInfo.WindowPoStProofType == nil {
			break
		}

		return e.complexity.MinerInfo.WindowPoStProofType(childComplexity), true

	case "MinerInfo.worker":
		if e.complexity.MinerInfo.Worker == nil {
			break
		}

		return e.complexity.MinerInfo.Worker(childComplexity), true

	case "MinerInfo.workerChangeEpoch":
		if e.complexity.MinerInfo.WorkerChangeEpoch == nil {
			break
		}

		return e.complexity.MinerInfo.WorkerChangeEpoch(childComplexity), true

	case "MinerPendingBeneficiaryChange.approvedByBeneficiary":
		if e.complexity.MinerPendingBeneficiaryChange.ApprovedByBeneficiary == nil {
			break
		}

		return e.complexity.MinerPendingBeneficiaryChange.ApprovedByBeneficiary(childComplexity), true

	case "MinerPendingBeneficiaryChange.approvedByNominee":
		if e.complexity.MinerPendingBeneficiaryChange.ApprovedByNominee == nil {
			break
		}

		return e.complexity.MinerPendingBeneficiaryChange.ApprovedByNominee(childComplexity), true

	case "MinerPendingBeneficiaryChange.newBeneficiary":
		if e.complexity.MinerPendingBeneficiaryChange.NewBeneficiary == nil {
			break
		}

		return e.complexity.MinerPendingBeneficiaryChange.NewBeneficiary(childComplexity), true

	case "MinerPendingBeneficiaryChange.newExpiration":
		if e.complexity.MinerPendingBeneficiaryChange.NewExpiration == nil {
			break
		}

		return e.complexity.MinerPendingBeneficiaryChange.NewExpiration(childComplexity), true

	case "MinerPendingBeneficiaryChange.newQuota":
		if e.complexity.MinerPendingBeneficiaryChange.NewQuota == nil {
			break
		}

		return e.complexity.MinerPendingBeneficiaryChange.NewQuota(childComplexity), true

	case "MinerPower.hasMinPower":
		if e.complexity.MinerPower.HasMinPower == nil {
			break
		}

		return e.complexity.MinerPower.HasMinPower(childComplexity), true

	case "MinerPower.id":
		if e.complexity.MinerPower.ID == nil {
			break
		}

		return e.complexity.MinerPower.ID(childComplexity), true

	case "MinerPower.minerPower":
		if e.complexity.MinerPower.MinerPower == nil {
			break
		}

		return e.complexity.MinerPower.MinerPower(childComplexity), true

	case "MinerPower.totalPower":
		if e.complexity.MinerPower.TotalPower == nil {
			break
		}

		return e.complexity.MinerPower.TotalPower(childComplexity), true

	case "MiningCount.exclude":
		if e.complexity.MiningCount.Exclude == nil {
			break
		}

		return e.complexity.MiningCount.Exclude(childComplexity), true

	case "MiningCount.include":
		if e.complexity.MiningCount.Include == nil {
			break
		}

		return e.complexity.MiningCount.Include(childComplexity), true

	case "MiningCountAggregated.included":
		if e.complexity.MiningCountAggregated.Included == nil {
			break
		}

		return e.complexity.MiningCountAggregated.Included(childComplexity), true

	case "MiningCountAggregated.time":
		if e.complexity.MiningCountAggregated.Time == nil {
			break
		}

		return e.complexity.MiningCountAggregated.Time(childComplexity), true

	case "MiningCountAggregated.total":
		if e.complexity.MiningCountAggregated.Total == nil {
			break
		}

		return e.complexity.MiningCountAggregated.Total(childComplexity), true

	case "MiningCountAggregated.won":
		if e.complexity.MiningCountAggregated.Won == nil {
			break
		}

		return e.complexity.MiningCountAggregated.Won(childComplexity), true

	case "MiningCountSummary.actor":
		if e.complexity.MiningCountSummary.Actor == nil {
			break
		}

		return e.complexity.MiningCountSummary.Actor(childComplexity), true

	case "MiningCountSummary.end":
		if e.complexity.MiningCountSummary.End == nil {
			break
		}

		return e.complexity.MiningCountSummary.End(childComplexity), true

	case "MiningCountSummary.included":
		if e.complexity.MiningCountSummary.Included == nil {
			break
		}

		return e.complexity.MiningCountSummary.Included(childComplexity), true

	case "MiningCountSummary.previous":
		if e.complexity.MiningCountSummary.Previous == nil {
			break
		}

		return e.complexity.MiningCountSummary.Previous(childComplexity), true

	case "MiningCountSummary.start":
		if e.complexity.MiningCountSummary.Start == nil {
			break
		}

		return e.complexity.MiningCountSummary.Start(childComplexity), true

	case "MiningCountSummary.total":
		if e.complexity.MiningCountSummary.Total == nil {
			break
		}

		return e.complexity.MiningCountSummary.Total(childComplexity), true

	case "MiningCountSummary.won":
		if e.complexity.MiningCountSummary.Won == nil {
			break
		}

		return e.complexity.MiningCountSummary.Won(childComplexity), true

	case "MiningStatusSummay.included":
		if e.complexity.MiningStatusSummay.Included == nil {
			break
		}

		return e.complexity.MiningStatusSummay.Included(childComplexity), true

	case "MiningStatusSummay.lastMinedAt":
		if e.complexity.MiningStatusSummay.LastMinedAt == nil {
			break
		}

		return e.complexity.MiningStatusSummay.LastMinedAt(childComplexity), true

	case "MiningStatusSummay.total":
		if e.complexity.MiningStatusSummay.Total == nil {
			break
		}

		return e.complexity.MiningStatusSummay.Total(childComplexity), true

	case "MiningStatusSummay.won":
		if e.complexity.MiningStatusSummay.Won == nil {
			break
		}

		return e.complexity.MiningStatusSummay.Won(childComplexity), true

	case "MiningStatusSummay.wonChangeRate":
		if e.complexity.MiningStatusSummay.WonChangeRate == nil {
			break
		}

		return e.complexity.MiningStatusSummay.WonChangeRate(childComplexity), true

	case "MiningSummaryDay.day":
		if e.complexity.MiningSummaryDay.Day == nil {
			break
		}

		return e.complexity.MiningSummaryDay.Day(childComplexity), true

	case "MiningSummaryDay.miner":
		if e.complexity.MiningSummaryDay.Miner == nil {
			break
		}

		return e.complexity.MiningSummaryDay.Miner(childComplexity), true

	case "MiningSummaryDay.wonBlock":
		if e.complexity.MiningSummaryDay.WonBlock == nil {
			break
		}

		return e.complexity.MiningSummaryDay.WonBlock(childComplexity), true

	case "MiningTask.baseComputeTime":
		if e.complexity.MiningTask.BaseComputeTime == nil {
			break
		}

		return e.complexity.MiningTask.BaseComputeTime(childComplexity), true

	case "MiningTask.epoch":
		if e.complexity.MiningTask.Epoch == nil {
			break
		}

		return e.complexity.MiningTask.Epoch(childComplexity), true

	case "MiningTask.included":
		if e.complexity.MiningTask.Included == nil {
			break
		}

		return e.complexity.MiningTask.Included(childComplexity), true

	case "MiningTask.minedAt":
		if e.complexity.MiningTask.MinedAt == nil {
			break
		}

		return e.complexity.MiningTask.MinedAt(childComplexity), true

	case "MiningTask.minedCid":
		if e.complexity.MiningTask.MinedCid == nil {
			break
		}

		return e.complexity.MiningTask.MinedCid(childComplexity), true

	case "MiningTask.minedHeader":
		if e.complexity.MiningTask.MinedHeader == nil {
			break
		}

		return e.complexity.MiningTask.MinedHeader(childComplexity), true

	case "MiningTask.spId":
		if e.complexity.MiningTask.SpID == nil {
			break
		}

		return e.complexity.MiningTask.SpID(childComplexity), true

	case "MiningTask.submittedAt":
		if e.complexity.MiningTask.SubmittedAt == nil {
			break
		}

		return e.complexity.MiningTask.SubmittedAt(childComplexity), true

	case "MiningTask.taskId":
		if e.complexity.MiningTask.TaskID == nil {
			break
		}

		return e.complexity.MiningTask.TaskID(childComplexity), true

	case "MiningTask.won":
		if e.complexity.MiningTask.Won == nil {
			break
		}

		return e.complexity.MiningTask.Won(childComplexity), true

	case "Mutation.createConfig":
		if e.complexity.Mutation.CreateConfig == nil {
			break
		}

		args, err := ec.field_Mutation_createConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateConfig(childComplexity, args["title"].(string), args["config"].(string)), true

	case "Mutation.dealSealNow":
		if e.complexity.Mutation.DealSealNow == nil {
			break
		}

		args, err := ec.field_Mutation_dealSealNow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DealSealNow(childComplexity, args["miner"].(types.Address), args["sectorNumber"].(uint64)), true

	case "Mutation.marketAddBalance":
		if e.complexity.Mutation.MarketAddBalance == nil {
			break
		}

		args, err := ec.field_Mutation_marketAddBalance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketAddBalance(childComplexity, args["miner"].(types.Address), args["wallet"].(types.Address), args["amount"].(types.FIL)), true

	case "Mutation.marketAddClientFilter":
		if e.complexity.Mutation.MarketAddClientFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketAddClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketAddClientFilter(childComplexity, args["input"].(model.ClientFilterInput)), true

	case "Mutation.marketAddPriceFilter":
		if e.complexity.Mutation.MarketAddPriceFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketAddPriceFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketAddPriceFilter(childComplexity, args["input"].(model.PriceFilterInput)), true

	case "Mutation.marketDeleteAllowFilter":
		if e.complexity.Mutation.MarketDeleteAllowFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketDeleteAllowFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketDeleteAllowFilter(childComplexity, args["wallet"].(types.Address)), true

	case "Mutation.marketDeleteClientFilter":
		if e.complexity.Mutation.MarketDeleteClientFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketDeleteClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketDeleteClientFilter(childComplexity, args["name"].(string)), true

	case "Mutation.marketDeletePriceFilter":
		if e.complexity.Mutation.MarketDeletePriceFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketDeletePriceFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketDeletePriceFilter(childComplexity, args["name"].(string)), true

	case "Mutation.marketSetAllowFilter":
		if e.complexity.Mutation.MarketSetAllowFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketSetAllowFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketSetAllowFilter(childComplexity, args["wallet"].(types.Address), args["status"].(bool)), true

	case "Mutation.marketToggleAllowFilter":
		if e.complexity.Mutation.MarketToggleAllowFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketToggleAllowFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketToggleAllowFilter(childComplexity, args["wallet"].(types.Address)), true

	case "Mutation.marketToggleClientFilter":
		if e.complexity.Mutation.MarketToggleClientFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketToggleClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketToggleClientFilter(childComplexity, args["name"].(string)), true

	case "Mutation.marketUpdateClientFilter":
		if e.complexity.Mutation.MarketUpdateClientFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketUpdateClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketUpdateClientFilter(childComplexity, args["input"].(model.ClientFilterInput)), true

	case "Mutation.marketUpdatePriceFilter":
		if e.complexity.Mutation.MarketUpdatePriceFilter == nil {
			break
		}

		args, err := ec.field_Mutation_marketUpdatePriceFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarketUpdatePriceFilter(childComplexity, args["input"].(model.PriceFilterInput)), true

	case "Mutation.removeConfig":
		if e.complexity.Mutation.RemoveConfig == nil {
			break
		}

		args, err := ec.field_Mutation_removeConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveConfig(childComplexity, args["title"].(string)), true

	case "Mutation.removeSector":
		if e.complexity.Mutation.RemoveSector == nil {
			break
		}

		args, err := ec.field_Mutation_removeSector_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveSector(childComplexity, args["miner"].(types.Address), args["sectorNumber"].(int)), true

	case "Mutation.restartAllFailedSectors":
		if e.complexity.Mutation.RestartAllFailedSectors == nil {
			break
		}

		return e.complexity.Mutation.RestartAllFailedSectors(childComplexity), true

	case "Mutation.restartSector":
		if e.complexity.Mutation.RestartSector == nil {
			break
		}

		args, err := ec.field_Mutation_restartSector_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartSector(childComplexity, args["miner"].(types.Address), args["sectorNumber"].(int)), true

	case "Mutation.updateConfig":
		if e.complexity.Mutation.UpdateConfig == nil {
			break
		}

		args, err := ec.field_Mutation_updateConfig_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateConfig(childComplexity, args["title"].(string), args["config"].(string)), true

	case "Mutation.updateMarketMk12StorageAsk":
		if e.complexity.Mutation.UpdateMarketMk12StorageAsk == nil {
			break
		}

		args, err := ec.field_Mutation_updateMarketMk12StorageAsk_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMarketMk12StorageAsk(childComplexity, args["input"].(model.MarketMk12StorageAskInput)), true

	case "NodeHealthSummary.offlineNodes":
		if e.complexity.NodeHealthSummary.OfflineNodes == nil {
			break
		}

		return e.complexity.NodeHealthSummary.OfflineNodes(childComplexity), true

	case "NodeHealthSummary.onlineNodes":
		if e.complexity.NodeHealthSummary.OnlineNodes == nil {
			break
		}

		return e.complexity.NodeHealthSummary.OnlineNodes(childComplexity), true

	case "NodeHealthSummary.unscheduledNodes":
		if e.complexity.NodeHealthSummary.UnscheduledNodes == nil {
			break
		}

		return e.complexity.NodeHealthSummary.UnscheduledNodes(childComplexity), true

	case "NodeInfo.address":
		if e.complexity.NodeInfo.Address == nil {
			break
		}

		return e.complexity.NodeInfo.Address(childComplexity), true

	case "NodeInfo.id":
		if e.complexity.NodeInfo.ID == nil {
			break
		}

		return e.complexity.NodeInfo.ID(childComplexity), true

	case "NodeInfo.layers":
		if e.complexity.NodeInfo.Layers == nil {
			break
		}

		return e.complexity.NodeInfo.Layers(childComplexity), true

	case "NodeInfo.reachable":
		if e.complexity.NodeInfo.Reachable == nil {
			break
		}

		return e.complexity.NodeInfo.Reachable(childComplexity), true

	case "NodeInfo.syncState":
		if e.complexity.NodeInfo.SyncState == nil {
			break
		}

		return e.complexity.NodeInfo.SyncState(childComplexity), true

	case "NodeInfo.version":
		if e.complexity.NodeInfo.Version == nil {
			break
		}

		return e.complexity.NodeInfo.Version(childComplexity), true

	case "OpenSectorPiece.createdAt":
		if e.complexity.OpenSectorPiece.CreatedAt == nil {
			break
		}

		return e.complexity.OpenSectorPiece.CreatedAt(childComplexity), true

	case "OpenSectorPiece.dataDeleteOnFinalize":
		if e.complexity.OpenSectorPiece.DataDeleteOnFinalize == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DataDeleteOnFinalize(childComplexity), true

	case "OpenSectorPiece.dataHeaders":
		if e.complexity.OpenSectorPiece.DataHeaders == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DataHeaders(childComplexity), true

	case "OpenSectorPiece.dataRawSize":
		if e.complexity.OpenSectorPiece.DataRawSize == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DataRawSize(childComplexity), true

	case "OpenSectorPiece.dataURL":
		if e.complexity.OpenSectorPiece.DataURL == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DataURL(childComplexity), true

	case "OpenSectorPiece.directEndEpoch":
		if e.complexity.OpenSectorPiece.DirectEndEpoch == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DirectEndEpoch(childComplexity), true

	case "OpenSectorPiece.directPieceActivationManifest":
		if e.complexity.OpenSectorPiece.DirectPieceActivationManifest == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DirectPieceActivationManifest(childComplexity), true

	case "OpenSectorPiece.directStartEpoch":
		if e.complexity.OpenSectorPiece.DirectStartEpoch == nil {
			break
		}

		return e.complexity.OpenSectorPiece.DirectStartEpoch(childComplexity), true

	case "OpenSectorPiece.f05DealEndEpoch":
		if e.complexity.OpenSectorPiece.F05DealEndEpoch == nil {
			break
		}

		return e.complexity.OpenSectorPiece.F05DealEndEpoch(childComplexity), true

	case "OpenSectorPiece.f05DealID":
		if e.complexity.OpenSectorPiece.F05DealID == nil {
			break
		}

		return e.complexity.OpenSectorPiece.F05DealID(childComplexity), true

	case "OpenSectorPiece.f05DealProposal":
		if e.complexity.OpenSectorPiece.F05DealProposal == nil {
			break
		}

		return e.complexity.OpenSectorPiece.F05DealProposal(childComplexity), true

	case "OpenSectorPiece.f05DealStartEpoch":
		if e.complexity.OpenSectorPiece.F05DealStartEpoch == nil {
			break
		}

		return e.complexity.OpenSectorPiece.F05DealStartEpoch(childComplexity), true

	case "OpenSectorPiece.f05PublishCID":
		if e.complexity.OpenSectorPiece.F05PublishCid == nil {
			break
		}

		return e.complexity.OpenSectorPiece.F05PublishCid(childComplexity), true

	case "OpenSectorPiece.isSnap":
		if e.complexity.OpenSectorPiece.IsSnap == nil {
			break
		}

		return e.complexity.OpenSectorPiece.IsSnap(childComplexity), true

	case "OpenSectorPiece.pieceCID":
		if e.complexity.OpenSectorPiece.PieceCid == nil {
			break
		}

		return e.complexity.OpenSectorPiece.PieceCid(childComplexity), true

	case "OpenSectorPiece.pieceIndex":
		if e.complexity.OpenSectorPiece.PieceIndex == nil {
			break
		}

		return e.complexity.OpenSectorPiece.PieceIndex(childComplexity), true

	case "OpenSectorPiece.pieceSize":
		if e.complexity.OpenSectorPiece.PieceSize == nil {
			break
		}

		return e.complexity.OpenSectorPiece.PieceSize(childComplexity), true

	case "OpenSectorPiece.sectorNumber":
		if e.complexity.OpenSectorPiece.SectorNumber == nil {
			break
		}

		return e.complexity.OpenSectorPiece.SectorNumber(childComplexity), true

	case "OpenSectorPiece.spID":
		if e.complexity.OpenSectorPiece.SpID == nil {
			break
		}

		return e.complexity.OpenSectorPiece.SpID(childComplexity), true

	case "PipelineSummary.commitMsg":
		if e.complexity.PipelineSummary.CommitMsg == nil {
			break
		}

		return e.complexity.PipelineSummary.CommitMsg(childComplexity), true

	case "PipelineSummary.done":
		if e.complexity.PipelineSummary.Done == nil {
			break
		}

		return e.complexity.PipelineSummary.Done(childComplexity), true

	case "PipelineSummary.failed":
		if e.complexity.PipelineSummary.Failed == nil {
			break
		}

		return e.complexity.PipelineSummary.Failed(childComplexity), true

	case "PipelineSummary.id":
		if e.complexity.PipelineSummary.ID == nil {
			break
		}

		return e.complexity.PipelineSummary.ID(childComplexity), true

	case "PipelineSummary.porep":
		if e.complexity.PipelineSummary.Porep == nil {
			break
		}

		return e.complexity.PipelineSummary.Porep(childComplexity), true

	case "PipelineSummary.precommitMsg":
		if e.complexity.PipelineSummary.PrecommitMsg == nil {
			break
		}

		return e.complexity.PipelineSummary.PrecommitMsg(childComplexity), true

	case "PipelineSummary.sdr":
		if e.complexity.PipelineSummary.Sdr == nil {
			break
		}

		return e.complexity.PipelineSummary.Sdr(childComplexity), true

	case "PipelineSummary.trees":
		if e.complexity.PipelineSummary.Trees == nil {
			break
		}

		return e.complexity.PipelineSummary.Trees(childComplexity), true

	case "PipelineSummary.waitSeed":
		if e.complexity.PipelineSummary.WaitSeed == nil {
			break
		}

		return e.complexity.PipelineSummary.WaitSeed(childComplexity), true

	case "Porep.afterCommitMsg":
		if e.complexity.Porep.AfterCommitMsg == nil {
			break
		}

		return e.complexity.Porep.AfterCommitMsg(childComplexity), true

	case "Porep.afterCommitMsgSuccess":
		if e.complexity.Porep.AfterCommitMsgSuccess == nil {
			break
		}

		return e.complexity.Porep.AfterCommitMsgSuccess(childComplexity), true

	case "Porep.afterFinalize":
		if e.complexity.Porep.AfterFinalize == nil {
			break
		}

		return e.complexity.Porep.AfterFinalize(childComplexity), true

	case "Porep.afterMoveStorage":
		if e.complexity.Porep.AfterMoveStorage == nil {
			break
		}

		return e.complexity.Porep.AfterMoveStorage(childComplexity), true

	case "Porep.afterPorep":
		if e.complexity.Porep.AfterPorep == nil {
			break
		}

		return e.complexity.Porep.AfterPorep(childComplexity), true

	case "Porep.afterPrecommitMsg":
		if e.complexity.Porep.AfterPrecommitMsg == nil {
			break
		}

		return e.complexity.Porep.AfterPrecommitMsg(childComplexity), true

	case "Porep.afterPrecommitMsgSuccess":
		if e.complexity.Porep.AfterPrecommitMsgSuccess == nil {
			break
		}

		return e.complexity.Porep.AfterPrecommitMsgSuccess(childComplexity), true

	case "Porep.afterSdr":
		if e.complexity.Porep.AfterSdr == nil {
			break
		}

		return e.complexity.Porep.AfterSdr(childComplexity), true

	case "Porep.afterSynth":
		if e.complexity.Porep.AfterSynth == nil {
			break
		}

		return e.complexity.Porep.AfterSynth(childComplexity), true

	case "Porep.afterTreeC":
		if e.complexity.Porep.AfterTreeC == nil {
			break
		}

		return e.complexity.Porep.AfterTreeC(childComplexity), true

	case "Porep.afterTreeD":
		if e.complexity.Porep.AfterTreeD == nil {
			break
		}

		return e.complexity.Porep.AfterTreeD(childComplexity), true

	case "Porep.afterTreeR":
		if e.complexity.Porep.AfterTreeR == nil {
			break
		}

		return e.complexity.Porep.AfterTreeR(childComplexity), true

	case "Porep.commitMsgCid":
		if e.complexity.Porep.CommitMsgCid == nil {
			break
		}

		return e.complexity.Porep.CommitMsgCid(childComplexity), true

	case "Porep.commitMsgTsk":
		if e.complexity.Porep.CommitMsgTsk == nil {
			break
		}

		return e.complexity.Porep.CommitMsgTsk(childComplexity), true

	case "Porep.commitReadyAt":
		if e.complexity.Porep.CommitReadyAt == nil {
			break
		}

		return e.complexity.Porep.CommitReadyAt(childComplexity), true

	case "Porep.compactStages":
		if e.complexity.Porep.CompactStages == nil {
			break
		}

		return e.complexity.Porep.CompactStages(childComplexity), true

	case "Porep.createTime":
		if e.complexity.Porep.CreateTime == nil {
			break
		}

		return e.complexity.Porep.CreateTime(childComplexity), true

	case "Porep.currentTask":
		if e.complexity.Porep.CurrentTask == nil {
			break
		}

		return e.complexity.Porep.CurrentTask(childComplexity), true

	case "Porep.failed":
		if e.complexity.Porep.Failed == nil {
			break
		}

		return e.complexity.Porep.Failed(childComplexity), true

	case "Porep.failedAt":
		if e.complexity.Porep.FailedAt == nil {
			break
		}

		return e.complexity.Porep.FailedAt(childComplexity), true

	case "Porep.failedReason":
		if e.complexity.Porep.FailedReason == nil {
			break
		}

		return e.complexity.Porep.FailedReason(childComplexity), true

	case "Porep.failedReasonMsg":
		if e.complexity.Porep.FailedReasonMsg == nil {
			break
		}

		return e.complexity.Porep.FailedReasonMsg(childComplexity), true

	case "Porep.id":
		if e.complexity.Porep.ID == nil {
			break
		}

		return e.complexity.Porep.ID(childComplexity), true

	case "Porep.porepProof":
		if e.complexity.Porep.PorepProof == nil {
			break
		}

		return e.complexity.Porep.PorepProof(childComplexity), true

	case "Porep.precommitMsgCid":
		if e.complexity.Porep.PrecommitMsgCid == nil {
			break
		}

		return e.complexity.Porep.PrecommitMsgCid(childComplexity), true

	case "Porep.precommitMsgTsk":
		if e.complexity.Porep.PrecommitMsgTsk == nil {
			break
		}

		return e.complexity.Porep.PrecommitMsgTsk(childComplexity), true

	case "Porep.precommitReadyAt":
		if e.complexity.Porep.PrecommitReadyAt == nil {
			break
		}

		return e.complexity.Porep.PrecommitReadyAt(childComplexity), true

	case "Porep.regSealProof":
		if e.complexity.Porep.RegSealProof == nil {
			break
		}

		return e.complexity.Porep.RegSealProof(childComplexity), true

	case "Porep.sectorNumber":
		if e.complexity.Porep.SectorNumber == nil {
			break
		}

		return e.complexity.Porep.SectorNumber(childComplexity), true

	case "Porep.seedEpoch":
		if e.complexity.Porep.SeedEpoch == nil {
			break
		}

		return e.complexity.Porep.SeedEpoch(childComplexity), true

	case "Porep.seedValue":
		if e.complexity.Porep.SeedValue == nil {
			break
		}

		return e.complexity.Porep.SeedValue(childComplexity), true

	case "Porep.spId":
		if e.complexity.Porep.SpID == nil {
			break
		}

		return e.complexity.Porep.SpID(childComplexity), true

	case "Porep.stage":
		if e.complexity.Porep.Stage == nil {
			break
		}

		return e.complexity.Porep.Stage(childComplexity), true

	case "Porep.status":
		if e.complexity.Porep.Status == nil {
			break
		}

		return e.complexity.Porep.Status(childComplexity), true

	case "Porep.taskIdCommitMsg":
		if e.complexity.Porep.TaskIDCommitMsg == nil {
			break
		}

		return e.complexity.Porep.TaskIDCommitMsg(childComplexity), true

	case "Porep.taskIdFinalize":
		if e.complexity.Porep.TaskIDFinalize == nil {
			break
		}

		return e.complexity.Porep.TaskIDFinalize(childComplexity), true

	case "Porep.taskIdMoveStorage":
		if e.complexity.Porep.TaskIDMoveStorage == nil {
			break
		}

		return e.complexity.Porep.TaskIDMoveStorage(childComplexity), true

	case "Porep.taskIdPorep":
		if e.complexity.Porep.TaskIDPorep == nil {
			break
		}

		return e.complexity.Porep.TaskIDPorep(childComplexity), true

	case "Porep.taskIdPrecommitMsg":
		if e.complexity.Porep.TaskIDPrecommitMsg == nil {
			break
		}

		return e.complexity.Porep.TaskIDPrecommitMsg(childComplexity), true

	case "Porep.taskIdSdr":
		if e.complexity.Porep.TaskIDSdr == nil {
			break
		}

		return e.complexity.Porep.TaskIDSdr(childComplexity), true

	case "Porep.taskIdSynth":
		if e.complexity.Porep.TaskIDSynth == nil {
			break
		}

		return e.complexity.Porep.TaskIDSynth(childComplexity), true

	case "Porep.taskIdTreeC":
		if e.complexity.Porep.TaskIDTreeC == nil {
			break
		}

		return e.complexity.Porep.TaskIDTreeC(childComplexity), true

	case "Porep.taskIdTreeD":
		if e.complexity.Porep.TaskIDTreeD == nil {
			break
		}

		return e.complexity.Porep.TaskIDTreeD(childComplexity), true

	case "Porep.taskIdTreeR":
		if e.complexity.Porep.TaskIDTreeR == nil {
			break
		}

		return e.complexity.Porep.TaskIDTreeR(childComplexity), true

	case "Porep.ticketEpoch":
		if e.complexity.Porep.TicketEpoch == nil {
			break
		}

		return e.complexity.Porep.TicketEpoch(childComplexity), true

	case "Porep.ticketValue":
		if e.complexity.Porep.TicketValue == nil {
			break
		}

		return e.complexity.Porep.TicketValue(childComplexity), true

	case "Porep.treeDCid":
		if e.complexity.Porep.TreeDCid == nil {
			break
		}

		return e.complexity.Porep.TreeDCid(childComplexity), true

	case "Porep.treeRCid":
		if e.complexity.Porep.TreeRCid == nil {
			break
		}

		return e.complexity.Porep.TreeRCid(childComplexity), true

	case "Porep.userSectorDurationEpochs":
		if e.complexity.Porep.UserSectorDurationEpochs == nil {
			break
		}

		return e.complexity.Porep.UserSectorDurationEpochs(childComplexity), true

	case "PowerClaim.qualityAdjPower":
		if e.complexity.PowerClaim.QualityAdjPower == nil {
			break
		}

		return e.complexity.PowerClaim.QualityAdjPower(childComplexity), true

	case "PowerClaim.rawBytePower":
		if e.complexity.PowerClaim.RawBytePower == nil {
			break
		}

		return e.complexity.PowerClaim.RawBytePower(childComplexity), true

	case "PriceFilter.maxDurationDays":
		if e.complexity.PriceFilter.MaxDurationDays == nil {
			break
		}

		return e.complexity.PriceFilter.MaxDurationDays(childComplexity), true

	case "PriceFilter.maximumSize":
		if e.complexity.PriceFilter.MaximumSize == nil {
			break
		}

		return e.complexity.PriceFilter.MaximumSize(childComplexity), true

	case "PriceFilter.minDurationDays":
		if e.complexity.PriceFilter.MinDurationDays == nil {
			break
		}

		return e.complexity.PriceFilter.MinDurationDays(childComplexity), true

	case "PriceFilter.minimumSize":
		if e.complexity.PriceFilter.MinimumSize == nil {
			break
		}

		return e.complexity.PriceFilter.MinimumSize(childComplexity), true

	case "PriceFilter.name":
		if e.complexity.PriceFilter.Name == nil {
			break
		}

		return e.complexity.PriceFilter.Name(childComplexity), true

	case "PriceFilter.price":
		if e.complexity.PriceFilter.Price == nil {
			break
		}

		return e.complexity.PriceFilter.Price(childComplexity), true

	case "PriceFilter.verified":
		if e.complexity.PriceFilter.Verified == nil {
			break
		}

		return e.complexity.PriceFilter.Verified(childComplexity), true

	case "PrometheusResponse.data":
		if e.complexity.PrometheusResponse.Data == nil {
			break
		}

		return e.complexity.PrometheusResponse.Data(childComplexity), true

	case "Query.actor":
		if e.complexity.Query.Actor == nil {
			break
		}

		args, err := ec.field_Query_actor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Actor(childComplexity, args["address"].(types.Address)), true

	case "Query.actors":
		if e.complexity.Query.Actors == nil {
			break
		}

		return e.complexity.Query.Actors(childComplexity), true

	case "Query.alerts":
		if e.complexity.Query.Alerts == nil {
			break
		}

		return e.complexity.Query.Alerts(childComplexity), true

	case "Query.config":
		if e.complexity.Query.Config == nil {
			break
		}

		args, err := ec.field_Query_config_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Config(childComplexity, args["layer"].(string)), true

	case "Query.configs":
		if e.complexity.Query.Configs == nil {
			break
		}

		return e.complexity.Query.Configs(childComplexity), true

	case "Query.dealsPending":
		if e.complexity.Query.DealsPending == nil {
			break
		}

		return e.complexity.Query.DealsPending(childComplexity), true

	case "Query.ipniAdvertisement":
		if e.complexity.Query.IpniAdvertisement == nil {
			break
		}

		args, err := ec.field_Query_ipniAdvertisement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniAdvertisement(childComplexity, args["orderNumber"].(int)), true

	case "Query.ipniAdvertisements":
		if e.complexity.Query.IpniAdvertisements == nil {
			break
		}

		args, err := ec.field_Query_ipniAdvertisements_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniAdvertisements(childComplexity, args["offset"].(int), args["limit"].(int), args["provider"].(*string), args["isSkip"].(*bool), args["isRemoved"].(*bool)), true

	case "Query.ipniAdvertisementsCount":
		if e.complexity.Query.IpniAdvertisementsCount == nil {
			break
		}

		args, err := ec.field_Query_ipniAdvertisementsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniAdvertisementsCount(childComplexity, args["provider"].(*string), args["isSkip"].(*bool), args["isRemoved"].(*bool)), true

	case "Query.ipniProviders":
		if e.complexity.Query.IpniProviders == nil {
			break
		}

		return e.complexity.Query.IpniProviders(childComplexity), true

	case "Query.ipniStats":
		if e.complexity.Query.IpniStats == nil {
			break
		}

		return e.complexity.Query.IpniStats(childComplexity), true

	case "Query.ipniTask":
		if e.complexity.Query.IpniTask == nil {
			break
		}

		args, err := ec.field_Query_ipniTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniTask(childComplexity, args["taskId"].(int)), true

	case "Query.ipniTasks":
		if e.complexity.Query.IpniTasks == nil {
			break
		}

		args, err := ec.field_Query_ipniTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniTasks(childComplexity, args["limit"].(*int), args["spId"].(*types.ActorID), args["isRm"].(*bool)), true

	case "Query.ipniTasksCount":
		if e.complexity.Query.IpniTasksCount == nil {
			break
		}

		args, err := ec.field_Query_ipniTasksCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IpniTasksCount(childComplexity, args["spId"].(*types.ActorID), args["isRm"].(*bool)), true

	case "Query.machine":
		if e.complexity.Query.Machine == nil {
			break
		}

		args, err := ec.field_Query_machine_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Machine(childComplexity, args["id"].(int)), true

	case "Query.machineByHostAndPort":
		if e.complexity.Query.MachineByHostAndPort == nil {
			break
		}

		args, err := ec.field_Query_machineByHostAndPort_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MachineByHostAndPort(childComplexity, args["hostAndPort"].(string)), true

	case "Query.machineSummary":
		if e.complexity.Query.MachineSummary == nil {
			break
		}

		return e.complexity.Query.MachineSummary(childComplexity), true

	case "Query.machines":
		if e.complexity.Query.Machines == nil {
			break
		}

		return e.complexity.Query.Machines(childComplexity), true

	case "Query.makretPriceFilters":
		if e.complexity.Query.MakretPriceFilters == nil {
			break
		}

		return e.complexity.Query.MakretPriceFilters(childComplexity), true

	case "Query.marketAllowFilter":
		if e.complexity.Query.MarketAllowFilter == nil {
			break
		}

		args, err := ec.field_Query_marketAllowFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketAllowFilter(childComplexity, args["wallet"].(types.Address)), true

	case "Query.marketAllowFilters":
		if e.complexity.Query.MarketAllowFilters == nil {
			break
		}

		return e.complexity.Query.MarketAllowFilters(childComplexity), true

	case "Query.marketBalance":
		if e.complexity.Query.MarketBalance == nil {
			break
		}

		args, err := ec.field_Query_marketBalance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketBalance(childComplexity, args["miner"].(types.Address)), true

	case "Query.marketBalances":
		if e.complexity.Query.MarketBalances == nil {
			break
		}

		return e.complexity.Query.MarketBalances(childComplexity), true

	case "Query.marketCheckClientFilter":
		if e.complexity.Query.MarketCheckClientFilter == nil {
			break
		}

		args, err := ec.field_Query_marketCheckClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketCheckClientFilter(childComplexity, args["name"].(string)), true

	case "Query.marketCheckPriceFilter":
		if e.complexity.Query.MarketCheckPriceFilter == nil {
			break
		}

		args, err := ec.field_Query_marketCheckPriceFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketCheckPriceFilter(childComplexity, args["name"].(string)), true

	case "Query.marketClientFilter":
		if e.complexity.Query.MarketClientFilter == nil {
			break
		}

		args, err := ec.field_Query_marketClientFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketClientFilter(childComplexity, args["name"].(string)), true

	case "Query.marketClientFilters":
		if e.complexity.Query.MarketClientFilters == nil {
			break
		}

		return e.complexity.Query.MarketClientFilters(childComplexity), true

	case "Query.marketDealCountSummary":
		if e.complexity.Query.MarketDealCountSummary == nil {
			break
		}

		return e.complexity.Query.MarketDealCountSummary(childComplexity), true

	case "Query.marketDealInfo":
		if e.complexity.Query.MarketDealInfo == nil {
			break
		}

		args, err := ec.field_Query_marketDealInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketDealInfo(childComplexity, args["id"].(string)), true

	case "Query.marketDefaultFilterBehaviour":
		if e.complexity.Query.MarketDefaultFilterBehaviour == nil {
			break
		}

		return e.complexity.Query.MarketDefaultFilterBehaviour(childComplexity), true

	case "Query.marketMk12Deals":
		if e.complexity.Query.MarketMk12Deals == nil {
			break
		}

		args, err := ec.field_Query_marketMk12Deals_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketMk12Deals(childComplexity, args["filter"].(model.MarketMk12DealFilterInput), args["limit"].(int), args["offset"].(int)), true

	case "Query.marketMk12DealsCount":
		if e.complexity.Query.MarketMk12DealsCount == nil {
			break
		}

		args, err := ec.field_Query_marketMk12DealsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketMk12DealsCount(childComplexity, args["filter"].(model.MarketMk12DealFilterInput)), true

	case "Query.marketMk12StorageAsk":
		if e.complexity.Query.MarketMk12StorageAsk == nil {
			break
		}

		args, err := ec.field_Query_marketMk12StorageAsk_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketMk12StorageAsk(childComplexity, args["spId"].(types.Address)), true

	case "Query.marketMk12StorageAsks":
		if e.complexity.Query.MarketMk12StorageAsks == nil {
			break
		}

		return e.complexity.Query.MarketMk12StorageAsks(childComplexity), true

	case "Query.marketMk12StorageAsksCount":
		if e.complexity.Query.MarketMk12StorageAsksCount == nil {
			break
		}

		return e.complexity.Query.MarketMk12StorageAsksCount(childComplexity), true

	case "Query.marketPriceFilter":
		if e.complexity.Query.MarketPriceFilter == nil {
			break
		}

		args, err := ec.field_Query_marketPriceFilter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketPriceFilter(childComplexity, args["name"].(string)), true

	case "Query.messageSend":
		if e.complexity.Query.MessageSend == nil {
			break
		}

		args, err := ec.field_Query_messageSend_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageSend(childComplexity, args["sendTaskId"].(*int), args["fromKey"].(*string), args["nonce"].(*int), args["signedCID"].(*string)), true

	case "Query.messageSends":
		if e.complexity.Query.MessageSends == nil {
			break
		}

		args, err := ec.field_Query_messageSends_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageSends(childComplexity, args["account"].(*types.Address), args["offset"].(int), args["limit"].(int)), true

	case "Query.messageSendsCount":
		if e.complexity.Query.MessageSendsCount == nil {
			break
		}

		args, err := ec.field_Query_messageSendsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageSendsCount(childComplexity, args["account"].(*types.Address)), true

	case "Query.messageWait":
		if e.complexity.Query.MessageWait == nil {
			break
		}

		args, err := ec.field_Query_messageWait_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageWait(childComplexity, args["signedMessageCid"].(string)), true

	case "Query.messageWaits":
		if e.complexity.Query.MessageWaits == nil {
			break
		}

		args, err := ec.field_Query_messageWaits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageWaits(childComplexity, args["waiterMachineId"].(*int), args["offset"].(int), args["limit"].(int)), true

	case "Query.messageWaitsCount":
		if e.complexity.Query.MessageWaitsCount == nil {
			break
		}

		args, err := ec.field_Query_messageWaitsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MessageWaitsCount(childComplexity, args["waiterMachineId"].(*int)), true

	case "Query.metadata":
		if e.complexity.Query.Metadata == nil {
			break
		}

		return e.complexity.Query.Metadata(childComplexity), true

	case "Query.miner":
		if e.complexity.Query.Miner == nil {
			break
		}

		args, err := ec.field_Query_miner_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Miner(childComplexity, args["address"].(types.Address)), true

	case "Query.minerPower":
		if e.complexity.Query.MinerPower == nil {
			break
		}

		args, err := ec.field_Query_minerPower_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MinerPower(childComplexity, args["address"].(*types.Address)), true

	case "Query.miningCount":
		if e.complexity.Query.MiningCount == nil {
			break
		}

		args, err := ec.field_Query_miningCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningCount(childComplexity, args["start"].(time.Time), args["end"].(time.Time), args["actor"].(*types.Address)), true

	case "Query.miningCountAggregate":
		if e.complexity.Query.MiningCountAggregate == nil {
			break
		}

		args, err := ec.field_Query_miningCountAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningCountAggregate(childComplexity, args["start"].(time.Time), args["end"].(time.Time), args["actor"].(*types.Address), args["interval"].(model.MiningTaskAggregateInterval)), true

	case "Query.miningCountSummary":
		if e.complexity.Query.MiningCountSummary == nil {
			break
		}

		args, err := ec.field_Query_miningCountSummary_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningCountSummary(childComplexity, args["start"].(time.Time), args["end"].(time.Time), args["actor"].(*types.Address)), true

	case "Query.miningStatusSummay":
		if e.complexity.Query.MiningStatusSummay == nil {
			break
		}

		args, err := ec.field_Query_miningStatusSummay_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningStatusSummay(childComplexity, args["spID"].(*types.ActorID), args["start"].(time.Time), args["end"].(time.Time)), true

	case "Query.miningSummaryByDay":
		if e.complexity.Query.MiningSummaryByDay == nil {
			break
		}

		args, err := ec.field_Query_miningSummaryByDay_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningSummaryByDay(childComplexity, args["start"].(time.Time), args["end"].(time.Time)), true

	case "Query.miningWins":
		if e.complexity.Query.MiningWins == nil {
			break
		}

		args, err := ec.field_Query_miningWins_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningWins(childComplexity, args["start"].(*time.Time), args["end"].(*time.Time), args["actor"].(*types.Address), args["include"].(*bool), args["offset"].(int), args["limit"].(int)), true

	case "Query.miningWinsCount":
		if e.complexity.Query.MiningWinsCount == nil {
			break
		}

		args, err := ec.field_Query_miningWinsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MiningWinsCount(childComplexity, args["start"].(*time.Time), args["end"].(*time.Time), args["actor"].(*types.Address), args["include"].(*bool)), true

	case "Query.nodeHealthSummary":
		if e.complexity.Query.NodeHealthSummary == nil {
			break
		}

		return e.complexity.Query.NodeHealthSummary(childComplexity), true

	case "Query.nodesInfo":
		if e.complexity.Query.NodesInfo == nil {
			break
		}

		return e.complexity.Query.NodesInfo(childComplexity), true

	case "Query.pipelinesSummary":
		if e.complexity.Query.PipelinesSummary == nil {
			break
		}

		return e.complexity.Query.PipelinesSummary(childComplexity), true

	case "Query.porep":
		if e.complexity.Query.Porep == nil {
			break
		}

		args, err := ec.field_Query_porep_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Porep(childComplexity, args["sp"].(types.Address), args["sectorNumber"].(int)), true

	case "Query.poreps":
		if e.complexity.Query.Poreps == nil {
			break
		}

		return e.complexity.Query.Poreps(childComplexity), true

	case "Query.prometheusQuery":
		if e.complexity.Query.PrometheusQuery == nil {
			break
		}

		args, err := ec.field_Query_prometheusQuery_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PrometheusQuery(childComplexity, args["query"].(string), args["time"].(*time.Time)), true

	case "Query.prometheusQueryRange":
		if e.complexity.Query.PrometheusQueryRange == nil {
			break
		}

		args, err := ec.field_Query_prometheusQueryRange_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PrometheusQueryRange(childComplexity, args["query"].(string), args["start"].(time.Time), args["end"].(time.Time), args["step"].(int)), true

	case "Query.runningTaskSummary":
		if e.complexity.Query.RunningTaskSummary == nil {
			break
		}

		return e.complexity.Query.RunningTaskSummary(childComplexity), true

	case "Query.sector":
		if e.complexity.Query.Sector == nil {
			break
		}

		args, err := ec.field_Query_sector_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sector(childComplexity, args["actor"].(types.Address), args["sectorNumber"].(int)), true

	case "Query.sectorSummary":
		if e.complexity.Query.SectorSummary == nil {
			break
		}

		return e.complexity.Query.SectorSummary(childComplexity), true

	case "Query.sectors":
		if e.complexity.Query.Sectors == nil {
			break
		}

		args, err := ec.field_Query_sectors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sectors(childComplexity, args["actor"].(*types.Address), args["sectorNumber"].(*int), args["offset"].(int), args["limit"].(int)), true

	case "Query.sectorsCount":
		if e.complexity.Query.SectorsCount == nil {
			break
		}

		args, err := ec.field_Query_sectorsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SectorsCount(childComplexity, args["actor"].(*types.Address)), true

	case "Query.storage":
		if e.complexity.Query.Storage == nil {
			break
		}

		args, err := ec.field_Query_storage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Storage(childComplexity, args["id"].(string)), true

	case "Query.storageStats":
		if e.complexity.Query.StorageStats == nil {
			break
		}

		return e.complexity.Query.StorageStats(childComplexity), true

	case "Query.storages":
		if e.complexity.Query.Storages == nil {
			break
		}

		return e.complexity.Query.Storages(childComplexity), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["id"].(int)), true

	case "Query.taskDurationStats":
		if e.complexity.Query.TaskDurationStats == nil {
			break
		}

		args, err := ec.field_Query_taskDurationStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskDurationStats(childComplexity, args["name"].(string), args["start"].(time.Time), args["end"].(time.Time)), true

	case "Query.taskHistories":
		if e.complexity.Query.TaskHistories == nil {
			break
		}

		args, err := ec.field_Query_taskHistories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistories(childComplexity, args["start"].(*time.Time), args["end"].(*time.Time), args["hostPort"].(*string), args["name"].(*string), args["result"].(*bool), args["offset"].(int), args["limit"].(int)), true

	case "Query.taskHistoriesAggregate":
		if e.complexity.Query.TaskHistoriesAggregate == nil {
			break
		}

		args, err := ec.field_Query_taskHistoriesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistoriesAggregate(childComplexity, args["start"].(time.Time), args["end"].(time.Time), args["interval"].(model.TaskHistoriesAggregateInterval)), true

	case "Query.taskHistoriesCount":
		if e.complexity.Query.TaskHistoriesCount == nil {
			break
		}

		args, err := ec.field_Query_taskHistoriesCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistoriesCount(childComplexity, args["start"].(*time.Time), args["end"].(*time.Time), args["hostPort"].(*string), args["name"].(*string), args["result"].(*bool)), true

	case "Query.taskNames":
		if e.complexity.Query.TaskNames == nil {
			break
		}

		return e.complexity.Query.TaskNames(childComplexity), true

	case "Query.taskSuccessRate":
		if e.complexity.Query.TaskSuccessRate == nil {
			break
		}

		args, err := ec.field_Query_taskSuccessRate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskSuccessRate(childComplexity, args["name"].(*string), args["start"].(time.Time), args["end"].(time.Time)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		return e.complexity.Query.Tasks(childComplexity), true

	case "Query.tasksCount":
		if e.complexity.Query.TasksCount == nil {
			break
		}

		return e.complexity.Query.TasksCount(childComplexity), true

	case "Query.tasksDurationStats":
		if e.complexity.Query.TasksDurationStats == nil {
			break
		}

		args, err := ec.field_Query_tasksDurationStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TasksDurationStats(childComplexity, args["start"].(time.Time), args["end"].(time.Time)), true

	case "Query.tasksStats":
		if e.complexity.Query.TasksStats == nil {
			break
		}

		args, err := ec.field_Query_tasksStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TasksStats(childComplexity, args["start"].(time.Time), args["end"].(time.Time), args["machine"].(*string)), true

	case "Query.wdpostProof":
		if e.complexity.Query.WdpostProof == nil {
			break
		}

		args, err := ec.field_Query_wdpostProof_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WdpostProof(childComplexity, args["spId"].(types.Address), args["provingPeriodStart"].(int), args["deadline"].(int), args["partition"].(int)), true

	case "Query.wdpostProofs":
		if e.complexity.Query.WdpostProofs == nil {
			break
		}

		args, err := ec.field_Query_wdpostProofs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WdpostProofs(childComplexity, args["spId"].(*types.Address), args["offset"].(int), args["limit"].(int)), true

	case "Query.wdpostProofsCount":
		if e.complexity.Query.WdpostProofsCount == nil {
			break
		}

		args, err := ec.field_Query_wdpostProofsCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WdpostProofsCount(childComplexity, args["spId"].(*types.Address)), true

	case "RunningTaskSummary.averageWaitTime":
		if e.complexity.RunningTaskSummary.AverageWaitTime == nil {
			break
		}

		return e.complexity.RunningTaskSummary.AverageWaitTime(childComplexity), true

	case "RunningTaskSummary.queued":
		if e.complexity.RunningTaskSummary.Queued == nil {
			break
		}

		return e.complexity.RunningTaskSummary.Queued(childComplexity), true

	case "RunningTaskSummary.running":
		if e.complexity.RunningTaskSummary.Running == nil {
			break
		}

		return e.complexity.RunningTaskSummary.Running(childComplexity), true

	case "Sector.events":
		if e.complexity.Sector.Events == nil {
			break
		}

		return e.complexity.Sector.Events(childComplexity), true

	case "Sector.id":
		if e.complexity.Sector.ID == nil {
			break
		}

		return e.complexity.Sector.ID(childComplexity), true

	case "Sector.locations":
		if e.complexity.Sector.Locations == nil {
			break
		}

		return e.complexity.Sector.Locations(childComplexity), true

	case "Sector.meta":
		if e.complexity.Sector.Meta == nil {
			break
		}

		return e.complexity.Sector.Meta(childComplexity), true

	case "Sector.pieces":
		if e.complexity.Sector.Pieces == nil {
			break
		}

		return e.complexity.Sector.Pieces(childComplexity), true

	case "Sector.porep":
		if e.complexity.Sector.Porep == nil {
			break
		}

		return e.complexity.Sector.Porep(childComplexity), true

	case "Sector.sectorNum":
		if e.complexity.Sector.SectorNum == nil {
			break
		}

		return e.complexity.Sector.SectorNum(childComplexity), true

	case "Sector.spID":
		if e.complexity.Sector.SpID == nil {
			break
		}

		return e.complexity.Sector.SpID(childComplexity), true

	case "Sector.status":
		if e.complexity.Sector.Status == nil {
			break
		}

		return e.complexity.Sector.Status(childComplexity), true

	case "Sector.tasks":
		if e.complexity.Sector.Tasks == nil {
			break
		}

		return e.complexity.Sector.Tasks(childComplexity), true

	case "SectorLocation.isPrimary":
		if e.complexity.SectorLocation.IsPrimary == nil {
			break
		}

		return e.complexity.SectorLocation.IsPrimary(childComplexity), true

	case "SectorLocation.minerId":
		if e.complexity.SectorLocation.MinerID == nil {
			break
		}

		return e.complexity.SectorLocation.MinerID(childComplexity), true

	case "SectorLocation.readRefs":
		if e.complexity.SectorLocation.ReadRefs == nil {
			break
		}

		return e.complexity.SectorLocation.ReadRefs(childComplexity), true

	case "SectorLocation.readTs":
		if e.complexity.SectorLocation.ReadTs == nil {
			break
		}

		return e.complexity.SectorLocation.ReadTs(childComplexity), true

	case "SectorLocation.sectorFiletype":
		if e.complexity.SectorLocation.SectorFiletype == nil {
			break
		}

		return e.complexity.SectorLocation.SectorFiletype(childComplexity), true

	case "SectorLocation.sectorNum":
		if e.complexity.SectorLocation.SectorNum == nil {
			break
		}

		return e.complexity.SectorLocation.SectorNum(childComplexity), true

	case "SectorLocation.storage":
		if e.complexity.SectorLocation.Storage == nil {
			break
		}

		return e.complexity.SectorLocation.Storage(childComplexity), true

	case "SectorLocation.storageId":
		if e.complexity.SectorLocation.StorageID == nil {
			break
		}

		return e.complexity.SectorLocation.StorageID(childComplexity), true

	case "SectorLocation.writeLockOwner":
		if e.complexity.SectorLocation.WriteLockOwner == nil {
			break
		}

		return e.complexity.SectorLocation.WriteLockOwner(childComplexity), true

	case "SectorLocation.writeTs":
		if e.complexity.SectorLocation.WriteTs == nil {
			break
		}

		return e.complexity.SectorLocation.WriteTs(childComplexity), true

	case "SectorMeta.curSealedCid":
		if e.complexity.SectorMeta.CurSealedCid == nil {
			break
		}

		return e.complexity.SectorMeta.CurSealedCid(childComplexity), true

	case "SectorMeta.curUnsealedCid":
		if e.complexity.SectorMeta.CurUnsealedCid == nil {
			break
		}

		return e.complexity.SectorMeta.CurUnsealedCid(childComplexity), true

	case "SectorMeta.deadline":
		if e.complexity.SectorMeta.Deadline == nil {
			break
		}

		return e.complexity.SectorMeta.Deadline(childComplexity), true

	case "SectorMeta.expirationEpoch":
		if e.complexity.SectorMeta.ExpirationEpoch == nil {
			break
		}

		return e.complexity.SectorMeta.ExpirationEpoch(childComplexity), true

	case "SectorMeta.id":
		if e.complexity.SectorMeta.ID == nil {
			break
		}

		return e.complexity.SectorMeta.ID(childComplexity), true

	case "SectorMeta.isCC":
		if e.complexity.SectorMeta.IsCc == nil {
			break
		}

		return e.complexity.SectorMeta.IsCc(childComplexity), true

	case "SectorMeta.msgCidCommit":
		if e.complexity.SectorMeta.MsgCidCommit == nil {
			break
		}

		return e.complexity.SectorMeta.MsgCidCommit(childComplexity), true

	case "SectorMeta.msgCidPrecommit":
		if e.complexity.SectorMeta.MsgCidPrecommit == nil {
			break
		}

		return e.complexity.SectorMeta.MsgCidPrecommit(childComplexity), true

	case "SectorMeta.msgCidUpdate":
		if e.complexity.SectorMeta.MsgCidUpdate == nil {
			break
		}

		return e.complexity.SectorMeta.MsgCidUpdate(childComplexity), true

	case "SectorMeta.origSealedCid":
		if e.complexity.SectorMeta.OrigSealedCid == nil {
			break
		}

		return e.complexity.SectorMeta.OrigSealedCid(childComplexity), true

	case "SectorMeta.origUnsealedCid":
		if e.complexity.SectorMeta.OrigUnsealedCid == nil {
			break
		}

		return e.complexity.SectorMeta.OrigUnsealedCid(childComplexity), true

	case "SectorMeta.partition":
		if e.complexity.SectorMeta.Partition == nil {
			break
		}

		return e.complexity.SectorMeta.Partition(childComplexity), true

	case "SectorMeta.regSealProof":
		if e.complexity.SectorMeta.RegSealProof == nil {
			break
		}

		return e.complexity.SectorMeta.RegSealProof(childComplexity), true

	case "SectorMeta.sectorNum":
		if e.complexity.SectorMeta.SectorNum == nil {
			break
		}

		return e.complexity.SectorMeta.SectorNum(childComplexity), true

	case "SectorMeta.seedEpoch":
		if e.complexity.SectorMeta.SeedEpoch == nil {
			break
		}

		return e.complexity.SectorMeta.SeedEpoch(childComplexity), true

	case "SectorMeta.seedValue":
		if e.complexity.SectorMeta.SeedValue == nil {
			break
		}

		return e.complexity.SectorMeta.SeedValue(childComplexity), true

	case "SectorMeta.spId":
		if e.complexity.SectorMeta.SpID == nil {
			break
		}

		return e.complexity.SectorMeta.SpID(childComplexity), true

	case "SectorMeta.ticketEpoch":
		if e.complexity.SectorMeta.TicketEpoch == nil {
			break
		}

		return e.complexity.SectorMeta.TicketEpoch(childComplexity), true

	case "SectorMeta.ticketValue":
		if e.complexity.SectorMeta.TicketValue == nil {
			break
		}

		return e.complexity.SectorMeta.TicketValue(childComplexity), true

	case "SectorMetaPiece.ddoPam":
		if e.complexity.SectorMetaPiece.DdoPam == nil {
			break
		}

		return e.complexity.SectorMetaPiece.DdoPam(childComplexity), true

	case "SectorMetaPiece.f05DealID":
		if e.complexity.SectorMetaPiece.F05DealID == nil {
			break
		}

		return e.complexity.SectorMetaPiece.F05DealID(childComplexity), true

	case "SectorMetaPiece.f05DealProposal":
		if e.complexity.SectorMetaPiece.F05DealProposal == nil {
			break
		}

		return e.complexity.SectorMetaPiece.F05DealProposal(childComplexity), true

	case "SectorMetaPiece.origEndEpoch":
		if e.complexity.SectorMetaPiece.OrigEndEpoch == nil {
			break
		}

		return e.complexity.SectorMetaPiece.OrigEndEpoch(childComplexity), true

	case "SectorMetaPiece.pieceCID":
		if e.complexity.SectorMetaPiece.PieceCid == nil {
			break
		}

		return e.complexity.SectorMetaPiece.PieceCid(childComplexity), true

	case "SectorMetaPiece.pieceNum":
		if e.complexity.SectorMetaPiece.PieceNum == nil {
			break
		}

		return e.complexity.SectorMetaPiece.PieceNum(childComplexity), true

	case "SectorMetaPiece.pieceSize":
		if e.complexity.SectorMetaPiece.PieceSize == nil {
			break
		}

		return e.complexity.SectorMetaPiece.PieceSize(childComplexity), true

	case "SectorMetaPiece.rawDataSize":
		if e.complexity.SectorMetaPiece.RawDataSize == nil {
			break
		}

		return e.complexity.SectorMetaPiece.RawDataSize(childComplexity), true

	case "SectorMetaPiece.requestedKeepData":
		if e.complexity.SectorMetaPiece.RequestedKeepData == nil {
			break
		}

		return e.complexity.SectorMetaPiece.RequestedKeepData(childComplexity), true

	case "SectorMetaPiece.sectorNum":
		if e.complexity.SectorMetaPiece.SectorNum == nil {
			break
		}

		return e.complexity.SectorMetaPiece.SectorNum(childComplexity), true

	case "SectorMetaPiece.spID":
		if e.complexity.SectorMetaPiece.SpID == nil {
			break
		}

		return e.complexity.SectorMetaPiece.SpID(childComplexity), true

	case "SectorMetaPiece.startEpoch":
		if e.complexity.SectorMetaPiece.StartEpoch == nil {
			break
		}

		return e.complexity.SectorMetaPiece.StartEpoch(childComplexity), true

	case "SectorSummary.active":
		if e.complexity.SectorSummary.Active == nil {
			break
		}

		return e.complexity.SectorSummary.Active(childComplexity), true

	case "SectorSummary.failed":
		if e.complexity.SectorSummary.Failed == nil {
			break
		}

		return e.complexity.SectorSummary.Failed(childComplexity), true

	case "SectorSummary.sealing":
		if e.complexity.SectorSummary.Sealing == nil {
			break
		}

		return e.complexity.SectorSummary.Sealing(childComplexity), true

	case "Storage.id":
		if e.complexity.Storage.ID == nil {
			break
		}

		return e.complexity.Storage.ID(childComplexity), true

	case "Storage.liveness":
		if e.complexity.Storage.Liveness == nil {
			break
		}

		return e.complexity.Storage.Liveness(childComplexity), true

	case "Storage.path":
		if e.complexity.Storage.Path == nil {
			break
		}

		return e.complexity.Storage.Path(childComplexity), true

	case "StorageLiveness.lastChecked":
		if e.complexity.StorageLiveness.LastChecked == nil {
			break
		}

		return e.complexity.StorageLiveness.LastChecked(childComplexity), true

	case "StorageLiveness.lastDead":
		if e.complexity.StorageLiveness.LastDead == nil {
			break
		}

		return e.complexity.StorageLiveness.LastDead(childComplexity), true

	case "StorageLiveness.lastDeadReason":
		if e.complexity.StorageLiveness.LastDeadReason == nil {
			break
		}

		return e.complexity.StorageLiveness.LastDeadReason(childComplexity), true

	case "StorageLiveness.lastLive":
		if e.complexity.StorageLiveness.LastLive == nil {
			break
		}

		return e.complexity.StorageLiveness.LastLive(childComplexity), true

	case "StorageLiveness.storageId":
		if e.complexity.StorageLiveness.StorageID == nil {
			break
		}

		return e.complexity.StorageLiveness.StorageID(childComplexity), true

	case "StorageLiveness.url":
		if e.complexity.StorageLiveness.URL == nil {
			break
		}

		return e.complexity.StorageLiveness.URL(childComplexity), true

	case "StoragePath.allowMiners":
		if e.complexity.StoragePath.AllowMiners == nil {
			break
		}

		return e.complexity.StoragePath.AllowMiners(childComplexity), true

	case "StoragePath.allowTo":
		if e.complexity.StoragePath.AllowTo == nil {
			break
		}

		return e.complexity.StoragePath.AllowTo(childComplexity), true

	case "StoragePath.allowTypes":
		if e.complexity.StoragePath.AllowTypes == nil {
			break
		}

		return e.complexity.StoragePath.AllowTypes(childComplexity), true

	case "StoragePath.available":
		if e.complexity.StoragePath.Available == nil {
			break
		}

		return e.complexity.StoragePath.Available(childComplexity), true

	case "StoragePath.canSeal":
		if e.complexity.StoragePath.CanSeal == nil {
			break
		}

		return e.complexity.StoragePath.CanSeal(childComplexity), true

	case "StoragePath.canStore":
		if e.complexity.StoragePath.CanStore == nil {
			break
		}

		return e.complexity.StoragePath.CanStore(childComplexity), true

	case "StoragePath.capacity":
		if e.complexity.StoragePath.Capacity == nil {
			break
		}

		return e.complexity.StoragePath.Capacity(childComplexity), true

	case "StoragePath.denyMiners":
		if e.complexity.StoragePath.DenyMiners == nil {
			break
		}

		return e.complexity.StoragePath.DenyMiners(childComplexity), true

	case "StoragePath.denyTypes":
		if e.complexity.StoragePath.DenyTypes == nil {
			break
		}

		return e.complexity.StoragePath.DenyTypes(childComplexity), true

	case "StoragePath.fsAvailable":
		if e.complexity.StoragePath.FsAvailable == nil {
			break
		}

		return e.complexity.StoragePath.FsAvailable(childComplexity), true

	case "StoragePath.groups":
		if e.complexity.StoragePath.Groups == nil {
			break
		}

		return e.complexity.StoragePath.Groups(childComplexity), true

	case "StoragePath.heartbeatErr":
		if e.complexity.StoragePath.HeartbeatErr == nil {
			break
		}

		return e.complexity.StoragePath.HeartbeatErr(childComplexity), true

	case "StoragePath.id":
		if e.complexity.StoragePath.ID == nil {
			break
		}

		return e.complexity.StoragePath.ID(childComplexity), true

	case "StoragePath.lastHeartbeat":
		if e.complexity.StoragePath.LastHeartbeat == nil {
			break
		}

		return e.complexity.StoragePath.LastHeartbeat(childComplexity), true

	case "StoragePath.maxStorage":
		if e.complexity.StoragePath.MaxStorage == nil {
			break
		}

		return e.complexity.StoragePath.MaxStorage(childComplexity), true

	case "StoragePath.reserved":
		if e.complexity.StoragePath.Reserved == nil {
			break
		}

		return e.complexity.StoragePath.Reserved(childComplexity), true

	case "StoragePath.storageId":
		if e.complexity.StoragePath.StorageID == nil {
			break
		}

		return e.complexity.StoragePath.StorageID(childComplexity), true

	case "StoragePath.type":
		if e.complexity.StoragePath.Type == nil {
			break
		}

		return e.complexity.StoragePath.Type(childComplexity), true

	case "StoragePath.urls":
		if e.complexity.StoragePath.Urls == nil {
			break
		}

		return e.complexity.StoragePath.Urls(childComplexity), true

	case "StoragePath.used":
		if e.complexity.StoragePath.Used == nil {
			break
		}

		return e.complexity.StoragePath.Used(childComplexity), true

	case "StoragePath.weight":
		if e.complexity.StoragePath.Weight == nil {
			break
		}

		return e.complexity.StoragePath.Weight(childComplexity), true

	case "StorageStats.totalAvailable":
		if e.complexity.StorageStats.TotalAvailable == nil {
			break
		}

		return e.complexity.StorageStats.TotalAvailable(childComplexity), true

	case "StorageStats.totalCapacity":
		if e.complexity.StorageStats.TotalCapacity == nil {
			break
		}

		return e.complexity.StorageStats.TotalCapacity(childComplexity), true

	case "StorageStats.totalFsAvailable":
		if e.complexity.StorageStats.TotalFsAvailable == nil {
			break
		}

		return e.complexity.StorageStats.TotalFsAvailable(childComplexity), true

	case "StorageStats.totalReserved":
		if e.complexity.StorageStats.TotalReserved == nil {
			break
		}

		return e.complexity.StorageStats.TotalReserved(childComplexity), true

	case "StorageStats.totalUsed":
		if e.complexity.StorageStats.TotalUsed == nil {
			break
		}

		return e.complexity.StorageStats.TotalUsed(childComplexity), true

	case "StorageStats.type":
		if e.complexity.StorageStats.Type == nil {
			break
		}

		return e.complexity.StorageStats.Type(childComplexity), true

	case "StorageUsage.available":
		if e.complexity.StorageUsage.Available == nil {
			break
		}

		return e.complexity.StorageUsage.Available(childComplexity), true

	case "StorageUsage.fsAvailable":
		if e.complexity.StorageUsage.FsAvailable == nil {
			break
		}

		return e.complexity.StorageUsage.FsAvailable(childComplexity), true

	case "StorageUsage.reserved":
		if e.complexity.StorageUsage.Reserved == nil {
			break
		}

		return e.complexity.StorageUsage.Reserved(childComplexity), true

	case "StorageUsage.time":
		if e.complexity.StorageUsage.Time == nil {
			break
		}

		return e.complexity.StorageUsage.Time(childComplexity), true

	case "StorageUsage.used":
		if e.complexity.StorageUsage.Used == nil {
			break
		}

		return e.complexity.StorageUsage.Used(childComplexity), true

	case "Subscription.alerts":
		if e.complexity.Subscription.Alerts == nil {
			break
		}

		args, err := ec.field_Subscription_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Alerts(childComplexity, args["offset"].(int)), true

	case "Subscription.chainHead":
		if e.complexity.Subscription.ChainHead == nil {
			break
		}

		return e.complexity.Subscription.ChainHead(childComplexity), true

	case "Subscription.completedTask":
		if e.complexity.Subscription.CompletedTask == nil {
			break
		}

		args, err := ec.field_Subscription_completedTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.CompletedTask(childComplexity, args["machine"].(*string), args["last"].(int)), true

	case "Subscription.newTask":
		if e.complexity.Subscription.NewTask == nil {
			break
		}

		args, err := ec.field_Subscription_newTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.NewTask(childComplexity, args["machineID"].(*int), args["last"].(int)), true

	case "Task.addedBy":
		if e.complexity.Task.AddedBy == nil {
			break
		}

		return e.complexity.Task.AddedBy(childComplexity), true

	case "Task.addedByID":
		if e.complexity.Task.AddedByID == nil {
			break
		}

		return e.complexity.Task.AddedByID(childComplexity), true

	case "Task.histories":
		if e.complexity.Task.Histories == nil {
			break
		}

		return e.complexity.Task.Histories(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.initiatedBy":
		if e.complexity.Task.InitiatedBy == nil {
			break
		}

		return e.complexity.Task.InitiatedBy(childComplexity), true

	case "Task.initiatedByID":
		if e.complexity.Task.InitiatedByID == nil {
			break
		}

		return e.complexity.Task.InitiatedByID(childComplexity), true

	case "Task.name":
		if e.complexity.Task.Name == nil {
			break
		}

		return e.complexity.Task.Name(childComplexity), true

	case "Task.owner":
		if e.complexity.Task.Owner == nil {
			break
		}

		return e.complexity.Task.Owner(childComplexity), true

	case "Task.ownerId":
		if e.complexity.Task.OwnerID == nil {
			break
		}

		return e.complexity.Task.OwnerID(childComplexity), true

	case "Task.postedTime":
		if e.complexity.Task.PostedTime == nil {
			break
		}

		return e.complexity.Task.PostedTime(childComplexity), true

	case "Task.previousTask":
		if e.complexity.Task.PreviousTask == nil {
			break
		}

		return e.complexity.Task.PreviousTask(childComplexity), true

	case "Task.previousTaskID":
		if e.complexity.Task.PreviousTaskID == nil {
			break
		}

		return e.complexity.Task.PreviousTaskID(childComplexity), true

	case "Task.updateTime":
		if e.complexity.Task.UpdateTime == nil {
			break
		}

		return e.complexity.Task.UpdateTime(childComplexity), true

	case "TaskAggregate.failure":
		if e.complexity.TaskAggregate.Failure == nil {
			break
		}

		return e.complexity.TaskAggregate.Failure(childComplexity), true

	case "TaskAggregate.success":
		if e.complexity.TaskAggregate.Success == nil {
			break
		}

		return e.complexity.TaskAggregate.Success(childComplexity), true

	case "TaskAggregate.time":
		if e.complexity.TaskAggregate.Time == nil {
			break
		}

		return e.complexity.TaskAggregate.Time(childComplexity), true

	case "TaskAggregate.total":
		if e.complexity.TaskAggregate.Total == nil {
			break
		}

		return e.complexity.TaskAggregate.Total(childComplexity), true

	case "TaskCompactStage.name":
		if e.complexity.TaskCompactStage.Name == nil {
			break
		}

		return e.complexity.TaskCompactStage.Name(childComplexity), true

	case "TaskCompactStage.status":
		if e.complexity.TaskCompactStage.Status == nil {
			break
		}

		return e.complexity.TaskCompactStage.Status(childComplexity), true

	case "TaskCompactStage.taskId":
		if e.complexity.TaskCompactStage.TaskID == nil {
			break
		}

		return e.complexity.TaskCompactStage.TaskID(childComplexity), true

	case "TaskDurationStats.avgDurationSeconds":
		if e.complexity.TaskDurationStats.AvgDurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.AvgDurationSeconds(childComplexity), true

	case "TaskDurationStats.maxDurationSeconds":
		if e.complexity.TaskDurationStats.MaxDurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.MaxDurationSeconds(childComplexity), true

	case "TaskDurationStats.medianDurationSeconds":
		if e.complexity.TaskDurationStats.MedianDurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.MedianDurationSeconds(childComplexity), true

	case "TaskDurationStats.minDurationSeconds":
		if e.complexity.TaskDurationStats.MinDurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.MinDurationSeconds(childComplexity), true

	case "TaskDurationStats.name":
		if e.complexity.TaskDurationStats.Name == nil {
			break
		}

		return e.complexity.TaskDurationStats.Name(childComplexity), true

	case "TaskDurationStats.p90DurationSeconds":
		if e.complexity.TaskDurationStats.P90DurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.P90DurationSeconds(childComplexity), true

	case "TaskDurationStats.p95DurationSeconds":
		if e.complexity.TaskDurationStats.P95DurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.P95DurationSeconds(childComplexity), true

	case "TaskDurationStats.p99DurationSeconds":
		if e.complexity.TaskDurationStats.P99DurationSeconds == nil {
			break
		}

		return e.complexity.TaskDurationStats.P99DurationSeconds(childComplexity), true

	case "TaskDurationStats.totalTasks":
		if e.complexity.TaskDurationStats.TotalTasks == nil {
			break
		}

		return e.complexity.TaskDurationStats.TotalTasks(childComplexity), true

	case "TaskHistory.completedBy":
		if e.complexity.TaskHistory.CompletedBy == nil {
			break
		}

		return e.complexity.TaskHistory.CompletedBy(childComplexity), true

	case "TaskHistory.completedByHostAndPort":
		if e.complexity.TaskHistory.CompletedByHostAndPort == nil {
			break
		}

		return e.complexity.TaskHistory.CompletedByHostAndPort(childComplexity), true

	case "TaskHistory.err":
		if e.complexity.TaskHistory.Err == nil {
			break
		}

		return e.complexity.TaskHistory.Err(childComplexity), true

	case "TaskHistory.id":
		if e.complexity.TaskHistory.ID == nil {
			break
		}

		return e.complexity.TaskHistory.ID(childComplexity), true

	case "TaskHistory.name":
		if e.complexity.TaskHistory.Name == nil {
			break
		}

		return e.complexity.TaskHistory.Name(childComplexity), true

	case "TaskHistory.posted":
		if e.complexity.TaskHistory.Posted == nil {
			break
		}

		return e.complexity.TaskHistory.Posted(childComplexity), true

	case "TaskHistory.result":
		if e.complexity.TaskHistory.Result == nil {
			break
		}

		return e.complexity.TaskHistory.Result(childComplexity), true

	case "TaskHistory.taskId":
		if e.complexity.TaskHistory.TaskID == nil {
			break
		}

		return e.complexity.TaskHistory.TaskID(childComplexity), true

	case "TaskHistory.workEnd":
		if e.complexity.TaskHistory.WorkEnd == nil {
			break
		}

		return e.complexity.TaskHistory.WorkEnd(childComplexity), true

	case "TaskHistory.workStart":
		if e.complexity.TaskHistory.WorkStart == nil {
			break
		}

		return e.complexity.TaskHistory.WorkStart(childComplexity), true

	case "TaskNameAggregate.failure":
		if e.complexity.TaskNameAggregate.Failure == nil {
			break
		}

		return e.complexity.TaskNameAggregate.Failure(childComplexity), true

	case "TaskNameAggregate.name":
		if e.complexity.TaskNameAggregate.Name == nil {
			break
		}

		return e.complexity.TaskNameAggregate.Name(childComplexity), true

	case "TaskNameAggregate.success":
		if e.complexity.TaskNameAggregate.Success == nil {
			break
		}

		return e.complexity.TaskNameAggregate.Success(childComplexity), true

	case "TaskNameAggregate.total":
		if e.complexity.TaskNameAggregate.Total == nil {
			break
		}

		return e.complexity.TaskNameAggregate.Total(childComplexity), true

	case "TaskStats.failure":
		if e.complexity.TaskStats.Failure == nil {
			break
		}

		return e.complexity.TaskStats.Failure(childComplexity), true

	case "TaskStats.name":
		if e.complexity.TaskStats.Name == nil {
			break
		}

		return e.complexity.TaskStats.Name(childComplexity), true

	case "TaskStats.success":
		if e.complexity.TaskStats.Success == nil {
			break
		}

		return e.complexity.TaskStats.Success(childComplexity), true

	case "TaskStats.total":
		if e.complexity.TaskStats.Total == nil {
			break
		}

		return e.complexity.TaskStats.Total(childComplexity), true

	case "TaskSuccessRate.failure":
		if e.complexity.TaskSuccessRate.Failure == nil {
			break
		}

		return e.complexity.TaskSuccessRate.Failure(childComplexity), true

	case "TaskSuccessRate.success":
		if e.complexity.TaskSuccessRate.Success == nil {
			break
		}

		return e.complexity.TaskSuccessRate.Success(childComplexity), true

	case "TaskSuccessRate.successRate":
		if e.complexity.TaskSuccessRate.SuccessRate == nil {
			break
		}

		return e.complexity.TaskSuccessRate.SuccessRate(childComplexity), true

	case "TaskSuccessRate.total":
		if e.complexity.TaskSuccessRate.Total == nil {
			break
		}

		return e.complexity.TaskSuccessRate.Total(childComplexity), true

	case "TaskSummary.falseCount":
		if e.complexity.TaskSummary.FalseCount == nil {
			break
		}

		return e.complexity.TaskSummary.FalseCount(childComplexity), true

	case "TaskSummary.name":
		if e.complexity.TaskSummary.Name == nil {
			break
		}

		return e.complexity.TaskSummary.Name(childComplexity), true

	case "TaskSummary.totalCount":
		if e.complexity.TaskSummary.TotalCount == nil {
			break
		}

		return e.complexity.TaskSummary.TotalCount(childComplexity), true

	case "TaskSummary.trueCount":
		if e.complexity.TaskSummary.TrueCount == nil {
			break
		}

		return e.complexity.TaskSummary.TrueCount(childComplexity), true

	case "TaskSummaryDay.day":
		if e.complexity.TaskSummaryDay.Day == nil {
			break
		}

		return e.complexity.TaskSummaryDay.Day(childComplexity), true

	case "TaskSummaryDay.falseCount":
		if e.complexity.TaskSummaryDay.FalseCount == nil {
			break
		}

		return e.complexity.TaskSummaryDay.FalseCount(childComplexity), true

	case "TaskSummaryDay.totalCount":
		if e.complexity.TaskSummaryDay.TotalCount == nil {
			break
		}

		return e.complexity.TaskSummaryDay.TotalCount(childComplexity), true

	case "TaskSummaryDay.trueCount":
		if e.complexity.TaskSummaryDay.TrueCount == nil {
			break
		}

		return e.complexity.TaskSummaryDay.TrueCount(childComplexity), true

	case "WalletBalance.address":
		if e.complexity.WalletBalance.Address == nil {
			break
		}

		return e.complexity.WalletBalance.Address(childComplexity), true

	case "WalletBalance.balance":
		if e.complexity.WalletBalance.Balance == nil {
			break
		}

		return e.complexity.WalletBalance.Balance(childComplexity), true

	case "WdpostProofs.deadline":
		if e.complexity.WdpostProofs.Deadline == nil {
			break
		}

		return e.complexity.WdpostProofs.Deadline(childComplexity), true

	case "WdpostProofs.id":
		if e.complexity.WdpostProofs.ID == nil {
			break
		}

		return e.complexity.WdpostProofs.ID(childComplexity), true

	case "WdpostProofs.messageCid":
		if e.complexity.WdpostProofs.MessageCid == nil {
			break
		}

		return e.complexity.WdpostProofs.MessageCid(childComplexity), true

	case "WdpostProofs.partition":
		if e.complexity.WdpostProofs.Partition == nil {
			break
		}

		return e.complexity.WdpostProofs.Partition(childComplexity), true

	case "WdpostProofs.proofParams":
		if e.complexity.WdpostProofs.ProofParams == nil {
			break
		}

		return e.complexity.WdpostProofs.ProofParams(childComplexity), true

	case "WdpostProofs.provingPeriodStart":
		if e.complexity.WdpostProofs.ProvingPeriodStart == nil {
			break
		}

		return e.complexity.WdpostProofs.ProvingPeriodStart(childComplexity), true

	case "WdpostProofs.spId":
		if e.complexity.WdpostProofs.SpID == nil {
			break
		}

		return e.complexity.WdpostProofs.SpID(childComplexity), true

	case "WdpostProofs.submitAtEpoch":
		if e.complexity.WdpostProofs.SubmitAtEpoch == nil {
			break
		}

		return e.complexity.WdpostProofs.SubmitAtEpoch(childComplexity), true

	case "WdpostProofs.submitByEpoch":
		if e.complexity.WdpostProofs.SubmitByEpoch == nil {
			break
		}

		return e.complexity.WdpostProofs.SubmitByEpoch(childComplexity), true

	case "WdpostProofs.submitTaskId":
		if e.complexity.WdpostProofs.SubmitTaskID == nil {
			break
		}

		return e.complexity.WdpostProofs.SubmitTaskID(childComplexity), true

	case "WdpostProofs.testTaskId":
		if e.complexity.WdpostProofs.TestTaskID == nil {
			break
		}

		return e.complexity.WdpostProofs.TestTaskID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputClientFilterInput,
		ec.unmarshalInputMarketMk12DealFilterInput,
		ec.unmarshalInputMarketMk12StorageAskInput,
		ec.unmarshalInputPriceFilterInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema/actor.graphql" "schema/alert.graphql" "schema/config.graphql" "schema/deal.graphql" "schema/directive.graphql" "schema/ipni.graphql" "schema/machine.graphql" "schema/market.graphql" "schema/message.graphql" "schema/metadata.graphql" "schema/miner.graphql" "schema/mining.graphql" "schema/mutation.graphql" "schema/node.graphql" "schema/pipeline.graphql" "schema/prometheus.graphql" "schema/query.graphql" "schema/sector.graphql" "schema/storage.graphql" "schema/subscription.graphql" "schema/task.graphql" "schema/types.graphql" "schema/user.graphql" "schema/wdpost.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/actor.graphql", Input: sourceData("schema/actor.graphql"), BuiltIn: false},
	{Name: "schema/alert.graphql", Input: sourceData("schema/alert.graphql"), BuiltIn: false},
	{Name: "schema/config.graphql", Input: sourceData("schema/config.graphql"), BuiltIn: false},
	{Name: "schema/deal.graphql", Input: sourceData("schema/deal.graphql"), BuiltIn: false},
	{Name: "schema/directive.graphql", Input: sourceData("schema/directive.graphql"), BuiltIn: false},
	{Name: "schema/ipni.graphql", Input: sourceData("schema/ipni.graphql"), BuiltIn: false},
	{Name: "schema/machine.graphql", Input: sourceData("schema/machine.graphql"), BuiltIn: false},
	{Name: "schema/market.graphql", Input: sourceData("schema/market.graphql"), BuiltIn: false},
	{Name: "schema/message.graphql", Input: sourceData("schema/message.graphql"), BuiltIn: false},
	{Name: "schema/metadata.graphql", Input: sourceData("schema/metadata.graphql"), BuiltIn: false},
	{Name: "schema/miner.graphql", Input: sourceData("schema/miner.graphql"), BuiltIn: false},
	{Name: "schema/mining.graphql", Input: sourceData("schema/mining.graphql"), BuiltIn: false},
	{Name: "schema/mutation.graphql", Input: sourceData("schema/mutation.graphql"), BuiltIn: false},
	{Name: "schema/node.graphql", Input: sourceData("schema/node.graphql"), BuiltIn: false},
	{Name: "schema/pipeline.graphql", Input: sourceData("schema/pipeline.graphql"), BuiltIn: false},
	{Name: "schema/prometheus.graphql", Input: sourceData("schema/prometheus.graphql"), BuiltIn: false},
	{Name: "schema/query.graphql", Input: sourceData("schema/query.graphql"), BuiltIn: false},
	{Name: "schema/sector.graphql", Input: sourceData("schema/sector.graphql"), BuiltIn: false},
	{Name: "schema/storage.graphql", Input: sourceData("schema/storage.graphql"), BuiltIn: false},
	{Name: "schema/subscription.graphql", Input: sourceData("schema/subscription.graphql"), BuiltIn: false},
	{Name: "schema/task.graphql", Input: sourceData("schema/task.graphql"), BuiltIn: false},
	{Name: "schema/types.graphql", Input: sourceData("schema/types.graphql"), BuiltIn: false},
	{Name: "schema/user.graphql", Input: sourceData("schema/user.graphql"), BuiltIn: false},
	{Name: "schema/wdpost.graphql", Input: sourceData("schema/wdpost.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_hasRole_argsRole(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["role"] = arg0
	return args, nil
}
func (ec *executionContext) dir_hasRole_argsRole(
	ctx context.Context,
	rawArgs map[string]any,
) (model.Role, error) {
	if _, ok := rawArgs["role"]; !ok {
		var zeroVal model.Role
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
	if tmp, ok := rawArgs["role"]; ok {
		return ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, tmp)
	}

	var zeroVal model.Role
	return zeroVal, nil
}

func (ec *executionContext) field_Machine_taskHistories_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Machine_taskHistories_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg0
	return args, nil
}
func (ec *executionContext) field_Machine_taskHistories_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createConfig_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createConfig_argsTitle(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["title"] = arg0
	arg1, err := ec.field_Mutation_createConfig_argsConfig(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["config"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_createConfig_argsTitle(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["title"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
	if tmp, ok := rawArgs["title"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createConfig_argsConfig(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["config"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
	if tmp, ok := rawArgs["config"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_dealSealNow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_dealSealNow_argsMiner(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["miner"] = arg0
	arg1, err := ec.field_Mutation_dealSealNow_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_dealSealNow_argsMiner(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["miner"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("miner"))
	if tmp, ok := rawArgs["miner"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_dealSealNow_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (uint64, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal uint64
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalNUint642uint64(ctx, tmp)
	}

	var zeroVal uint64
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketAddBalance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketAddBalance_argsMiner(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["miner"] = arg0
	arg1, err := ec.field_Mutation_marketAddBalance_argsWallet(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["wallet"] = arg1
	arg2, err := ec.field_Mutation_marketAddBalance_argsAmount(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["amount"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_marketAddBalance_argsMiner(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["miner"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("miner"))
	if tmp, ok := rawArgs["miner"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketAddBalance_argsWallet(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["wallet"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("wallet"))
	if tmp, ok := rawArgs["wallet"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketAddBalance_argsAmount(
	ctx context.Context,
	rawArgs map[string]any,
) (types.FIL, error) {
	if _, ok := rawArgs["amount"]; !ok {
		var zeroVal types.FIL
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
	if tmp, ok := rawArgs["amount"]; ok {
		return ec.unmarshalNFIL2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐFIL(ctx, tmp)
	}

	var zeroVal types.FIL
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketAddClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketAddClientFilter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketAddClientFilter_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.ClientFilterInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.ClientFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNClientFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilterInput(ctx, tmp)
	}

	var zeroVal model.ClientFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketAddPriceFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketAddPriceFilter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketAddPriceFilter_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.PriceFilterInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.PriceFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPriceFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilterInput(ctx, tmp)
	}

	var zeroVal model.PriceFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketDeleteAllowFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketDeleteAllowFilter_argsWallet(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["wallet"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketDeleteAllowFilter_argsWallet(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["wallet"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("wallet"))
	if tmp, ok := rawArgs["wallet"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketDeleteClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketDeleteClientFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketDeleteClientFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketDeletePriceFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketDeletePriceFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketDeletePriceFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketSetAllowFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketSetAllowFilter_argsWallet(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["wallet"] = arg0
	arg1, err := ec.field_Mutation_marketSetAllowFilter_argsStatus(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_marketSetAllowFilter_argsWallet(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["wallet"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("wallet"))
	if tmp, ok := rawArgs["wallet"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketSetAllowFilter_argsStatus(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["status"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
	if tmp, ok := rawArgs["status"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketToggleAllowFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketToggleAllowFilter_argsWallet(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["wallet"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketToggleAllowFilter_argsWallet(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["wallet"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("wallet"))
	if tmp, ok := rawArgs["wallet"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketToggleClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketToggleClientFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketToggleClientFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketUpdateClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketUpdateClientFilter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketUpdateClientFilter_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.ClientFilterInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.ClientFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNClientFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilterInput(ctx, tmp)
	}

	var zeroVal model.ClientFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_marketUpdatePriceFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_marketUpdatePriceFilter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_marketUpdatePriceFilter_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.PriceFilterInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.PriceFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPriceFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilterInput(ctx, tmp)
	}

	var zeroVal model.PriceFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeConfig_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeConfig_argsTitle(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["title"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeConfig_argsTitle(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["title"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
	if tmp, ok := rawArgs["title"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeSector_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeSector_argsMiner(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["miner"] = arg0
	arg1, err := ec.field_Mutation_removeSector_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_removeSector_argsMiner(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["miner"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("miner"))
	if tmp, ok := rawArgs["miner"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeSector_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartSector_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartSector_argsMiner(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["miner"] = arg0
	arg1, err := ec.field_Mutation_restartSector_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_restartSector_argsMiner(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["miner"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("miner"))
	if tmp, ok := rawArgs["miner"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartSector_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateConfig_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateConfig_argsTitle(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["title"] = arg0
	arg1, err := ec.field_Mutation_updateConfig_argsConfig(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["config"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateConfig_argsTitle(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["title"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
	if tmp, ok := rawArgs["title"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateConfig_argsConfig(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["config"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
	if tmp, ok := rawArgs["config"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMarketMk12StorageAsk_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMarketMk12StorageAsk_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMarketMk12StorageAsk_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MarketMk12StorageAskInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MarketMk12StorageAskInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMarketMk12StorageAskInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAskInput(ctx, tmp)
	}

	var zeroVal model.MarketMk12StorageAskInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_actor_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_actor_argsAddress(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["address"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_actor_argsAddress(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["address"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
	if tmp, ok := rawArgs["address"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_config_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_config_argsLayer(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["layer"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_config_argsLayer(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["layer"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
	if tmp, ok := rawArgs["layer"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniAdvertisement_argsOrderNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderNumber"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_ipniAdvertisement_argsOrderNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["orderNumber"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNumber"))
	if tmp, ok := rawArgs["orderNumber"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisementsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniAdvertisementsCount_argsProvider(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["provider"] = arg0
	arg1, err := ec.field_Query_ipniAdvertisementsCount_argsIsSkip(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isSkip"] = arg1
	arg2, err := ec.field_Query_ipniAdvertisementsCount_argsIsRemoved(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isRemoved"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_ipniAdvertisementsCount_argsProvider(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["provider"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
	if tmp, ok := rawArgs["provider"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisementsCount_argsIsSkip(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isSkip"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isSkip"))
	if tmp, ok := rawArgs["isSkip"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisementsCount_argsIsRemoved(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isRemoved"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isRemoved"))
	if tmp, ok := rawArgs["isRemoved"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisements_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniAdvertisements_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg0
	arg1, err := ec.field_Query_ipniAdvertisements_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_ipniAdvertisements_argsProvider(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["provider"] = arg2
	arg3, err := ec.field_Query_ipniAdvertisements_argsIsSkip(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isSkip"] = arg3
	arg4, err := ec.field_Query_ipniAdvertisements_argsIsRemoved(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isRemoved"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_ipniAdvertisements_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisements_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisements_argsProvider(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["provider"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
	if tmp, ok := rawArgs["provider"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisements_argsIsSkip(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isSkip"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isSkip"))
	if tmp, ok := rawArgs["isSkip"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniAdvertisements_argsIsRemoved(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isRemoved"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isRemoved"))
	if tmp, ok := rawArgs["isRemoved"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_ipniTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTasksCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniTasksCount_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg0
	arg1, err := ec.field_Query_ipniTasksCount_argsIsRm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isRm"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_ipniTasksCount_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.ActorID, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal *types.ActorID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, tmp)
	}

	var zeroVal *types.ActorID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTasksCount_argsIsRm(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isRm"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isRm"))
	if tmp, ok := rawArgs["isRm"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_ipniTasks_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := ec.field_Query_ipniTasks_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg1
	arg2, err := ec.field_Query_ipniTasks_argsIsRm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isRm"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_ipniTasks_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTasks_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.ActorID, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal *types.ActorID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, tmp)
	}

	var zeroVal *types.ActorID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_ipniTasks_argsIsRm(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["isRm"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isRm"))
	if tmp, ok := rawArgs["isRm"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_machineByHostAndPort_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_machineByHostAndPort_argsHostAndPort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostAndPort"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_machineByHostAndPort_argsHostAndPort(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostAndPort"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAndPort"))
	if tmp, ok := rawArgs["hostAndPort"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_machine_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_machine_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_machine_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketAllowFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketAllowFilter_argsWallet(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["wallet"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketAllowFilter_argsWallet(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["wallet"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("wallet"))
	if tmp, ok := rawArgs["wallet"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketBalance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketBalance_argsMiner(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["miner"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketBalance_argsMiner(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["miner"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("miner"))
	if tmp, ok := rawArgs["miner"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketCheckClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketCheckClientFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketCheckClientFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketCheckPriceFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketCheckPriceFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketCheckPriceFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketClientFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketClientFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketClientFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketDealInfo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketDealInfo_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketDealInfo_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketMk12DealsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketMk12DealsCount_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketMk12DealsCount_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MarketMk12DealFilterInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MarketMk12DealFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMarketMk12DealFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12DealFilterInput(ctx, tmp)
	}

	var zeroVal model.MarketMk12DealFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketMk12Deals_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketMk12Deals_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := ec.field_Query_marketMk12Deals_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_marketMk12Deals_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_marketMk12Deals_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MarketMk12DealFilterInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MarketMk12DealFilterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMarketMk12DealFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12DealFilterInput(ctx, tmp)
	}

	var zeroVal model.MarketMk12DealFilterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketMk12Deals_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketMk12Deals_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketMk12StorageAsk_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketMk12StorageAsk_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketMk12StorageAsk_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_marketPriceFilter_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_marketPriceFilter_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_marketPriceFilter_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSend_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageSend_argsSendTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sendTaskId"] = arg0
	arg1, err := ec.field_Query_messageSend_argsFromKey(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fromKey"] = arg1
	arg2, err := ec.field_Query_messageSend_argsNonce(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["nonce"] = arg2
	arg3, err := ec.field_Query_messageSend_argsSignedCid(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["signedCID"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_messageSend_argsSendTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["sendTaskId"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sendTaskId"))
	if tmp, ok := rawArgs["sendTaskId"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSend_argsFromKey(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["fromKey"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fromKey"))
	if tmp, ok := rawArgs["fromKey"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSend_argsNonce(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["nonce"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
	if tmp, ok := rawArgs["nonce"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSend_argsSignedCid(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["signedCID"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("signedCID"))
	if tmp, ok := rawArgs["signedCID"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSendsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageSendsCount_argsAccount(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_messageSendsCount_argsAccount(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["account"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
	if tmp, ok := rawArgs["account"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSends_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageSends_argsAccount(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	arg1, err := ec.field_Query_messageSends_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := ec.field_Query_messageSends_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_messageSends_argsAccount(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["account"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
	if tmp, ok := rawArgs["account"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSends_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageSends_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageWait_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageWait_argsSignedMessageCid(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["signedMessageCid"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_messageWait_argsSignedMessageCid(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["signedMessageCid"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("signedMessageCid"))
	if tmp, ok := rawArgs["signedMessageCid"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageWaitsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageWaitsCount_argsWaiterMachineID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["waiterMachineId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_messageWaitsCount_argsWaiterMachineID(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["waiterMachineId"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("waiterMachineId"))
	if tmp, ok := rawArgs["waiterMachineId"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageWaits_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_messageWaits_argsWaiterMachineID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["waiterMachineId"] = arg0
	arg1, err := ec.field_Query_messageWaits_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := ec.field_Query_messageWaits_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_messageWaits_argsWaiterMachineID(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["waiterMachineId"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("waiterMachineId"))
	if tmp, ok := rawArgs["waiterMachineId"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageWaits_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_messageWaits_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_minerPower_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_minerPower_argsAddress(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["address"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_minerPower_argsAddress(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["address"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
	if tmp, ok := rawArgs["address"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miner_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miner_argsAddress(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["address"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_miner_argsAddress(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["address"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
	if tmp, ok := rawArgs["address"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountAggregate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningCountAggregate_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningCountAggregate_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_miningCountAggregate_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg2
	arg3, err := ec.field_Query_miningCountAggregate_argsInterval(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["interval"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_miningCountAggregate_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountAggregate_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountAggregate_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountAggregate_argsInterval(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MiningTaskAggregateInterval, error) {
	if _, ok := rawArgs["interval"]; !ok {
		var zeroVal model.MiningTaskAggregateInterval
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
	if tmp, ok := rawArgs["interval"]; ok {
		return ec.unmarshalNMiningTaskAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTaskAggregateInterval(ctx, tmp)
	}

	var zeroVal model.MiningTaskAggregateInterval
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountSummary_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningCountSummary_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningCountSummary_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_miningCountSummary_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_miningCountSummary_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountSummary_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCountSummary_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningCount_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningCount_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_miningCount_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_miningCount_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCount_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningCount_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningStatusSummay_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningStatusSummay_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spID"] = arg0
	arg1, err := ec.field_Query_miningStatusSummay_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg1
	arg2, err := ec.field_Query_miningStatusSummay_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_miningStatusSummay_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.ActorID, error) {
	if _, ok := rawArgs["spID"]; !ok {
		var zeroVal *types.ActorID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spID"))
	if tmp, ok := rawArgs["spID"]; ok {
		return ec.unmarshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, tmp)
	}

	var zeroVal *types.ActorID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningStatusSummay_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningStatusSummay_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningSummaryByDay_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningSummaryByDay_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningSummaryByDay_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_miningSummaryByDay_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningSummaryByDay_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWinsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningWinsCount_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningWinsCount_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_miningWinsCount_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg2
	arg3, err := ec.field_Query_miningWinsCount_argsInclude(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["include"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_miningWinsCount_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWinsCount_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWinsCount_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWinsCount_argsInclude(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["include"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("include"))
	if tmp, ok := rawArgs["include"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_miningWins_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_miningWins_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_miningWins_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg2
	arg3, err := ec.field_Query_miningWins_argsInclude(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["include"] = arg3
	arg4, err := ec.field_Query_miningWins_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg4
	arg5, err := ec.field_Query_miningWins_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg5
	return args, nil
}
func (ec *executionContext) field_Query_miningWins_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_argsInclude(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["include"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("include"))
	if tmp, ok := rawArgs["include"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_miningWins_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_porep_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_porep_argsSp(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sp"] = arg0
	arg1, err := ec.field_Query_porep_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_porep_argsSp(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["sp"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sp"))
	if tmp, ok := rawArgs["sp"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_porep_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQueryRange_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_prometheusQueryRange_argsQuery(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["query"] = arg0
	arg1, err := ec.field_Query_prometheusQueryRange_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg1
	arg2, err := ec.field_Query_prometheusQueryRange_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg2
	arg3, err := ec.field_Query_prometheusQueryRange_argsStep(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["step"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_prometheusQueryRange_argsQuery(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["query"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
	if tmp, ok := rawArgs["query"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQueryRange_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQueryRange_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQueryRange_argsStep(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["step"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("step"))
	if tmp, ok := rawArgs["step"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQuery_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_prometheusQuery_argsQuery(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["query"] = arg0
	arg1, err := ec.field_Query_prometheusQuery_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_prometheusQuery_argsQuery(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["query"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
	if tmp, ok := rawArgs["query"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_prometheusQuery_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sector_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_sector_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg0
	arg1, err := ec.field_Query_sector_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_sector_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sector_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sectorsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_sectorsCount_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_sectorsCount_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sectors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_sectors_argsActor(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["actor"] = arg0
	arg1, err := ec.field_Query_sectors_argsSectorNumber(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sectorNumber"] = arg1
	arg2, err := ec.field_Query_sectors_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	arg3, err := ec.field_Query_sectors_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_sectors_argsActor(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["actor"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("actor"))
	if tmp, ok := rawArgs["actor"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sectors_argsSectorNumber(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["sectorNumber"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorNumber"))
	if tmp, ok := rawArgs["sectorNumber"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sectors_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_sectors_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_storage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_storage_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_storage_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskDurationStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskDurationStats_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	arg1, err := ec.field_Query_taskDurationStats_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg1
	arg2, err := ec.field_Query_taskDurationStats_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_taskDurationStats_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskDurationStats_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskDurationStats_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesAggregate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskHistoriesAggregate_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_taskHistoriesAggregate_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_taskHistoriesAggregate_argsInterval(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["interval"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_taskHistoriesAggregate_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesAggregate_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesAggregate_argsInterval(
	ctx context.Context,
	rawArgs map[string]any,
) (model.TaskHistoriesAggregateInterval, error) {
	if _, ok := rawArgs["interval"]; !ok {
		var zeroVal model.TaskHistoriesAggregateInterval
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("interval"))
	if tmp, ok := rawArgs["interval"]; ok {
		return ec.unmarshalNTaskHistoriesAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistoriesAggregateInterval(ctx, tmp)
	}

	var zeroVal model.TaskHistoriesAggregateInterval
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskHistoriesCount_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_taskHistoriesCount_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_taskHistoriesCount_argsHostPort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostPort"] = arg2
	arg3, err := ec.field_Query_taskHistoriesCount_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg3
	arg4, err := ec.field_Query_taskHistoriesCount_argsResult(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["result"] = arg4
	return args, nil
}
func (ec *executionContext) field_Query_taskHistoriesCount_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesCount_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesCount_argsHostPort(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostPort"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostPort"))
	if tmp, ok := rawArgs["hostPort"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesCount_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistoriesCount_argsResult(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["result"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("result"))
	if tmp, ok := rawArgs["result"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskHistories_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_taskHistories_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_taskHistories_argsHostPort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostPort"] = arg2
	arg3, err := ec.field_Query_taskHistories_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg3
	arg4, err := ec.field_Query_taskHistories_argsResult(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["result"] = arg4
	arg5, err := ec.field_Query_taskHistories_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg5
	arg6, err := ec.field_Query_taskHistories_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg6
	return args, nil
}
func (ec *executionContext) field_Query_taskHistories_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsHostPort(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostPort"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostPort"))
	if tmp, ok := rawArgs["hostPort"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsResult(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["result"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("result"))
	if tmp, ok := rawArgs["result"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskHistories_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskSuccessRate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskSuccessRate_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	arg1, err := ec.field_Query_taskSuccessRate_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg1
	arg2, err := ec.field_Query_taskSuccessRate_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_taskSuccessRate_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskSuccessRate_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskSuccessRate_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_task_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_task_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_task_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tasksDurationStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tasksDurationStats_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_tasksDurationStats_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_tasksDurationStats_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tasksDurationStats_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tasksStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tasksStats_argsStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["start"] = arg0
	arg1, err := ec.field_Query_tasksStats_argsEnd(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["end"] = arg1
	arg2, err := ec.field_Query_tasksStats_argsMachine(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["machine"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_tasksStats_argsStart(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["start"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
	if tmp, ok := rawArgs["start"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tasksStats_argsEnd(
	ctx context.Context,
	rawArgs map[string]any,
) (time.Time, error) {
	if _, ok := rawArgs["end"]; !ok {
		var zeroVal time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
	if tmp, ok := rawArgs["end"]; ok {
		return ec.unmarshalNTime2timeᚐTime(ctx, tmp)
	}

	var zeroVal time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tasksStats_argsMachine(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["machine"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("machine"))
	if tmp, ok := rawArgs["machine"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProof_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_wdpostProof_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg0
	arg1, err := ec.field_Query_wdpostProof_argsProvingPeriodStart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["provingPeriodStart"] = arg1
	arg2, err := ec.field_Query_wdpostProof_argsDeadline(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["deadline"] = arg2
	arg3, err := ec.field_Query_wdpostProof_argsPartition(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["partition"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_wdpostProof_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (types.Address, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProof_argsProvingPeriodStart(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["provingPeriodStart"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("provingPeriodStart"))
	if tmp, ok := rawArgs["provingPeriodStart"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProof_argsDeadline(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["deadline"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("deadline"))
	if tmp, ok := rawArgs["deadline"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProof_argsPartition(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["partition"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("partition"))
	if tmp, ok := rawArgs["partition"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProofsCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_wdpostProofsCount_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_wdpostProofsCount_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProofs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_wdpostProofs_argsSpID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spId"] = arg0
	arg1, err := ec.field_Query_wdpostProofs_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := ec.field_Query_wdpostProofs_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_wdpostProofs_argsSpID(
	ctx context.Context,
	rawArgs map[string]any,
) (*types.Address, error) {
	if _, ok := rawArgs["spId"]; !ok {
		var zeroVal *types.Address
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
	if tmp, ok := rawArgs["spId"]; ok {
		return ec.unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, tmp)
	}

	var zeroVal *types.Address
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProofs_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_wdpostProofs_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_alerts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Subscription_alerts_argsOffset(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_alerts_argsOffset(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["offset"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
	if tmp, ok := rawArgs["offset"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_completedTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Subscription_completedTask_argsMachine(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["machine"] = arg0
	arg1, err := ec.field_Subscription_completedTask_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg1
	return args, nil
}
func (ec *executionContext) field_Subscription_completedTask_argsMachine(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["machine"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("machine"))
	if tmp, ok := rawArgs["machine"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_completedTask_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_newTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Subscription_newTask_argsMachineID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["machineID"] = arg0
	arg1, err := ec.field_Subscription_newTask_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg1
	return args, nil
}
func (ec *executionContext) field_Subscription_newTask_argsMachineID(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["machineID"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("machineID"))
	if tmp, ok := rawArgs["machineID"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_newTask_argsLast(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["last"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Actor_id(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_address(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_layers(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_layers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_layers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_qualityAdjustedPower(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_qualityAdjustedPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().QualityAdjustedPower(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_qualityAdjustedPower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_rawBytePower(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_rawBytePower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().RawBytePower(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_rawBytePower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_actorBalance(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_actorBalance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().ActorBalance(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_actorBalance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_actorAvailableBalance(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_actorAvailableBalance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().ActorAvailableBalance(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_actorAvailableBalance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_workerBalance(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_workerBalance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().WorkerBalance(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_workerBalance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Actor_deadlines(ctx context.Context, field graphql.CollectedField, obj *model.Actor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Actor_deadlines(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Actor().Deadlines(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ActorDeadline)
	fc.Result = res
	return ec.marshalOActorDeadline2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActorDeadline(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Actor_deadlines(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Actor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "empty":
				return ec.fieldContext_ActorDeadline_empty(ctx, field)
			case "current":
				return ec.fieldContext_ActorDeadline_current(ctx, field)
			case "proven":
				return ec.fieldContext_ActorDeadline_proven(ctx, field)
			case "partFaulty":
				return ec.fieldContext_ActorDeadline_partFaulty(ctx, field)
			case "faulty":
				return ec.fieldContext_ActorDeadline_faulty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActorDeadline", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActorDeadline_empty(ctx context.Context, field graphql.CollectedField, obj *model.ActorDeadline) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActorDeadline_empty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Empty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActorDeadline_empty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActorDeadline",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActorDeadline_current(ctx context.Context, field graphql.CollectedField, obj *model.ActorDeadline) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActorDeadline_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Current, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActorDeadline_current(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActorDeadline",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActorDeadline_proven(ctx context.Context, field graphql.CollectedField, obj *model.ActorDeadline) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActorDeadline_proven(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proven, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActorDeadline_proven(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActorDeadline",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActorDeadline_partFaulty(ctx context.Context, field graphql.CollectedField, obj *model.ActorDeadline) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActorDeadline_partFaulty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartFaulty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActorDeadline_partFaulty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActorDeadline",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActorDeadline_faulty(ctx context.Context, field graphql.CollectedField, obj *model.ActorDeadline) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActorDeadline_faulty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faulty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActorDeadline_faulty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActorDeadline",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_id(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_machineName(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_machineName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MachineName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_machineName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_message(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainHead_height(ctx context.Context, field graphql.CollectedField, obj *model.ChainHead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainHead_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainHead_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainHead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainHead_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.ChainHead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainHead_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainHead_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainHead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CidGravityStatus_miner(ctx context.Context, field graphql.CollectedField, obj *model.CidGravityStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CidGravityStatus_miner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Miner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CidGravityStatus_miner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CidGravityStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CidGravityStatus_status(ctx context.Context, field graphql.CollectedField, obj *model.CidGravityStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CidGravityStatus_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CidGravityStatus_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CidGravityStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_name(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_active(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_active(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_wallets(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*types.Address)
	fc.Result = res
	return ec.marshalNAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_wallets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_peers(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_peers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*types.PeerID)
	fc.Result = res
	return ec.marshalNPeerID2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerIDᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_peers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PeerID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_pricingFilters(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_pricingFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PricingFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_pricingFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_maxDealsPerHour(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_maxDealsPerHour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDealsPerHour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_maxDealsPerHour(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_maxDealSizePerHour(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_maxDealSizePerHour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDealSizePerHour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_maxDealSizePerHour(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientFilter_info(ctx context.Context, field graphql.CollectedField, obj *model.ClientFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientFilter_info(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Info, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientFilter_info(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Config_id(ctx context.Context, field graphql.CollectedField, obj *model.Config) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Config_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Config_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Config_title(ctx context.Context, field graphql.CollectedField, obj *model.Config) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Config_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Config_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Config_config(ctx context.Context, field graphql.CollectedField, obj *model.Config) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Config_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Config_config(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Config_usedBy(ctx context.Context, field graphql.CollectedField, obj *model.Config) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Config_usedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Config().UsedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MachineDetail)
	fc.Result = res
	return ec.marshalNMachineDetail2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Config_usedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Config",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MachineDetail_id(ctx, field)
			case "machineName":
				return ec.fieldContext_MachineDetail_machineName(ctx, field)
			case "tasks":
				return ec.fieldContext_MachineDetail_tasks(ctx, field)
			case "tasksArray":
				return ec.fieldContext_MachineDetail_tasksArray(ctx, field)
			case "layers":
				return ec.fieldContext_MachineDetail_layers(ctx, field)
			case "layersArray":
				return ec.fieldContext_MachineDetail_layersArray(ctx, field)
			case "startupTime":
				return ec.fieldContext_MachineDetail_startupTime(ctx, field)
			case "miners":
				return ec.fieldContext_MachineDetail_miners(ctx, field)
			case "minersArray":
				return ec.fieldContext_MachineDetail_minersArray(ctx, field)
			case "machineId":
				return ec.fieldContext_MachineDetail_machineId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MachineDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealCountSummary_boost(ctx context.Context, field graphql.CollectedField, obj *model.DealCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealCountSummary_boost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Boost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealCountSummary_boost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealCountSummary_direct(ctx context.Context, field graphql.CollectedField, obj *model.DealCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealCountSummary_direct(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Direct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealCountSummary_direct(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealCountSummary_legacy(ctx context.Context, field graphql.CollectedField, obj *model.DealCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealCountSummary_legacy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legacy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealCountSummary_legacy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_spId(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.ActorID)
	fc.Result = res
	return ec.marshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActorID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_sector(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_sector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_sector(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_signedProposalCid(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_signedProposalCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedProposalCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_signedProposalCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_offline(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_offline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Offline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_offline(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_verified(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_verified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_verified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_startEpoch(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_startEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_startEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_endEpoch(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_endEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_endEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_clientPeerId(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_clientPeerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientPeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.PeerID)
	fc.Result = res
	return ec.marshalNPeerID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_clientPeerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PeerID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_chainDealId(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_chainDealId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChainDealID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_chainDealId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_publishCid(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_publishCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_publishCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_pieceCid(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_pieceCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_pieceCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_pieceSize(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_pieceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_pieceSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_fastRetrieval(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_fastRetrieval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FastRetrieval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_fastRetrieval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_announceToIpni(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_announceToIpni(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnounceToIpni, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_announceToIpni(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_url(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_urls(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Urls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_urlHeaders(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_urlHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.JSON)
	fc.Result = res
	return ec.marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_urlHeaders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_error(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_miner(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_miner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Miner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_miner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_isLegacy(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_isLegacy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLegacy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_isLegacy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_indexed(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_indexed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indexed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullBool)
	fc.Result = res
	return ec.marshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_indexed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullBool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DealInfo_isDdo(ctx context.Context, field graphql.CollectedField, obj *model.DealInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DealInfo_isDdo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDdo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DealInfo_isDdo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DealInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DefaultFilterBehaviour_allowDealsFromUnknownClients(ctx context.Context, field graphql.CollectedField, obj *model.DefaultFilterBehaviour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DefaultFilterBehaviour_allowDealsFromUnknownClients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowDealsFromUnknownClients, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DefaultFilterBehaviour_allowDealsFromUnknownClients(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DefaultFilterBehaviour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DefaultFilterBehaviour_isDealRejectedWhenCidGravityNotReachable(ctx context.Context, field graphql.CollectedField, obj *model.DefaultFilterBehaviour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DefaultFilterBehaviour_isDealRejectedWhenCidGravityNotReachable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDealRejectedWhenCidGravityNotReachable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DefaultFilterBehaviour_isDealRejectedWhenCidGravityNotReachable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DefaultFilterBehaviour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DefaultFilterBehaviour_isCidGravityEnabled(ctx context.Context, field graphql.CollectedField, obj *model.DefaultFilterBehaviour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DefaultFilterBehaviour_isCidGravityEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCidGravityEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CidGravityStatus)
	fc.Result = res
	return ec.marshalNCidGravityStatus2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐCidGravityStatusᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DefaultFilterBehaviour_isCidGravityEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DefaultFilterBehaviour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "miner":
				return ec.fieldContext_CidGravityStatus_miner(ctx, field)
			case "status":
				return ec.fieldContext_CidGravityStatus_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CidGravityStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GaugeCountValue_key(ctx context.Context, field graphql.CollectedField, obj *model.GaugeCountValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GaugeCountValue_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GaugeCountValue_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GaugeCountValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GaugeCountValue_value(ctx context.Context, field graphql.CollectedField, obj *model.GaugeCountValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GaugeCountValue_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GaugeCountValue_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GaugeCountValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_orderNumber(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_orderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_orderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_pieceCid(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_pieceCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_pieceCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_adCid(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_adCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_adCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_previous(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_previous(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Previous, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_previous(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_contextId(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_contextId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContextID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_contextId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_pieceSize(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_pieceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_pieceSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_provider(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIAdvertisement().Provider(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPNIPeerID)
	fc.Result = res
	return ec.marshalOIPNIPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIPeerID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "peerID":
				return ec.fieldContext_IPNIPeerID_peerID(ctx, field)
			case "spID":
				return ec.fieldContext_IPNIPeerID_spID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNIPeerID", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_providerPeerID(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_providerPeerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderPeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_providerPeerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_entries(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_addresses(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_addresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Addresses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_addresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_isSkip(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_isSkip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSkip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_isSkip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_isRm(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_isRm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_isRm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIAdvertisement_signature(ctx context.Context, field graphql.CollectedField, obj *model.IPNIAdvertisement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIAdvertisement_signature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIAdvertisement_signature(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIAdvertisement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIHead_head(ctx context.Context, field graphql.CollectedField, obj *model.IPNIHead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIHead_head(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Head, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIHead_head(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIHead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIHead_provider(ctx context.Context, field graphql.CollectedField, obj *model.IPNIHead) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIHead_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIHead_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIHead",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIPeerID_peerID(ctx context.Context, field graphql.CollectedField, obj *model.IPNIPeerID) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIPeerID_peerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIPeerID_peerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIPeerID",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIPeerID_spID(ctx context.Context, field graphql.CollectedField, obj *model.IPNIPeerID) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIPeerID_spID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.ActorID)
	fc.Result = res
	return ec.marshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIPeerID_spID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIPeerID",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActorID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIProvider_spID(ctx context.Context, field graphql.CollectedField, obj *model.IPNIProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIProvider_spID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.ActorID)
	fc.Result = res
	return ec.marshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIProvider_spID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActorID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIProvider_peerID(ctx context.Context, field graphql.CollectedField, obj *model.IPNIProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIProvider_peerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIProvider_peerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIProvider_head(ctx context.Context, field graphql.CollectedField, obj *model.IPNIProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIProvider_head(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIProvider().Head(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIProvider_head(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIProvider_adCount(ctx context.Context, field graphql.CollectedField, obj *model.IPNIProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIProvider_adCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIProvider().AdCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIProvider_adCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIProvider_status(ctx context.Context, field graphql.CollectedField, obj *model.IPNIProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIProvider_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIProvider().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.IPNIProviderStatus)
	fc.Result = res
	return ec.marshalNIPNIProviderStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProviderStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIProvider_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type IPNIProviderStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_totalAdvertisements(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_totalAdvertisements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().TotalAdvertisements(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_totalAdvertisements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_previousTotalAdvertisements(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_previousTotalAdvertisements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PreviousTotalAdvertisements(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_previousTotalAdvertisements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_providers(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_providers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().Providers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_providers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_previousProviders(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_previousProviders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PreviousProviders(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_previousProviders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_indexed(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_indexed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().Indexed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_indexed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_previousIndexed(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_previousIndexed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PreviousIndexed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_previousIndexed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_skipped(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_skipped(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().Skipped(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_skipped(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_previousSkipped(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_previousSkipped(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PreviousSkipped(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_previousSkipped(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_pendingTasks(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_pendingTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PendingTasks(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_pendingTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNIStats_previousPendingTasks(ctx context.Context, field graphql.CollectedField, obj *model.IPNIStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNIStats_previousPendingTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IPNIStats().PreviousPendingTasks(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNIStats_previousPendingTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNIStats",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_taskId(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_contextId(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_contextId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContextID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_contextId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_complete(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_complete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Complete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_complete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_isRm(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_isRm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_isRm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_sector(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_sector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sector, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_sector(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_sectorOffset(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_sectorOffset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_sectorOffset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_spId(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.ActorID)
	fc.Result = res
	return ec.marshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActorID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_provider(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_regSealProof(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_regSealProof(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegSealProof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_regSealProof(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IPNITask_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.IPNITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IPNITask_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IPNITask_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IPNITask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_id(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_lastContact(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_lastContact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastContact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_lastContact(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_hostAndPort(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_hostAndPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAndPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_hostAndPort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_cpu(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_ram(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_ram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RAM, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_ram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_gpu(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_gpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gpu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_gpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_detail(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_detail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Machine().Detail(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MachineDetail)
	fc.Result = res
	return ec.marshalOMachineDetail2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_detail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MachineDetail_id(ctx, field)
			case "machineName":
				return ec.fieldContext_MachineDetail_machineName(ctx, field)
			case "tasks":
				return ec.fieldContext_MachineDetail_tasks(ctx, field)
			case "tasksArray":
				return ec.fieldContext_MachineDetail_tasksArray(ctx, field)
			case "layers":
				return ec.fieldContext_MachineDetail_layers(ctx, field)
			case "layersArray":
				return ec.fieldContext_MachineDetail_layersArray(ctx, field)
			case "startupTime":
				return ec.fieldContext_MachineDetail_startupTime(ctx, field)
			case "miners":
				return ec.fieldContext_MachineDetail_miners(ctx, field)
			case "minersArray":
				return ec.fieldContext_MachineDetail_minersArray(ctx, field)
			case "machineId":
				return ec.fieldContext_MachineDetail_machineId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MachineDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Machine().Tasks(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_taskHistories(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_taskHistories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Machine().TaskHistories(rctx, obj, fc.Args["last"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TaskHistory)
	fc.Result = res
	return ec.marshalOTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_taskHistories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Machine_taskHistories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Machine_storages(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_storages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Machine().Storages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.StoragePath)
	fc.Result = res
	return ec.marshalOStoragePath2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStoragePath(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_storages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StoragePath_id(ctx, field)
			case "storageId":
				return ec.fieldContext_StoragePath_storageId(ctx, field)
			case "type":
				return ec.fieldContext_StoragePath_type(ctx, field)
			case "urls":
				return ec.fieldContext_StoragePath_urls(ctx, field)
			case "weight":
				return ec.fieldContext_StoragePath_weight(ctx, field)
			case "maxStorage":
				return ec.fieldContext_StoragePath_maxStorage(ctx, field)
			case "canSeal":
				return ec.fieldContext_StoragePath_canSeal(ctx, field)
			case "canStore":
				return ec.fieldContext_StoragePath_canStore(ctx, field)
			case "groups":
				return ec.fieldContext_StoragePath_groups(ctx, field)
			case "allowTo":
				return ec.fieldContext_StoragePath_allowTo(ctx, field)
			case "allowTypes":
				return ec.fieldContext_StoragePath_allowTypes(ctx, field)
			case "denyTypes":
				return ec.fieldContext_StoragePath_denyTypes(ctx, field)
			case "capacity":
				return ec.fieldContext_StoragePath_capacity(ctx, field)
			case "available":
				return ec.fieldContext_StoragePath_available(ctx, field)
			case "fsAvailable":
				return ec.fieldContext_StoragePath_fsAvailable(ctx, field)
			case "reserved":
				return ec.fieldContext_StoragePath_reserved(ctx, field)
			case "used":
				return ec.fieldContext_StoragePath_used(ctx, field)
			case "lastHeartbeat":
				return ec.fieldContext_StoragePath_lastHeartbeat(ctx, field)
			case "heartbeatErr":
				return ec.fieldContext_StoragePath_heartbeatErr(ctx, field)
			case "allowMiners":
				return ec.fieldContext_StoragePath_allowMiners(ctx, field)
			case "denyMiners":
				return ec.fieldContext_StoragePath_denyMiners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StoragePath", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Machine_metrics(ctx context.Context, field graphql.CollectedField, obj *model.Machine) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Machine_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Machine().Metrics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MachineMetrics)
	fc.Result = res
	return ec.marshalOMachineMetrics2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Machine_metrics(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Machine",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cpuUsage":
				return ec.fieldContext_MachineMetrics_cpuUsage(ctx, field)
			case "gpuUsage":
				return ec.fieldContext_MachineMetrics_gpuUsage(ctx, field)
			case "ramUsage":
				return ec.fieldContext_MachineMetrics_ramUsage(ctx, field)
			case "activeTasks":
				return ec.fieldContext_MachineMetrics_activeTasks(ctx, field)
			case "addedTasks":
				return ec.fieldContext_MachineMetrics_addedTasks(ctx, field)
			case "tasksCompleted":
				return ec.fieldContext_MachineMetrics_tasksCompleted(ctx, field)
			case "tasksStarted":
				return ec.fieldContext_MachineMetrics_tasksStarted(ctx, field)
			case "goRoutines":
				return ec.fieldContext_MachineMetrics_goRoutines(ctx, field)
			case "goVersion":
				return ec.fieldContext_MachineMetrics_goVersion(ctx, field)
			case "goThreads":
				return ec.fieldContext_MachineMetrics_goThreads(ctx, field)
			case "processCpuSecondsTotal":
				return ec.fieldContext_MachineMetrics_processCpuSecondsTotal(ctx, field)
			case "processStartTimeSeconds":
				return ec.fieldContext_MachineMetrics_processStartTimeSeconds(ctx, field)
			case "processVirtualMemoryBytes":
				return ec.fieldContext_MachineMetrics_processVirtualMemoryBytes(ctx, field)
			case "processResidentMemoryBytes":
				return ec.fieldContext_MachineMetrics_processResidentMemoryBytes(ctx, field)
			case "processOpenFds":
				return ec.fieldContext_MachineMetrics_processOpenFds(ctx, field)
			case "processMaxFds":
				return ec.fieldContext_MachineMetrics_processMaxFds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MachineMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_id(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_machineName(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_machineName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MachineName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_machineName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_tasks(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_tasksArray(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_tasksArray(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineDetail().TasksArray(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_tasksArray(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_layers(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_layers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_layers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_layersArray(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_layersArray(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineDetail().LayersArray(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_layersArray(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_startupTime(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_startupTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartupTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullTime)
	fc.Result = res
	return ec.marshalNNullTime2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_startupTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_miners(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_miners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Miners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_miners(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_minersArray(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_minersArray(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineDetail().MinersArray(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_minersArray(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineDetail_machineId(ctx context.Context, field graphql.CollectedField, obj *model.MachineDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineDetail_machineId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MachineID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineDetail_machineId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_cpuUsage(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_cpuUsage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPUUsage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_cpuUsage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_gpuUsage(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_gpuUsage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GpuUsage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_gpuUsage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_ramUsage(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_ramUsage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RAMUsage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_ramUsage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_activeTasks(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_activeTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GaugeCountValue)
	fc.Result = res
	return ec.marshalNGaugeCountValue2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_activeTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GaugeCountValue_key(ctx, field)
			case "value":
				return ec.fieldContext_GaugeCountValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GaugeCountValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_addedTasks(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_addedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GaugeCountValue)
	fc.Result = res
	return ec.marshalNGaugeCountValue2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_addedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GaugeCountValue_key(ctx, field)
			case "value":
				return ec.fieldContext_GaugeCountValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GaugeCountValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_tasksCompleted(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_tasksCompleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TasksCompleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GaugeCountValue)
	fc.Result = res
	return ec.marshalNGaugeCountValue2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_tasksCompleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GaugeCountValue_key(ctx, field)
			case "value":
				return ec.fieldContext_GaugeCountValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GaugeCountValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_tasksStarted(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_tasksStarted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TasksStarted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GaugeCountValue)
	fc.Result = res
	return ec.marshalNGaugeCountValue2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_tasksStarted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GaugeCountValue_key(ctx, field)
			case "value":
				return ec.fieldContext_GaugeCountValue_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GaugeCountValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_goRoutines(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_goRoutines(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoRoutines, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_goRoutines(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_goVersion(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_goVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_goVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_goThreads(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_goThreads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoThreads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_goThreads(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processCpuSecondsTotal(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processCpuSecondsTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessCPUSecondsTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processCpuSecondsTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processStartTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processStartTimeSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessStartTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processStartTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processVirtualMemoryBytes(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processVirtualMemoryBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessVirtualMemoryBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processVirtualMemoryBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processResidentMemoryBytes(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processResidentMemoryBytes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessResidentMemoryBytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processResidentMemoryBytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processOpenFds(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processOpenFds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessOpenFds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processOpenFds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineMetrics_processMaxFds(ctx context.Context, field graphql.CollectedField, obj *model.MachineMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineMetrics_processMaxFds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessMaxFds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineMetrics_processMaxFds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_total(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().Total(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_totalUp(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_totalUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().TotalUp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_totalUp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_totalDown(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_totalDown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().TotalDown(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_totalDown(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_uniqueHostsTotal(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_uniqueHostsTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().UniqueHostsTotal(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_uniqueHostsTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_uniqueHostsUp(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_uniqueHostsUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().UniqueHostsUp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_uniqueHostsUp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_uniqueHostsDown(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_uniqueHostsDown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().UniqueHostsDown(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_uniqueHostsDown(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_totalRam(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_totalRam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().TotalRAM(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_totalRam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_totalCpu(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_totalCpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().TotalCPU(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_totalCpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_totalGpu(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_totalGpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().TotalGpu(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_totalGpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MachineSummary_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.MachineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MachineSummary_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MachineSummary().UpdatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MachineSummary_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MachineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketAllowFilter_wallet(ctx context.Context, field graphql.CollectedField, obj *model.MarketAllowFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketAllowFilter_wallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketAllowFilter_wallet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketAllowFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketAllowFilter_status(ctx context.Context, field graphql.CollectedField, obj *model.MarketAllowFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketAllowFilter_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketAllowFilter_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketAllowFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketBalance_miner(ctx context.Context, field graphql.CollectedField, obj *model.MarketBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketBalance_miner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Miner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketBalance_miner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketBalance_balance(ctx context.Context, field graphql.CollectedField, obj *model.MarketBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketBalance_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.FIL)
	fc.Result = res
	return ec.marshalNFIL2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐFIL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketBalance_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FIL does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketBalance_balances(ctx context.Context, field graphql.CollectedField, obj *model.MarketBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketBalance_balances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.WalletBalance)
	fc.Result = res
	return ec.marshalOWalletBalance2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWalletBalanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketBalance_balances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_WalletBalance_address(ctx, field)
			case "balance":
				return ec.fieldContext_WalletBalance_balance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletBalance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_uuid(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_uuid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_spId(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.ActorID)
	fc.Result = res
	return ec.marshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ActorID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_signedProposalCid(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_signedProposalCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedProposalCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_signedProposalCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_proposalSignature(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_proposalSignature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProposalSignature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_proposalSignature(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_proposal(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_proposal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proposal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.JSON)
	fc.Result = res
	return ec.marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_proposal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_offline(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_offline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Offline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_offline(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_verified(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_verified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_verified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_startEpoch(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_startEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_startEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_endEpoch(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_endEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_endEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_clientPeerId(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_clientPeerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientPeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_clientPeerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_chainDealId(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_chainDealId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChainDealID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_chainDealId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_publishCid(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_publishCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_publishCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_pieceCid(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_pieceCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_pieceCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_pieceSize(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_pieceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_pieceSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_fastRetrieval(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_fastRetrieval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FastRetrieval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_fastRetrieval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_announceToIpni(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_announceToIpni(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnounceToIpni, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_announceToIpni(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_url(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_urlHeaders(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_urlHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.JSON)
	fc.Result = res
	return ec.marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_urlHeaders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_error(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_label(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12Deal_proposalCid(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12Deal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12Deal_proposalCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProposalCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12Deal_proposalCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12Deal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_spId(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_price(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_price(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_verifiedPrice(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_verifiedPrice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VerifiedPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_verifiedPrice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_minSize(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_minSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_minSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_maxSize(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_maxSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_maxSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_expiry(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_expiry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_expiry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarketMk12StorageAsk_sequence(ctx context.Context, field graphql.CollectedField, obj *model.MarketMk12StorageAsk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MarketMk12StorageAsk_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MarketMk12StorageAsk_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarketMk12StorageAsk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_fromKey(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_fromKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_fromKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_toAddr(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_toAddr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_toAddr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_sendReason(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_sendReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SendReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_sendReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_sendTaskId(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_sendTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SendTaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_sendTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_unsignedData(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_unsignedData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsignedData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_unsignedData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_unsignedCid(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_unsignedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsignedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_unsignedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_nonce(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_nonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_nonce(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_signedData(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_signedData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_signedData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_signedJson(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_signedJson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedJSON, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_signedJson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_signedCid(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_signedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_signedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_sendTime(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_sendTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SendTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_sendTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_sendSuccess(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_sendSuccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SendSuccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_sendSuccess(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageSend_sendError(ctx context.Context, field graphql.CollectedField, obj *model.MessageSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageSend_sendError(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SendError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageSend_sendError(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_signedMessageCid(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_signedMessageCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignedMessageCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_signedMessageCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_waiterMachineId(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_waiterMachineId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaiterMachineID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_waiterMachineId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_waiterMachine(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_waiterMachine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MessageWait().WaiterMachine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_waiterMachine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedTskCid(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedTskCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedTskCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedTskCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedTskEpoch(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedTskEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedTskEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt642ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedTskEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedMsgCid(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedMsgCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedMsgCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedMsgCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedMsgData(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedMsgData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedMsgData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedMsgData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedRcptExitcode(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedRcptExitcode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedRcptExitcode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt642ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedRcptExitcode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedRcptReturn(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedRcptReturn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedRcptReturn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedRcptReturn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_executedRcptGasUsed(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_executedRcptGasUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedRcptGasUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt642ᚖint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_executedRcptGasUsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MessageWait_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.MessageWait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MessageWait_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MessageWait_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MessageWait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Metadata_networkName(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Metadata_networkName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Metadata().NetworkName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Metadata_networkName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Metadata",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Metadata_genesisTimestamp(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Metadata_genesisTimestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Metadata().GenesisTimestamp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Metadata_genesisTimestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Metadata",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Miner_id(ctx context.Context, field graphql.CollectedField, obj *model.Miner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Miner_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Miner_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Miner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Miner_info(ctx context.Context, field graphql.CollectedField, obj *model.Miner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Miner_info(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Miner().Info(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerInfo)
	fc.Result = res
	return ec.marshalOMinerInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Miner_info(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Miner",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_MinerInfo_owner(ctx, field)
			case "worker":
				return ec.fieldContext_MinerInfo_worker(ctx, field)
			case "newWorker":
				return ec.fieldContext_MinerInfo_newWorker(ctx, field)
			case "controlAddresses":
				return ec.fieldContext_MinerInfo_controlAddresses(ctx, field)
			case "workerChangeEpoch":
				return ec.fieldContext_MinerInfo_workerChangeEpoch(ctx, field)
			case "peerId":
				return ec.fieldContext_MinerInfo_peerId(ctx, field)
			case "multiAddrs":
				return ec.fieldContext_MinerInfo_multiAddrs(ctx, field)
			case "windowPoStProofType":
				return ec.fieldContext_MinerInfo_windowPoStProofType(ctx, field)
			case "sectorSize":
				return ec.fieldContext_MinerInfo_sectorSize(ctx, field)
			case "windowPoStPartitionSectors":
				return ec.fieldContext_MinerInfo_windowPoStPartitionSectors(ctx, field)
			case "consensusFaultElapsed":
				return ec.fieldContext_MinerInfo_consensusFaultElapsed(ctx, field)
			case "pendingOwnerAddress":
				return ec.fieldContext_MinerInfo_pendingOwnerAddress(ctx, field)
			case "beneficiary":
				return ec.fieldContext_MinerInfo_beneficiary(ctx, field)
			case "beneficiaryTerm":
				return ec.fieldContext_MinerInfo_beneficiaryTerm(ctx, field)
			case "pendingBeneficiaryChange":
				return ec.fieldContext_MinerInfo_pendingBeneficiaryChange(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Miner_power(ctx context.Context, field graphql.CollectedField, obj *model.Miner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Miner_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Miner().Power(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerPower)
	fc.Result = res
	return ec.marshalOMinerPower2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerPower(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Miner_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Miner",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MinerPower_id(ctx, field)
			case "minerPower":
				return ec.fieldContext_MinerPower_minerPower(ctx, field)
			case "totalPower":
				return ec.fieldContext_MinerPower_totalPower(ctx, field)
			case "hasMinPower":
				return ec.fieldContext_MinerPower_hasMinPower(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerPower", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Miner_balance(ctx context.Context, field graphql.CollectedField, obj *model.Miner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Miner_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Miner().Balance(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerBalance)
	fc.Result = res
	return ec.marshalOMinerBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerBalance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Miner_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Miner",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MinerBalance_id(ctx, field)
			case "balance":
				return ec.fieldContext_MinerBalance_balance(ctx, field)
			case "available":
				return ec.fieldContext_MinerBalance_available(ctx, field)
			case "initialPledge":
				return ec.fieldContext_MinerBalance_initialPledge(ctx, field)
			case "vesting":
				return ec.fieldContext_MinerBalance_vesting(ctx, field)
			case "preCommitDeposits":
				return ec.fieldContext_MinerBalance_preCommitDeposits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerBalance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_id(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_balance(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MinerBalance().Balance(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_available(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MinerBalance().Available(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_initialPledge(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_initialPledge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MinerBalance().InitialPledge(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_initialPledge(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_vesting(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_vesting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MinerBalance().Vesting(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_vesting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBalance_preCommitDeposits(ctx context.Context, field graphql.CollectedField, obj *model.MinerBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBalance_preCommitDeposits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MinerBalance().PreCommitDeposits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBalance_preCommitDeposits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBalance",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBeneficiaryTerm_quota(ctx context.Context, field graphql.CollectedField, obj *model.MinerBeneficiaryTerm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBeneficiaryTerm_quota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBeneficiaryTerm_quota(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBeneficiaryTerm",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBeneficiaryTerm_usedQuota(ctx context.Context, field graphql.CollectedField, obj *model.MinerBeneficiaryTerm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBeneficiaryTerm_usedQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBeneficiaryTerm_usedQuota(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBeneficiaryTerm",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerBeneficiaryTerm_expiration(ctx context.Context, field graphql.CollectedField, obj *model.MinerBeneficiaryTerm) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerBeneficiaryTerm_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerBeneficiaryTerm_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerBeneficiaryTerm",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_owner(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_worker(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_worker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_worker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_newWorker(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_newWorker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewWorker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_newWorker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_controlAddresses(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_controlAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ControlAddresses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*types.Address)
	fc.Result = res
	return ec.marshalOAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_controlAddresses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_workerChangeEpoch(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_workerChangeEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkerChangeEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_workerChangeEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_peerId(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_peerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_peerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_multiAddrs(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_multiAddrs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MultiAddrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_multiAddrs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_windowPoStProofType(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_windowPoStProofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WindowPoStProofType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_windowPoStProofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_sectorSize(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_sectorSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_sectorSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_windowPoStPartitionSectors(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_windowPoStPartitionSectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WindowPoStPartitionSectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_windowPoStPartitionSectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_consensusFaultElapsed(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_consensusFaultElapsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConsensusFaultElapsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_consensusFaultElapsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_pendingOwnerAddress(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_pendingOwnerAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingOwnerAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_pendingOwnerAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_beneficiary(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_beneficiary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beneficiary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_beneficiary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_beneficiaryTerm(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_beneficiaryTerm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BeneficiaryTerm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerBeneficiaryTerm)
	fc.Result = res
	return ec.marshalOMinerBeneficiaryTerm2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerBeneficiaryTerm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_beneficiaryTerm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "quota":
				return ec.fieldContext_MinerBeneficiaryTerm_quota(ctx, field)
			case "usedQuota":
				return ec.fieldContext_MinerBeneficiaryTerm_usedQuota(ctx, field)
			case "expiration":
				return ec.fieldContext_MinerBeneficiaryTerm_expiration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerBeneficiaryTerm", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerInfo_pendingBeneficiaryChange(ctx context.Context, field graphql.CollectedField, obj *model.MinerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerInfo_pendingBeneficiaryChange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingBeneficiaryChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerPendingBeneficiaryChange)
	fc.Result = res
	return ec.marshalOMinerPendingBeneficiaryChange2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerPendingBeneficiaryChange(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerInfo_pendingBeneficiaryChange(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newBeneficiary":
				return ec.fieldContext_MinerPendingBeneficiaryChange_newBeneficiary(ctx, field)
			case "newQuota":
				return ec.fieldContext_MinerPendingBeneficiaryChange_newQuota(ctx, field)
			case "newExpiration":
				return ec.fieldContext_MinerPendingBeneficiaryChange_newExpiration(ctx, field)
			case "approvedByBeneficiary":
				return ec.fieldContext_MinerPendingBeneficiaryChange_approvedByBeneficiary(ctx, field)
			case "approvedByNominee":
				return ec.fieldContext_MinerPendingBeneficiaryChange_approvedByNominee(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerPendingBeneficiaryChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPendingBeneficiaryChange_newBeneficiary(ctx context.Context, field graphql.CollectedField, obj *model.MinerPendingBeneficiaryChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPendingBeneficiaryChange_newBeneficiary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewBeneficiary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPendingBeneficiaryChange_newBeneficiary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPendingBeneficiaryChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPendingBeneficiaryChange_newQuota(ctx context.Context, field graphql.CollectedField, obj *model.MinerPendingBeneficiaryChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPendingBeneficiaryChange_newQuota(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewQuota, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPendingBeneficiaryChange_newQuota(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPendingBeneficiaryChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPendingBeneficiaryChange_newExpiration(ctx context.Context, field graphql.CollectedField, obj *model.MinerPendingBeneficiaryChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPendingBeneficiaryChange_newExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPendingBeneficiaryChange_newExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPendingBeneficiaryChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPendingBeneficiaryChange_approvedByBeneficiary(ctx context.Context, field graphql.CollectedField, obj *model.MinerPendingBeneficiaryChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPendingBeneficiaryChange_approvedByBeneficiary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedByBeneficiary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPendingBeneficiaryChange_approvedByBeneficiary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPendingBeneficiaryChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPendingBeneficiaryChange_approvedByNominee(ctx context.Context, field graphql.CollectedField, obj *model.MinerPendingBeneficiaryChange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPendingBeneficiaryChange_approvedByNominee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedByNominee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPendingBeneficiaryChange_approvedByNominee(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPendingBeneficiaryChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPower_id(ctx context.Context, field graphql.CollectedField, obj *model.MinerPower) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPower_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPower_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPower",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPower_minerPower(ctx context.Context, field graphql.CollectedField, obj *model.MinerPower) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPower_minerPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinerPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PowerClaim)
	fc.Result = res
	return ec.marshalNPowerClaim2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPowerClaim(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPower_minerPower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPower",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rawBytePower":
				return ec.fieldContext_PowerClaim_rawBytePower(ctx, field)
			case "qualityAdjPower":
				return ec.fieldContext_PowerClaim_qualityAdjPower(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PowerClaim", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPower_totalPower(ctx context.Context, field graphql.CollectedField, obj *model.MinerPower) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPower_totalPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PowerClaim)
	fc.Result = res
	return ec.marshalNPowerClaim2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPowerClaim(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPower_totalPower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPower",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rawBytePower":
				return ec.fieldContext_PowerClaim_rawBytePower(ctx, field)
			case "qualityAdjPower":
				return ec.fieldContext_PowerClaim_qualityAdjPower(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PowerClaim", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MinerPower_hasMinPower(ctx context.Context, field graphql.CollectedField, obj *model.MinerPower) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MinerPower_hasMinPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasMinPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MinerPower_hasMinPower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MinerPower",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCount_include(ctx context.Context, field graphql.CollectedField, obj *model.MiningCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCount_include(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Include, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCount_include(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCount_exclude(ctx context.Context, field graphql.CollectedField, obj *model.MiningCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCount_exclude(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exclude, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCount_exclude(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountAggregated_time(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountAggregated) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountAggregated_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountAggregated_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountAggregated",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountAggregated_total(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountAggregated) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountAggregated_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountAggregated_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountAggregated",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountAggregated_won(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountAggregated) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountAggregated_won(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Won, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountAggregated_won(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountAggregated",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountAggregated_included(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountAggregated) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountAggregated_included(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Included, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountAggregated_included(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountAggregated",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_start(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_end(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_end(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_total(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_won(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_won(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Won, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_won(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_included(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_included(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Included, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_included(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_actor(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.Address)
	fc.Result = res
	return ec.marshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_actor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningCountSummary_previous(ctx context.Context, field graphql.CollectedField, obj *model.MiningCountSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningCountSummary_previous(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MiningCountSummary().Previous(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MiningCountSummary)
	fc.Result = res
	return ec.marshalOMiningCountSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningCountSummary_previous(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningCountSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_MiningCountSummary_start(ctx, field)
			case "end":
				return ec.fieldContext_MiningCountSummary_end(ctx, field)
			case "total":
				return ec.fieldContext_MiningCountSummary_total(ctx, field)
			case "won":
				return ec.fieldContext_MiningCountSummary_won(ctx, field)
			case "included":
				return ec.fieldContext_MiningCountSummary_included(ctx, field)
			case "actor":
				return ec.fieldContext_MiningCountSummary_actor(ctx, field)
			case "previous":
				return ec.fieldContext_MiningCountSummary_previous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningCountSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningStatusSummay_total(ctx context.Context, field graphql.CollectedField, obj *model.MiningStatusSummay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningStatusSummay_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningStatusSummay_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningStatusSummay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningStatusSummay_won(ctx context.Context, field graphql.CollectedField, obj *model.MiningStatusSummay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningStatusSummay_won(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Won, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningStatusSummay_won(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningStatusSummay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningStatusSummay_included(ctx context.Context, field graphql.CollectedField, obj *model.MiningStatusSummay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningStatusSummay_included(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Included, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningStatusSummay_included(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningStatusSummay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningStatusSummay_wonChangeRate(ctx context.Context, field graphql.CollectedField, obj *model.MiningStatusSummay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningStatusSummay_wonChangeRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WonChangeRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningStatusSummay_wonChangeRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningStatusSummay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningStatusSummay_lastMinedAt(ctx context.Context, field graphql.CollectedField, obj *model.MiningStatusSummay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningStatusSummay_lastMinedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastMinedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningStatusSummay_lastMinedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningStatusSummay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningSummaryDay_day(ctx context.Context, field graphql.CollectedField, obj *model.MiningSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningSummaryDay_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningSummaryDay_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningSummaryDay_miner(ctx context.Context, field graphql.CollectedField, obj *model.MiningSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningSummaryDay_miner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Miner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningSummaryDay_miner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningSummaryDay_wonBlock(ctx context.Context, field graphql.CollectedField, obj *model.MiningSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningSummaryDay_wonBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WonBlock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningSummaryDay_wonBlock(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_taskId(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_spId(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_epoch(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_epoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Epoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_epoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_baseComputeTime(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_baseComputeTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseComputeTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_baseComputeTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_won(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_won(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Won, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_won(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_minedCid(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_minedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_minedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_minedHeader(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_minedHeader(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinedHeader, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_minedHeader(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_minedAt(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_minedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_minedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_submittedAt(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_submittedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmittedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_submittedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MiningTask_included(ctx context.Context, field graphql.CollectedField, obj *model.MiningTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MiningTask_included(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Included, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MiningTask_included(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MiningTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateConfig(rctx, fc.Args["title"].(string), fc.Args["config"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.Config
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Config
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Config); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Config`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Config)
	fc.Result = res
	return ec.marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Config_id(ctx, field)
			case "title":
				return ec.fieldContext_Config_title(ctx, field)
			case "config":
				return ec.fieldContext_Config_config(ctx, field)
			case "usedBy":
				return ec.fieldContext_Config_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Config", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateConfig(rctx, fc.Args["title"].(string), fc.Args["config"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.Config
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Config
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Config); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Config`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Config)
	fc.Result = res
	return ec.marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Config_id(ctx, field)
			case "title":
				return ec.fieldContext_Config_title(ctx, field)
			case "config":
				return ec.fieldContext_Config_config(ctx, field)
			case "usedBy":
				return ec.fieldContext_Config_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Config", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveConfig(rctx, fc.Args["title"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.Config
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Config
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Config); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Config`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Config)
	fc.Result = res
	return ec.marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Config_id(ctx, field)
			case "title":
				return ec.fieldContext_Config_title(ctx, field)
			case "config":
				return ec.fieldContext_Config_config(ctx, field)
			case "usedBy":
				return ec.fieldContext_Config_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Config", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeConfig_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_dealSealNow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_dealSealNow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DealSealNow(rctx, fc.Args["miner"].(types.Address), fc.Args["sectorNumber"].(uint64))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_dealSealNow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_dealSealNow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketAddBalance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketAddBalance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketAddBalance(rctx, fc.Args["miner"].(types.Address), fc.Args["wallet"].(types.Address), fc.Args["amount"].(types.FIL))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "ADMIN")
			if err != nil {
				var zeroVal *model.MarketBalance
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketBalance
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketBalance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketBalance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketBalance)
	fc.Result = res
	return ec.marshalOMarketBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketAddBalance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "miner":
				return ec.fieldContext_MarketBalance_miner(ctx, field)
			case "balance":
				return ec.fieldContext_MarketBalance_balance(ctx, field)
			case "balances":
				return ec.fieldContext_MarketBalance_balances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketBalance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketAddBalance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMarketMk12StorageAsk(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMarketMk12StorageAsk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMarketMk12StorageAsk(rctx, fc.Args["input"].(model.MarketMk12StorageAskInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.MarketMk12StorageAsk
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketMk12StorageAsk
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketMk12StorageAsk); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketMk12StorageAsk`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketMk12StorageAsk)
	fc.Result = res
	return ec.marshalOMarketMk12StorageAsk2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMarketMk12StorageAsk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spId":
				return ec.fieldContext_MarketMk12StorageAsk_spId(ctx, field)
			case "price":
				return ec.fieldContext_MarketMk12StorageAsk_price(ctx, field)
			case "verifiedPrice":
				return ec.fieldContext_MarketMk12StorageAsk_verifiedPrice(ctx, field)
			case "minSize":
				return ec.fieldContext_MarketMk12StorageAsk_minSize(ctx, field)
			case "maxSize":
				return ec.fieldContext_MarketMk12StorageAsk_maxSize(ctx, field)
			case "createdAt":
				return ec.fieldContext_MarketMk12StorageAsk_createdAt(ctx, field)
			case "expiry":
				return ec.fieldContext_MarketMk12StorageAsk_expiry(ctx, field)
			case "sequence":
				return ec.fieldContext_MarketMk12StorageAsk_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketMk12StorageAsk", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMarketMk12StorageAsk_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketAddPriceFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketAddPriceFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketAddPriceFilter(rctx, fc.Args["input"].(model.PriceFilterInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketAddPriceFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketAddPriceFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketUpdatePriceFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketUpdatePriceFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketUpdatePriceFilter(rctx, fc.Args["input"].(model.PriceFilterInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.PriceFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.PriceFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PriceFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.PriceFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PriceFilter)
	fc.Result = res
	return ec.marshalOPriceFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketUpdatePriceFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PriceFilter_name(ctx, field)
			case "minDurationDays":
				return ec.fieldContext_PriceFilter_minDurationDays(ctx, field)
			case "maxDurationDays":
				return ec.fieldContext_PriceFilter_maxDurationDays(ctx, field)
			case "minimumSize":
				return ec.fieldContext_PriceFilter_minimumSize(ctx, field)
			case "maximumSize":
				return ec.fieldContext_PriceFilter_maximumSize(ctx, field)
			case "price":
				return ec.fieldContext_PriceFilter_price(ctx, field)
			case "verified":
				return ec.fieldContext_PriceFilter_verified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PriceFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketUpdatePriceFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketDeletePriceFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketDeletePriceFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketDeletePriceFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketDeletePriceFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketDeletePriceFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketAddClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketAddClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketAddClientFilter(rctx, fc.Args["input"].(model.ClientFilterInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketAddClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketAddClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketUpdateClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketUpdateClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketUpdateClientFilter(rctx, fc.Args["input"].(model.ClientFilterInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.ClientFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.ClientFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ClientFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.ClientFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ClientFilter)
	fc.Result = res
	return ec.marshalOClientFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketUpdateClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ClientFilter_name(ctx, field)
			case "active":
				return ec.fieldContext_ClientFilter_active(ctx, field)
			case "wallets":
				return ec.fieldContext_ClientFilter_wallets(ctx, field)
			case "peers":
				return ec.fieldContext_ClientFilter_peers(ctx, field)
			case "pricingFilters":
				return ec.fieldContext_ClientFilter_pricingFilters(ctx, field)
			case "maxDealsPerHour":
				return ec.fieldContext_ClientFilter_maxDealsPerHour(ctx, field)
			case "maxDealSizePerHour":
				return ec.fieldContext_ClientFilter_maxDealSizePerHour(ctx, field)
			case "info":
				return ec.fieldContext_ClientFilter_info(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketUpdateClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketDeleteClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketDeleteClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketDeleteClientFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketDeleteClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketDeleteClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketToggleClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketToggleClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketToggleClientFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketToggleClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketToggleClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketSetAllowFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketSetAllowFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketSetAllowFilter(rctx, fc.Args["wallet"].(types.Address), fc.Args["status"].(bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal *model.MarketAllowFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketAllowFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketAllowFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketAllowFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketAllowFilter)
	fc.Result = res
	return ec.marshalOMarketAllowFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketSetAllowFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "wallet":
				return ec.fieldContext_MarketAllowFilter_wallet(ctx, field)
			case "status":
				return ec.fieldContext_MarketAllowFilter_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketAllowFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketSetAllowFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketDeleteAllowFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketDeleteAllowFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketDeleteAllowFilter(rctx, fc.Args["wallet"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketDeleteAllowFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketDeleteAllowFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_marketToggleAllowFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_marketToggleAllowFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarketToggleAllowFilter(rctx, fc.Args["wallet"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_marketToggleAllowFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_marketToggleAllowFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeSector(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeSector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveSector(rctx, fc.Args["miner"].(types.Address), fc.Args["sectorNumber"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeSector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeSector_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartSector(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartSector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RestartSector(rctx, fc.Args["miner"].(types.Address), fc.Args["sectorNumber"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartSector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartSector_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartAllFailedSectors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartAllFailedSectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RestartAllFailedSectors(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "OPERATOR")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartAllFailedSectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeHealthSummary_onlineNodes(ctx context.Context, field graphql.CollectedField, obj *model.NodeHealthSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeHealthSummary_onlineNodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnlineNodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeHealthSummary_onlineNodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeHealthSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeHealthSummary_unscheduledNodes(ctx context.Context, field graphql.CollectedField, obj *model.NodeHealthSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeHealthSummary_unscheduledNodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnscheduledNodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeHealthSummary_unscheduledNodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeHealthSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeHealthSummary_offlineNodes(ctx context.Context, field graphql.CollectedField, obj *model.NodeHealthSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeHealthSummary_offlineNodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfflineNodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeHealthSummary_offlineNodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeHealthSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_address(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_layers(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_layers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_layers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_reachable(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_reachable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reachable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_reachable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_syncState(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_syncState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_syncState(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.NodeInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeInfo_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_spID(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_spID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_spID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_sectorNumber(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_sectorNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_sectorNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_pieceIndex(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_pieceIndex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_pieceIndex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_pieceCID(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_pieceCID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_pieceCID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_pieceSize(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_pieceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_pieceSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_dataURL(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_dataURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_dataURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_dataHeaders(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_dataHeaders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataHeaders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.JSON)
	fc.Result = res
	return ec.marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_dataHeaders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_dataRawSize(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_dataRawSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataRawSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_dataRawSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_dataDeleteOnFinalize(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_dataDeleteOnFinalize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataDeleteOnFinalize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_dataDeleteOnFinalize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_f05PublishCID(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_f05PublishCID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05PublishCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_f05PublishCID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_f05DealID(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_f05DealID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_f05DealID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_f05DealProposal(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_f05DealProposal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealProposal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_f05DealProposal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_f05DealStartEpoch(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_f05DealStartEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealStartEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_f05DealStartEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_f05DealEndEpoch(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_f05DealEndEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealEndEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_f05DealEndEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_directStartEpoch(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_directStartEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectStartEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_directStartEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_directEndEpoch(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_directEndEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectEndEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_directEndEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_directPieceActivationManifest(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_directPieceActivationManifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectPieceActivationManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_directPieceActivationManifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpenSectorPiece_isSnap(ctx context.Context, field graphql.CollectedField, obj *model.OpenSectorPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OpenSectorPiece_isSnap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSnap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OpenSectorPiece_isSnap(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpenSectorPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_id(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_sdr(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_sdr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().Sdr(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_sdr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_trees(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_trees(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().Trees(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_trees(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_precommitMsg(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_precommitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().PrecommitMsg(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_precommitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_waitSeed(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_waitSeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().WaitSeed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_waitSeed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_porep(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_porep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().Porep(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_porep(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_commitMsg(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_commitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().CommitMsg(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_commitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_done(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().Done(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_done(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PipelineSummary_failed(ctx context.Context, field graphql.CollectedField, obj *model.PipelineSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PipelineSummary_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PipelineSummary().Failed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PipelineSummary_failed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PipelineSummary",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_id(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Porep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_spId(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_sectorNumber(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_sectorNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_sectorNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_createTime(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_regSealProof(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_regSealProof(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegSealProof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_regSealProof(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_ticketEpoch(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_ticketEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_ticketEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_ticketValue(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_ticketValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_ticketValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdSdr(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdSdr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDSdr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdSdr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterSdr(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterSdr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterSdr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterSdr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_treeDCid(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_treeDCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TreeDCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_treeDCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdTreeD(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdTreeD(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDTreeD, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdTreeD(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterTreeD(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterTreeD(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterTreeD, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterTreeD(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdTreeC(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdTreeC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDTreeC, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdTreeC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterTreeC(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterTreeC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterTreeC, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterTreeC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_treeRCid(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_treeRCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TreeRCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_treeRCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdTreeR(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdTreeR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDTreeR, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdTreeR(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterTreeR(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterTreeR(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterTreeR, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterTreeR(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_precommitMsgCid(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_precommitMsgCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecommitMsgCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_precommitMsgCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdPrecommitMsg(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdPrecommitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDPrecommitMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdPrecommitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterPrecommitMsg(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterPrecommitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterPrecommitMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterPrecommitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_seedEpoch(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_seedEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeedEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_seedEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_precommitMsgTsk(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_precommitMsgTsk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecommitMsgTsk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_precommitMsgTsk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterPrecommitMsgSuccess(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterPrecommitMsgSuccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterPrecommitMsgSuccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterPrecommitMsgSuccess(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_seedValue(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_seedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_seedValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdPorep(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdPorep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDPorep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdPorep(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_porepProof(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_porepProof(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PorepProof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_porepProof(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterPorep(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterPorep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterPorep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterPorep(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdFinalize(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdFinalize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDFinalize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdFinalize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterFinalize(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterFinalize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterFinalize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterFinalize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdMoveStorage(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdMoveStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDMoveStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdMoveStorage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterMoveStorage(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterMoveStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterMoveStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterMoveStorage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_commitMsgCid(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_commitMsgCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitMsgCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_commitMsgCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdCommitMsg(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdCommitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDCommitMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdCommitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterCommitMsg(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterCommitMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterCommitMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterCommitMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_commitMsgTsk(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_commitMsgTsk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitMsgTsk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_commitMsgTsk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterCommitMsgSuccess(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterCommitMsgSuccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterCommitMsgSuccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterCommitMsgSuccess(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_failed(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_failed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_failedAt(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_failedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_failedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_failedReason(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_failedReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_failedReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_failedReasonMsg(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_failedReasonMsg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedReasonMsg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_failedReasonMsg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_taskIdSynth(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_taskIdSynth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskIDSynth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_taskIdSynth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_afterSynth(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_afterSynth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AfterSynth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_afterSynth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_userSectorDurationEpochs(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_userSectorDurationEpochs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSectorDurationEpochs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_userSectorDurationEpochs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_precommitReadyAt(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_precommitReadyAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrecommitReadyAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_precommitReadyAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_commitReadyAt(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_commitReadyAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitReadyAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_commitReadyAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_status(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Porep().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TaskStatus)
	fc.Result = res
	return ec.marshalNTaskStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_stage(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_stage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Porep().Stage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PorepStage)
	fc.Result = res
	return ec.marshalNPorepStage2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorepStage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_stage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PorepStage does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_currentTask(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_currentTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Porep().CurrentTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Task)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_currentTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Porep_compactStages(ctx context.Context, field graphql.CollectedField, obj *model.Porep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Porep_compactStages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Porep().CompactStages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskCompactStage)
	fc.Result = res
	return ec.marshalNTaskCompactStage2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskCompactStageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Porep_compactStages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Porep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_TaskCompactStage_name(ctx, field)
			case "status":
				return ec.fieldContext_TaskCompactStage_status(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskCompactStage_taskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskCompactStage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PowerClaim_rawBytePower(ctx context.Context, field graphql.CollectedField, obj *model.PowerClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PowerClaim_rawBytePower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawBytePower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalOBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PowerClaim_rawBytePower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PowerClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PowerClaim_qualityAdjPower(ctx context.Context, field graphql.CollectedField, obj *model.PowerClaim) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PowerClaim_qualityAdjPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QualityAdjPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.BigInt)
	fc.Result = res
	return ec.marshalOBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PowerClaim_qualityAdjPower(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PowerClaim",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_name(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_minDurationDays(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_minDurationDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDurationDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_minDurationDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_maxDurationDays(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_maxDurationDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDurationDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_maxDurationDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_minimumSize(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_minimumSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_minimumSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_maximumSize(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_maximumSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_maximumSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_price(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_price(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PriceFilter_verified(ctx context.Context, field graphql.CollectedField, obj *model.PriceFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PriceFilter_verified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Verified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PriceFilter_verified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PriceFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrometheusResponse_data(ctx context.Context, field graphql.CollectedField, obj *model.PrometheusResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrometheusResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.JSON)
	fc.Result = res
	return ec.marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrometheusResponse_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrometheusResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_actors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_actors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Actors(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Actor
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Actor
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Actor); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Actor`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Actor)
	fc.Result = res
	return ec.marshalOActor2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_actors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Actor_id(ctx, field)
			case "address":
				return ec.fieldContext_Actor_address(ctx, field)
			case "layers":
				return ec.fieldContext_Actor_layers(ctx, field)
			case "qualityAdjustedPower":
				return ec.fieldContext_Actor_qualityAdjustedPower(ctx, field)
			case "rawBytePower":
				return ec.fieldContext_Actor_rawBytePower(ctx, field)
			case "actorBalance":
				return ec.fieldContext_Actor_actorBalance(ctx, field)
			case "actorAvailableBalance":
				return ec.fieldContext_Actor_actorAvailableBalance(ctx, field)
			case "workerBalance":
				return ec.fieldContext_Actor_workerBalance(ctx, field)
			case "deadlines":
				return ec.fieldContext_Actor_deadlines(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Actor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_actor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Actor(rctx, fc.Args["address"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Actor
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Actor
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Actor); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Actor`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Actor)
	fc.Result = res
	return ec.marshalOActor2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_actor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Actor_id(ctx, field)
			case "address":
				return ec.fieldContext_Actor_address(ctx, field)
			case "layers":
				return ec.fieldContext_Actor_layers(ctx, field)
			case "qualityAdjustedPower":
				return ec.fieldContext_Actor_qualityAdjustedPower(ctx, field)
			case "rawBytePower":
				return ec.fieldContext_Actor_rawBytePower(ctx, field)
			case "actorBalance":
				return ec.fieldContext_Actor_actorBalance(ctx, field)
			case "actorAvailableBalance":
				return ec.fieldContext_Actor_actorAvailableBalance(ctx, field)
			case "workerBalance":
				return ec.fieldContext_Actor_workerBalance(ctx, field)
			case "deadlines":
				return ec.fieldContext_Actor_deadlines(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Actor", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_actor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_alerts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Alerts(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Alert
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Alert
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Alert); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Alert`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_alerts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "machineName":
				return ec.fieldContext_Alert_machineName(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_config(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Config(rctx, fc.Args["layer"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Config
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Config
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Config); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Config`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Config)
	fc.Result = res
	return ec.marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Config_id(ctx, field)
			case "title":
				return ec.fieldContext_Config_title(ctx, field)
			case "config":
				return ec.fieldContext_Config_config(ctx, field)
			case "usedBy":
				return ec.fieldContext_Config_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Config", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_config_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_configs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_configs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Configs(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Config
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Config
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Config); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Config`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Config)
	fc.Result = res
	return ec.marshalOConfig2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_configs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Config_id(ctx, field)
			case "title":
				return ec.fieldContext_Config_title(ctx, field)
			case "config":
				return ec.fieldContext_Config_config(ctx, field)
			case "usedBy":
				return ec.fieldContext_Config_usedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Config", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketMk12Deals(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketMk12Deals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketMk12Deals(rctx, fc.Args["filter"].(model.MarketMk12DealFilterInput), fc.Args["limit"].(int), fc.Args["offset"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MarketMk12Deal
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MarketMk12Deal
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MarketMk12Deal); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MarketMk12Deal`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MarketMk12Deal)
	fc.Result = res
	return ec.marshalNMarketMk12Deal2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12Dealᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketMk12Deals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "uuid":
				return ec.fieldContext_MarketMk12Deal_uuid(ctx, field)
			case "spId":
				return ec.fieldContext_MarketMk12Deal_spId(ctx, field)
			case "createdAt":
				return ec.fieldContext_MarketMk12Deal_createdAt(ctx, field)
			case "signedProposalCid":
				return ec.fieldContext_MarketMk12Deal_signedProposalCid(ctx, field)
			case "proposalSignature":
				return ec.fieldContext_MarketMk12Deal_proposalSignature(ctx, field)
			case "proposal":
				return ec.fieldContext_MarketMk12Deal_proposal(ctx, field)
			case "offline":
				return ec.fieldContext_MarketMk12Deal_offline(ctx, field)
			case "verified":
				return ec.fieldContext_MarketMk12Deal_verified(ctx, field)
			case "startEpoch":
				return ec.fieldContext_MarketMk12Deal_startEpoch(ctx, field)
			case "endEpoch":
				return ec.fieldContext_MarketMk12Deal_endEpoch(ctx, field)
			case "clientPeerId":
				return ec.fieldContext_MarketMk12Deal_clientPeerId(ctx, field)
			case "chainDealId":
				return ec.fieldContext_MarketMk12Deal_chainDealId(ctx, field)
			case "publishCid":
				return ec.fieldContext_MarketMk12Deal_publishCid(ctx, field)
			case "pieceCid":
				return ec.fieldContext_MarketMk12Deal_pieceCid(ctx, field)
			case "pieceSize":
				return ec.fieldContext_MarketMk12Deal_pieceSize(ctx, field)
			case "fastRetrieval":
				return ec.fieldContext_MarketMk12Deal_fastRetrieval(ctx, field)
			case "announceToIpni":
				return ec.fieldContext_MarketMk12Deal_announceToIpni(ctx, field)
			case "url":
				return ec.fieldContext_MarketMk12Deal_url(ctx, field)
			case "urlHeaders":
				return ec.fieldContext_MarketMk12Deal_urlHeaders(ctx, field)
			case "error":
				return ec.fieldContext_MarketMk12Deal_error(ctx, field)
			case "label":
				return ec.fieldContext_MarketMk12Deal_label(ctx, field)
			case "proposalCid":
				return ec.fieldContext_MarketMk12Deal_proposalCid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketMk12Deal", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketMk12Deals_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketMk12DealsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketMk12DealsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketMk12DealsCount(rctx, fc.Args["filter"].(model.MarketMk12DealFilterInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketMk12DealsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketMk12DealsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketDealInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketDealInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketDealInfo(rctx, fc.Args["id"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.DealInfo
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.DealInfo
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DealInfo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.DealInfo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DealInfo)
	fc.Result = res
	return ec.marshalODealInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDealInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketDealInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DealInfo_id(ctx, field)
			case "spId":
				return ec.fieldContext_DealInfo_spId(ctx, field)
			case "sector":
				return ec.fieldContext_DealInfo_sector(ctx, field)
			case "createdAt":
				return ec.fieldContext_DealInfo_createdAt(ctx, field)
			case "signedProposalCid":
				return ec.fieldContext_DealInfo_signedProposalCid(ctx, field)
			case "offline":
				return ec.fieldContext_DealInfo_offline(ctx, field)
			case "verified":
				return ec.fieldContext_DealInfo_verified(ctx, field)
			case "startEpoch":
				return ec.fieldContext_DealInfo_startEpoch(ctx, field)
			case "endEpoch":
				return ec.fieldContext_DealInfo_endEpoch(ctx, field)
			case "clientPeerId":
				return ec.fieldContext_DealInfo_clientPeerId(ctx, field)
			case "chainDealId":
				return ec.fieldContext_DealInfo_chainDealId(ctx, field)
			case "publishCid":
				return ec.fieldContext_DealInfo_publishCid(ctx, field)
			case "pieceCid":
				return ec.fieldContext_DealInfo_pieceCid(ctx, field)
			case "pieceSize":
				return ec.fieldContext_DealInfo_pieceSize(ctx, field)
			case "fastRetrieval":
				return ec.fieldContext_DealInfo_fastRetrieval(ctx, field)
			case "announceToIpni":
				return ec.fieldContext_DealInfo_announceToIpni(ctx, field)
			case "url":
				return ec.fieldContext_DealInfo_url(ctx, field)
			case "urls":
				return ec.fieldContext_DealInfo_urls(ctx, field)
			case "urlHeaders":
				return ec.fieldContext_DealInfo_urlHeaders(ctx, field)
			case "error":
				return ec.fieldContext_DealInfo_error(ctx, field)
			case "miner":
				return ec.fieldContext_DealInfo_miner(ctx, field)
			case "isLegacy":
				return ec.fieldContext_DealInfo_isLegacy(ctx, field)
			case "indexed":
				return ec.fieldContext_DealInfo_indexed(ctx, field)
			case "isDdo":
				return ec.fieldContext_DealInfo_isDdo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DealInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketDealInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketDealCountSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketDealCountSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketDealCountSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.DealCountSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.DealCountSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DealCountSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.DealCountSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DealCountSummary)
	fc.Result = res
	return ec.marshalODealCountSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDealCountSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketDealCountSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "boost":
				return ec.fieldContext_DealCountSummary_boost(ctx, field)
			case "direct":
				return ec.fieldContext_DealCountSummary_direct(ctx, field)
			case "legacy":
				return ec.fieldContext_DealCountSummary_legacy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DealCountSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_dealsPending(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dealsPending(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().DealsPending(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.OpenSectorPiece
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.OpenSectorPiece
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.OpenSectorPiece); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.OpenSectorPiece`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.OpenSectorPiece)
	fc.Result = res
	return ec.marshalOOpenSectorPiece2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐOpenSectorPiece(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dealsPending(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spID":
				return ec.fieldContext_OpenSectorPiece_spID(ctx, field)
			case "sectorNumber":
				return ec.fieldContext_OpenSectorPiece_sectorNumber(ctx, field)
			case "pieceIndex":
				return ec.fieldContext_OpenSectorPiece_pieceIndex(ctx, field)
			case "pieceCID":
				return ec.fieldContext_OpenSectorPiece_pieceCID(ctx, field)
			case "pieceSize":
				return ec.fieldContext_OpenSectorPiece_pieceSize(ctx, field)
			case "dataURL":
				return ec.fieldContext_OpenSectorPiece_dataURL(ctx, field)
			case "dataHeaders":
				return ec.fieldContext_OpenSectorPiece_dataHeaders(ctx, field)
			case "dataRawSize":
				return ec.fieldContext_OpenSectorPiece_dataRawSize(ctx, field)
			case "dataDeleteOnFinalize":
				return ec.fieldContext_OpenSectorPiece_dataDeleteOnFinalize(ctx, field)
			case "f05PublishCID":
				return ec.fieldContext_OpenSectorPiece_f05PublishCID(ctx, field)
			case "f05DealID":
				return ec.fieldContext_OpenSectorPiece_f05DealID(ctx, field)
			case "f05DealProposal":
				return ec.fieldContext_OpenSectorPiece_f05DealProposal(ctx, field)
			case "f05DealStartEpoch":
				return ec.fieldContext_OpenSectorPiece_f05DealStartEpoch(ctx, field)
			case "f05DealEndEpoch":
				return ec.fieldContext_OpenSectorPiece_f05DealEndEpoch(ctx, field)
			case "directStartEpoch":
				return ec.fieldContext_OpenSectorPiece_directStartEpoch(ctx, field)
			case "directEndEpoch":
				return ec.fieldContext_OpenSectorPiece_directEndEpoch(ctx, field)
			case "directPieceActivationManifest":
				return ec.fieldContext_OpenSectorPiece_directPieceActivationManifest(ctx, field)
			case "createdAt":
				return ec.fieldContext_OpenSectorPiece_createdAt(ctx, field)
			case "isSnap":
				return ec.fieldContext_OpenSectorPiece_isSnap(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpenSectorPiece", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniStats(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.IPNIStats
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.IPNIStats
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPNIStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.IPNIStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.IPNIStats)
	fc.Result = res
	return ec.marshalNIPNIStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniStats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalAdvertisements":
				return ec.fieldContext_IPNIStats_totalAdvertisements(ctx, field)
			case "previousTotalAdvertisements":
				return ec.fieldContext_IPNIStats_previousTotalAdvertisements(ctx, field)
			case "providers":
				return ec.fieldContext_IPNIStats_providers(ctx, field)
			case "previousProviders":
				return ec.fieldContext_IPNIStats_previousProviders(ctx, field)
			case "indexed":
				return ec.fieldContext_IPNIStats_indexed(ctx, field)
			case "previousIndexed":
				return ec.fieldContext_IPNIStats_previousIndexed(ctx, field)
			case "skipped":
				return ec.fieldContext_IPNIStats_skipped(ctx, field)
			case "previousSkipped":
				return ec.fieldContext_IPNIStats_previousSkipped(ctx, field)
			case "pendingTasks":
				return ec.fieldContext_IPNIStats_pendingTasks(ctx, field)
			case "previousPendingTasks":
				return ec.fieldContext_IPNIStats_previousPendingTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNIStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniAdvertisement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniAdvertisement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniAdvertisement(rctx, fc.Args["orderNumber"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.IPNIAdvertisement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.IPNIAdvertisement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPNIAdvertisement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.IPNIAdvertisement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPNIAdvertisement)
	fc.Result = res
	return ec.marshalOIPNIAdvertisement2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniAdvertisement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderNumber":
				return ec.fieldContext_IPNIAdvertisement_orderNumber(ctx, field)
			case "pieceCid":
				return ec.fieldContext_IPNIAdvertisement_pieceCid(ctx, field)
			case "adCid":
				return ec.fieldContext_IPNIAdvertisement_adCid(ctx, field)
			case "previous":
				return ec.fieldContext_IPNIAdvertisement_previous(ctx, field)
			case "contextId":
				return ec.fieldContext_IPNIAdvertisement_contextId(ctx, field)
			case "pieceSize":
				return ec.fieldContext_IPNIAdvertisement_pieceSize(ctx, field)
			case "provider":
				return ec.fieldContext_IPNIAdvertisement_provider(ctx, field)
			case "providerPeerID":
				return ec.fieldContext_IPNIAdvertisement_providerPeerID(ctx, field)
			case "entries":
				return ec.fieldContext_IPNIAdvertisement_entries(ctx, field)
			case "addresses":
				return ec.fieldContext_IPNIAdvertisement_addresses(ctx, field)
			case "isSkip":
				return ec.fieldContext_IPNIAdvertisement_isSkip(ctx, field)
			case "isRm":
				return ec.fieldContext_IPNIAdvertisement_isRm(ctx, field)
			case "signature":
				return ec.fieldContext_IPNIAdvertisement_signature(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNIAdvertisement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniAdvertisement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniAdvertisements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniAdvertisements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniAdvertisements(rctx, fc.Args["offset"].(int), fc.Args["limit"].(int), fc.Args["provider"].(*string), fc.Args["isSkip"].(*bool), fc.Args["isRemoved"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.IPNIAdvertisement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.IPNIAdvertisement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IPNIAdvertisement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.IPNIAdvertisement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPNIAdvertisement)
	fc.Result = res
	return ec.marshalNIPNIAdvertisement2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniAdvertisements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "orderNumber":
				return ec.fieldContext_IPNIAdvertisement_orderNumber(ctx, field)
			case "pieceCid":
				return ec.fieldContext_IPNIAdvertisement_pieceCid(ctx, field)
			case "adCid":
				return ec.fieldContext_IPNIAdvertisement_adCid(ctx, field)
			case "previous":
				return ec.fieldContext_IPNIAdvertisement_previous(ctx, field)
			case "contextId":
				return ec.fieldContext_IPNIAdvertisement_contextId(ctx, field)
			case "pieceSize":
				return ec.fieldContext_IPNIAdvertisement_pieceSize(ctx, field)
			case "provider":
				return ec.fieldContext_IPNIAdvertisement_provider(ctx, field)
			case "providerPeerID":
				return ec.fieldContext_IPNIAdvertisement_providerPeerID(ctx, field)
			case "entries":
				return ec.fieldContext_IPNIAdvertisement_entries(ctx, field)
			case "addresses":
				return ec.fieldContext_IPNIAdvertisement_addresses(ctx, field)
			case "isSkip":
				return ec.fieldContext_IPNIAdvertisement_isSkip(ctx, field)
			case "isRm":
				return ec.fieldContext_IPNIAdvertisement_isRm(ctx, field)
			case "signature":
				return ec.fieldContext_IPNIAdvertisement_signature(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNIAdvertisement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniAdvertisements_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniAdvertisementsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniAdvertisementsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniAdvertisementsCount(rctx, fc.Args["provider"].(*string), fc.Args["isSkip"].(*bool), fc.Args["isRemoved"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniAdvertisementsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniAdvertisementsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniTask(rctx, fc.Args["taskId"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.IPNITask
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.IPNITask
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.IPNITask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.IPNITask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IPNITask)
	fc.Result = res
	return ec.marshalOIPNITask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskId":
				return ec.fieldContext_IPNITask_taskId(ctx, field)
			case "contextId":
				return ec.fieldContext_IPNITask_contextId(ctx, field)
			case "complete":
				return ec.fieldContext_IPNITask_complete(ctx, field)
			case "isRm":
				return ec.fieldContext_IPNITask_isRm(ctx, field)
			case "sector":
				return ec.fieldContext_IPNITask_sector(ctx, field)
			case "sectorOffset":
				return ec.fieldContext_IPNITask_sectorOffset(ctx, field)
			case "spId":
				return ec.fieldContext_IPNITask_spId(ctx, field)
			case "provider":
				return ec.fieldContext_IPNITask_provider(ctx, field)
			case "regSealProof":
				return ec.fieldContext_IPNITask_regSealProof(ctx, field)
			case "createdAt":
				return ec.fieldContext_IPNITask_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNITask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniTasks(rctx, fc.Args["limit"].(*int), fc.Args["spId"].(*types.ActorID), fc.Args["isRm"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.IPNITask
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.IPNITask
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IPNITask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.IPNITask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPNITask)
	fc.Result = res
	return ec.marshalNIPNITask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskId":
				return ec.fieldContext_IPNITask_taskId(ctx, field)
			case "contextId":
				return ec.fieldContext_IPNITask_contextId(ctx, field)
			case "complete":
				return ec.fieldContext_IPNITask_complete(ctx, field)
			case "isRm":
				return ec.fieldContext_IPNITask_isRm(ctx, field)
			case "sector":
				return ec.fieldContext_IPNITask_sector(ctx, field)
			case "sectorOffset":
				return ec.fieldContext_IPNITask_sectorOffset(ctx, field)
			case "spId":
				return ec.fieldContext_IPNITask_spId(ctx, field)
			case "provider":
				return ec.fieldContext_IPNITask_provider(ctx, field)
			case "regSealProof":
				return ec.fieldContext_IPNITask_regSealProof(ctx, field)
			case "createdAt":
				return ec.fieldContext_IPNITask_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNITask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniTasksCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniTasksCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniTasksCount(rctx, fc.Args["spId"].(*types.ActorID), fc.Args["isRm"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniTasksCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ipniTasksCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ipniProviders(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ipniProviders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().IpniProviders(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.IPNIProvider
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.IPNIProvider
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IPNIProvider); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.IPNIProvider`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IPNIProvider)
	fc.Result = res
	return ec.marshalNIPNIProvider2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProviderᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ipniProviders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spID":
				return ec.fieldContext_IPNIProvider_spID(ctx, field)
			case "peerID":
				return ec.fieldContext_IPNIProvider_peerID(ctx, field)
			case "head":
				return ec.fieldContext_IPNIProvider_head(ctx, field)
			case "adCount":
				return ec.fieldContext_IPNIProvider_adCount(ctx, field)
			case "status":
				return ec.fieldContext_IPNIProvider_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IPNIProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_machine(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_machine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Machine(rctx, fc.Args["id"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Machine
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Machine
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Machine); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Machine`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_machine(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_machine_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_machineByHostAndPort(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_machineByHostAndPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MachineByHostAndPort(rctx, fc.Args["hostAndPort"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Machine
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Machine
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Machine); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Machine`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_machineByHostAndPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_machineByHostAndPort_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_machines(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_machines(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Machines(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Machine
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Machine
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Machine); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Machine`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_machines(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_machineSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_machineSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MachineSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MachineSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MachineSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MachineSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MachineSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MachineSummary)
	fc.Result = res
	return ec.marshalOMachineSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_machineSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_MachineSummary_total(ctx, field)
			case "totalUp":
				return ec.fieldContext_MachineSummary_totalUp(ctx, field)
			case "totalDown":
				return ec.fieldContext_MachineSummary_totalDown(ctx, field)
			case "uniqueHostsTotal":
				return ec.fieldContext_MachineSummary_uniqueHostsTotal(ctx, field)
			case "uniqueHostsUp":
				return ec.fieldContext_MachineSummary_uniqueHostsUp(ctx, field)
			case "uniqueHostsDown":
				return ec.fieldContext_MachineSummary_uniqueHostsDown(ctx, field)
			case "totalRam":
				return ec.fieldContext_MachineSummary_totalRam(ctx, field)
			case "totalCpu":
				return ec.fieldContext_MachineSummary_totalCpu(ctx, field)
			case "totalGpu":
				return ec.fieldContext_MachineSummary_totalGpu(ctx, field)
			case "updatedAt":
				return ec.fieldContext_MachineSummary_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MachineSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketBalance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketBalance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketBalance(rctx, fc.Args["miner"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MarketBalance
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketBalance
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketBalance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketBalance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketBalance)
	fc.Result = res
	return ec.marshalOMarketBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketBalance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "miner":
				return ec.fieldContext_MarketBalance_miner(ctx, field)
			case "balance":
				return ec.fieldContext_MarketBalance_balance(ctx, field)
			case "balances":
				return ec.fieldContext_MarketBalance_balances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketBalance", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketBalance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketBalances(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketBalances(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketBalances(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MarketBalance
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MarketBalance
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MarketBalance); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MarketBalance`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MarketBalance)
	fc.Result = res
	return ec.marshalOMarketBalance2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalanceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketBalances(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "miner":
				return ec.fieldContext_MarketBalance_miner(ctx, field)
			case "balance":
				return ec.fieldContext_MarketBalance_balance(ctx, field)
			case "balances":
				return ec.fieldContext_MarketBalance_balances(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketBalance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketMk12StorageAsks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketMk12StorageAsks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketMk12StorageAsks(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MarketMk12StorageAsk
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MarketMk12StorageAsk
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MarketMk12StorageAsk); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MarketMk12StorageAsk`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MarketMk12StorageAsk)
	fc.Result = res
	return ec.marshalOMarketMk12StorageAsk2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketMk12StorageAsks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spId":
				return ec.fieldContext_MarketMk12StorageAsk_spId(ctx, field)
			case "price":
				return ec.fieldContext_MarketMk12StorageAsk_price(ctx, field)
			case "verifiedPrice":
				return ec.fieldContext_MarketMk12StorageAsk_verifiedPrice(ctx, field)
			case "minSize":
				return ec.fieldContext_MarketMk12StorageAsk_minSize(ctx, field)
			case "maxSize":
				return ec.fieldContext_MarketMk12StorageAsk_maxSize(ctx, field)
			case "createdAt":
				return ec.fieldContext_MarketMk12StorageAsk_createdAt(ctx, field)
			case "expiry":
				return ec.fieldContext_MarketMk12StorageAsk_expiry(ctx, field)
			case "sequence":
				return ec.fieldContext_MarketMk12StorageAsk_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketMk12StorageAsk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketMk12StorageAsk(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketMk12StorageAsk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketMk12StorageAsk(rctx, fc.Args["spId"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MarketMk12StorageAsk
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketMk12StorageAsk
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketMk12StorageAsk); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketMk12StorageAsk`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketMk12StorageAsk)
	fc.Result = res
	return ec.marshalOMarketMk12StorageAsk2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketMk12StorageAsk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spId":
				return ec.fieldContext_MarketMk12StorageAsk_spId(ctx, field)
			case "price":
				return ec.fieldContext_MarketMk12StorageAsk_price(ctx, field)
			case "verifiedPrice":
				return ec.fieldContext_MarketMk12StorageAsk_verifiedPrice(ctx, field)
			case "minSize":
				return ec.fieldContext_MarketMk12StorageAsk_minSize(ctx, field)
			case "maxSize":
				return ec.fieldContext_MarketMk12StorageAsk_maxSize(ctx, field)
			case "createdAt":
				return ec.fieldContext_MarketMk12StorageAsk_createdAt(ctx, field)
			case "expiry":
				return ec.fieldContext_MarketMk12StorageAsk_expiry(ctx, field)
			case "sequence":
				return ec.fieldContext_MarketMk12StorageAsk_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketMk12StorageAsk", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketMk12StorageAsk_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketMk12StorageAsksCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketMk12StorageAsksCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketMk12StorageAsksCount(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketMk12StorageAsksCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_makretPriceFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_makretPriceFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MakretPriceFilters(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.PriceFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.PriceFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PriceFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.PriceFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PriceFilter)
	fc.Result = res
	return ec.marshalOPriceFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_makretPriceFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PriceFilter_name(ctx, field)
			case "minDurationDays":
				return ec.fieldContext_PriceFilter_minDurationDays(ctx, field)
			case "maxDurationDays":
				return ec.fieldContext_PriceFilter_maxDurationDays(ctx, field)
			case "minimumSize":
				return ec.fieldContext_PriceFilter_minimumSize(ctx, field)
			case "maximumSize":
				return ec.fieldContext_PriceFilter_maximumSize(ctx, field)
			case "price":
				return ec.fieldContext_PriceFilter_price(ctx, field)
			case "verified":
				return ec.fieldContext_PriceFilter_verified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PriceFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketPriceFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketPriceFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketPriceFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.PriceFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.PriceFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PriceFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.PriceFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PriceFilter)
	fc.Result = res
	return ec.marshalOPriceFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketPriceFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_PriceFilter_name(ctx, field)
			case "minDurationDays":
				return ec.fieldContext_PriceFilter_minDurationDays(ctx, field)
			case "maxDurationDays":
				return ec.fieldContext_PriceFilter_maxDurationDays(ctx, field)
			case "minimumSize":
				return ec.fieldContext_PriceFilter_minimumSize(ctx, field)
			case "maximumSize":
				return ec.fieldContext_PriceFilter_maximumSize(ctx, field)
			case "price":
				return ec.fieldContext_PriceFilter_price(ctx, field)
			case "verified":
				return ec.fieldContext_PriceFilter_verified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PriceFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketPriceFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketCheckPriceFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketCheckPriceFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketCheckPriceFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketCheckPriceFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketCheckPriceFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketClientFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketClientFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketClientFilters(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.ClientFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.ClientFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ClientFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.ClientFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ClientFilter)
	fc.Result = res
	return ec.marshalOClientFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketClientFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ClientFilter_name(ctx, field)
			case "active":
				return ec.fieldContext_ClientFilter_active(ctx, field)
			case "wallets":
				return ec.fieldContext_ClientFilter_wallets(ctx, field)
			case "peers":
				return ec.fieldContext_ClientFilter_peers(ctx, field)
			case "pricingFilters":
				return ec.fieldContext_ClientFilter_pricingFilters(ctx, field)
			case "maxDealsPerHour":
				return ec.fieldContext_ClientFilter_maxDealsPerHour(ctx, field)
			case "maxDealSizePerHour":
				return ec.fieldContext_ClientFilter_maxDealSizePerHour(ctx, field)
			case "info":
				return ec.fieldContext_ClientFilter_info(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketClientFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.ClientFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.ClientFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ClientFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.ClientFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ClientFilter)
	fc.Result = res
	return ec.marshalOClientFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ClientFilter_name(ctx, field)
			case "active":
				return ec.fieldContext_ClientFilter_active(ctx, field)
			case "wallets":
				return ec.fieldContext_ClientFilter_wallets(ctx, field)
			case "peers":
				return ec.fieldContext_ClientFilter_peers(ctx, field)
			case "pricingFilters":
				return ec.fieldContext_ClientFilter_pricingFilters(ctx, field)
			case "maxDealsPerHour":
				return ec.fieldContext_ClientFilter_maxDealsPerHour(ctx, field)
			case "maxDealSizePerHour":
				return ec.fieldContext_ClientFilter_maxDealSizePerHour(ctx, field)
			case "info":
				return ec.fieldContext_ClientFilter_info(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketCheckClientFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketCheckClientFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketCheckClientFilter(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketCheckClientFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketCheckClientFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketAllowFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketAllowFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketAllowFilters(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MarketAllowFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MarketAllowFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MarketAllowFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MarketAllowFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MarketAllowFilter)
	fc.Result = res
	return ec.marshalOMarketAllowFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketAllowFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "wallet":
				return ec.fieldContext_MarketAllowFilter_wallet(ctx, field)
			case "status":
				return ec.fieldContext_MarketAllowFilter_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketAllowFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketAllowFilter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketAllowFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketAllowFilter(rctx, fc.Args["wallet"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MarketAllowFilter
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MarketAllowFilter
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MarketAllowFilter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MarketAllowFilter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MarketAllowFilter)
	fc.Result = res
	return ec.marshalOMarketAllowFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketAllowFilter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "wallet":
				return ec.fieldContext_MarketAllowFilter_wallet(ctx, field)
			case "status":
				return ec.fieldContext_MarketAllowFilter_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarketAllowFilter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_marketAllowFilter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_marketDefaultFilterBehaviour(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_marketDefaultFilterBehaviour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MarketDefaultFilterBehaviour(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.DefaultFilterBehaviour
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.DefaultFilterBehaviour
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DefaultFilterBehaviour); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.DefaultFilterBehaviour`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DefaultFilterBehaviour)
	fc.Result = res
	return ec.marshalODefaultFilterBehaviour2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDefaultFilterBehaviour(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_marketDefaultFilterBehaviour(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowDealsFromUnknownClients":
				return ec.fieldContext_DefaultFilterBehaviour_allowDealsFromUnknownClients(ctx, field)
			case "isDealRejectedWhenCidGravityNotReachable":
				return ec.fieldContext_DefaultFilterBehaviour_isDealRejectedWhenCidGravityNotReachable(ctx, field)
			case "isCidGravityEnabled":
				return ec.fieldContext_DefaultFilterBehaviour_isCidGravityEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DefaultFilterBehaviour", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageSends(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageSends(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageSends(rctx, fc.Args["account"].(*types.Address), fc.Args["offset"].(int), fc.Args["limit"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MessageSend
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MessageSend
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MessageSend); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MessageSend`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MessageSend)
	fc.Result = res
	return ec.marshalOMessageSend2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageSend(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageSends(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fromKey":
				return ec.fieldContext_MessageSend_fromKey(ctx, field)
			case "toAddr":
				return ec.fieldContext_MessageSend_toAddr(ctx, field)
			case "sendReason":
				return ec.fieldContext_MessageSend_sendReason(ctx, field)
			case "sendTaskId":
				return ec.fieldContext_MessageSend_sendTaskId(ctx, field)
			case "unsignedData":
				return ec.fieldContext_MessageSend_unsignedData(ctx, field)
			case "unsignedCid":
				return ec.fieldContext_MessageSend_unsignedCid(ctx, field)
			case "nonce":
				return ec.fieldContext_MessageSend_nonce(ctx, field)
			case "signedData":
				return ec.fieldContext_MessageSend_signedData(ctx, field)
			case "signedJson":
				return ec.fieldContext_MessageSend_signedJson(ctx, field)
			case "signedCid":
				return ec.fieldContext_MessageSend_signedCid(ctx, field)
			case "sendTime":
				return ec.fieldContext_MessageSend_sendTime(ctx, field)
			case "sendSuccess":
				return ec.fieldContext_MessageSend_sendSuccess(ctx, field)
			case "sendError":
				return ec.fieldContext_MessageSend_sendError(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MessageSend", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageSends_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageSendsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageSendsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageSendsCount(rctx, fc.Args["account"].(*types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageSendsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageSendsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageSend(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageSend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageSend(rctx, fc.Args["sendTaskId"].(*int), fc.Args["fromKey"].(*string), fc.Args["nonce"].(*int), fc.Args["signedCID"].(*string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MessageSend
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MessageSend
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MessageSend); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MessageSend`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MessageSend)
	fc.Result = res
	return ec.marshalOMessageSend2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageSend(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageSend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fromKey":
				return ec.fieldContext_MessageSend_fromKey(ctx, field)
			case "toAddr":
				return ec.fieldContext_MessageSend_toAddr(ctx, field)
			case "sendReason":
				return ec.fieldContext_MessageSend_sendReason(ctx, field)
			case "sendTaskId":
				return ec.fieldContext_MessageSend_sendTaskId(ctx, field)
			case "unsignedData":
				return ec.fieldContext_MessageSend_unsignedData(ctx, field)
			case "unsignedCid":
				return ec.fieldContext_MessageSend_unsignedCid(ctx, field)
			case "nonce":
				return ec.fieldContext_MessageSend_nonce(ctx, field)
			case "signedData":
				return ec.fieldContext_MessageSend_signedData(ctx, field)
			case "signedJson":
				return ec.fieldContext_MessageSend_signedJson(ctx, field)
			case "signedCid":
				return ec.fieldContext_MessageSend_signedCid(ctx, field)
			case "sendTime":
				return ec.fieldContext_MessageSend_sendTime(ctx, field)
			case "sendSuccess":
				return ec.fieldContext_MessageSend_sendSuccess(ctx, field)
			case "sendError":
				return ec.fieldContext_MessageSend_sendError(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MessageSend", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageSend_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageWaits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageWaits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageWaits(rctx, fc.Args["waiterMachineId"].(*int), fc.Args["offset"].(int), fc.Args["limit"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MessageWait
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MessageWait
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MessageWait); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MessageWait`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MessageWait)
	fc.Result = res
	return ec.marshalOMessageWait2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageWait(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageWaits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signedMessageCid":
				return ec.fieldContext_MessageWait_signedMessageCid(ctx, field)
			case "waiterMachineId":
				return ec.fieldContext_MessageWait_waiterMachineId(ctx, field)
			case "waiterMachine":
				return ec.fieldContext_MessageWait_waiterMachine(ctx, field)
			case "executedTskCid":
				return ec.fieldContext_MessageWait_executedTskCid(ctx, field)
			case "executedTskEpoch":
				return ec.fieldContext_MessageWait_executedTskEpoch(ctx, field)
			case "executedMsgCid":
				return ec.fieldContext_MessageWait_executedMsgCid(ctx, field)
			case "executedMsgData":
				return ec.fieldContext_MessageWait_executedMsgData(ctx, field)
			case "executedRcptExitcode":
				return ec.fieldContext_MessageWait_executedRcptExitcode(ctx, field)
			case "executedRcptReturn":
				return ec.fieldContext_MessageWait_executedRcptReturn(ctx, field)
			case "executedRcptGasUsed":
				return ec.fieldContext_MessageWait_executedRcptGasUsed(ctx, field)
			case "createdAt":
				return ec.fieldContext_MessageWait_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MessageWait", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageWaits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageWaitsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageWaitsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageWaitsCount(rctx, fc.Args["waiterMachineId"].(*int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageWaitsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageWaitsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_messageWait(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_messageWait(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MessageWait(rctx, fc.Args["signedMessageCid"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MessageWait
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MessageWait
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MessageWait); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MessageWait`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MessageWait)
	fc.Result = res
	return ec.marshalOMessageWait2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageWait(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_messageWait(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signedMessageCid":
				return ec.fieldContext_MessageWait_signedMessageCid(ctx, field)
			case "waiterMachineId":
				return ec.fieldContext_MessageWait_waiterMachineId(ctx, field)
			case "waiterMachine":
				return ec.fieldContext_MessageWait_waiterMachine(ctx, field)
			case "executedTskCid":
				return ec.fieldContext_MessageWait_executedTskCid(ctx, field)
			case "executedTskEpoch":
				return ec.fieldContext_MessageWait_executedTskEpoch(ctx, field)
			case "executedMsgCid":
				return ec.fieldContext_MessageWait_executedMsgCid(ctx, field)
			case "executedMsgData":
				return ec.fieldContext_MessageWait_executedMsgData(ctx, field)
			case "executedRcptExitcode":
				return ec.fieldContext_MessageWait_executedRcptExitcode(ctx, field)
			case "executedRcptReturn":
				return ec.fieldContext_MessageWait_executedRcptReturn(ctx, field)
			case "executedRcptGasUsed":
				return ec.fieldContext_MessageWait_executedRcptGasUsed(ctx, field)
			case "createdAt":
				return ec.fieldContext_MessageWait_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MessageWait", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_messageWait_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_metadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Metadata(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Metadata
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Metadata
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Metadata); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Metadata`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Metadata)
	fc.Result = res
	return ec.marshalNMetadata2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "networkName":
				return ec.fieldContext_Metadata_networkName(ctx, field)
			case "genesisTimestamp":
				return ec.fieldContext_Metadata_genesisTimestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Metadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_miner(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Miner(rctx, fc.Args["address"].(types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Miner
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Miner
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Miner); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Miner`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Miner)
	fc.Result = res
	return ec.marshalOMiner2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Miner_id(ctx, field)
			case "info":
				return ec.fieldContext_Miner_info(ctx, field)
			case "power":
				return ec.fieldContext_Miner_power(ctx, field)
			case "balance":
				return ec.fieldContext_Miner_balance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Miner", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miner_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_minerPower(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_minerPower(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MinerPower(rctx, fc.Args["address"].(*types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MinerPower
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MinerPower
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MinerPower); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MinerPower`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MinerPower)
	fc.Result = res
	return ec.marshalOMinerPower2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerPower(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_minerPower(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MinerPower_id(ctx, field)
			case "minerPower":
				return ec.fieldContext_MinerPower_minerPower(ctx, field)
			case "totalPower":
				return ec.fieldContext_MinerPower_totalPower(ctx, field)
			case "hasMinPower":
				return ec.fieldContext_MinerPower_hasMinPower(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MinerPower", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_minerPower_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningSummaryByDay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningSummaryByDay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningSummaryByDay(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MiningSummaryDay
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MiningSummaryDay
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MiningSummaryDay); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MiningSummaryDay`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MiningSummaryDay)
	fc.Result = res
	return ec.marshalOMiningSummaryDay2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningSummaryDay(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningSummaryByDay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_MiningSummaryDay_day(ctx, field)
			case "miner":
				return ec.fieldContext_MiningSummaryDay_miner(ctx, field)
			case "wonBlock":
				return ec.fieldContext_MiningSummaryDay_wonBlock(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningSummaryDay", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningSummaryByDay_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningCount(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["actor"].(*types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MiningCount
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MiningCount
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MiningCount); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MiningCount`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MiningCount)
	fc.Result = res
	return ec.marshalNMiningCount2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "include":
				return ec.fieldContext_MiningCount_include(ctx, field)
			case "exclude":
				return ec.fieldContext_MiningCount_exclude(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningCount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningWins(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningWins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningWins(rctx, fc.Args["start"].(*time.Time), fc.Args["end"].(*time.Time), fc.Args["actor"].(*types.Address), fc.Args["include"].(*bool), fc.Args["offset"].(int), fc.Args["limit"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MiningTask
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MiningTask
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MiningTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MiningTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MiningTask)
	fc.Result = res
	return ec.marshalOMiningTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningWins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskId":
				return ec.fieldContext_MiningTask_taskId(ctx, field)
			case "spId":
				return ec.fieldContext_MiningTask_spId(ctx, field)
			case "epoch":
				return ec.fieldContext_MiningTask_epoch(ctx, field)
			case "baseComputeTime":
				return ec.fieldContext_MiningTask_baseComputeTime(ctx, field)
			case "won":
				return ec.fieldContext_MiningTask_won(ctx, field)
			case "minedCid":
				return ec.fieldContext_MiningTask_minedCid(ctx, field)
			case "minedHeader":
				return ec.fieldContext_MiningTask_minedHeader(ctx, field)
			case "minedAt":
				return ec.fieldContext_MiningTask_minedAt(ctx, field)
			case "submittedAt":
				return ec.fieldContext_MiningTask_submittedAt(ctx, field)
			case "included":
				return ec.fieldContext_MiningTask_included(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningWins_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningWinsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningWinsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningWinsCount(rctx, fc.Args["start"].(*time.Time), fc.Args["end"].(*time.Time), fc.Args["actor"].(*types.Address), fc.Args["include"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningWinsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningWinsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningCountSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningCountSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningCountSummary(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["actor"].(*types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MiningCountSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MiningCountSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MiningCountSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MiningCountSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MiningCountSummary)
	fc.Result = res
	return ec.marshalOMiningCountSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningCountSummary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_MiningCountSummary_start(ctx, field)
			case "end":
				return ec.fieldContext_MiningCountSummary_end(ctx, field)
			case "total":
				return ec.fieldContext_MiningCountSummary_total(ctx, field)
			case "won":
				return ec.fieldContext_MiningCountSummary_won(ctx, field)
			case "included":
				return ec.fieldContext_MiningCountSummary_included(ctx, field)
			case "actor":
				return ec.fieldContext_MiningCountSummary_actor(ctx, field)
			case "previous":
				return ec.fieldContext_MiningCountSummary_previous(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningCountSummary", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningCountSummary_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningCountAggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningCountAggregate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningCountAggregate(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["actor"].(*types.Address), fc.Args["interval"].(model.MiningTaskAggregateInterval))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.MiningCountAggregated
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.MiningCountAggregated
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MiningCountAggregated); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.MiningCountAggregated`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MiningCountAggregated)
	fc.Result = res
	return ec.marshalOMiningCountAggregated2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountAggregated(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningCountAggregate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "time":
				return ec.fieldContext_MiningCountAggregated_time(ctx, field)
			case "total":
				return ec.fieldContext_MiningCountAggregated_total(ctx, field)
			case "won":
				return ec.fieldContext_MiningCountAggregated_won(ctx, field)
			case "included":
				return ec.fieldContext_MiningCountAggregated_included(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningCountAggregated", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningCountAggregate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_miningStatusSummay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_miningStatusSummay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().MiningStatusSummay(rctx, fc.Args["spID"].(*types.ActorID), fc.Args["start"].(time.Time), fc.Args["end"].(time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.MiningStatusSummay
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MiningStatusSummay
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MiningStatusSummay); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.MiningStatusSummay`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MiningStatusSummay)
	fc.Result = res
	return ec.marshalOMiningStatusSummay2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningStatusSummay(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_miningStatusSummay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_MiningStatusSummay_total(ctx, field)
			case "won":
				return ec.fieldContext_MiningStatusSummay_won(ctx, field)
			case "included":
				return ec.fieldContext_MiningStatusSummay_included(ctx, field)
			case "wonChangeRate":
				return ec.fieldContext_MiningStatusSummay_wonChangeRate(ctx, field)
			case "lastMinedAt":
				return ec.fieldContext_MiningStatusSummay_lastMinedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MiningStatusSummay", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_miningStatusSummay_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodesInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodesInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().NodesInfo(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.NodeInfo
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.NodeInfo
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.NodeInfo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.NodeInfo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NodeInfo)
	fc.Result = res
	return ec.marshalONodeInfo2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodesInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_NodeInfo_id(ctx, field)
			case "address":
				return ec.fieldContext_NodeInfo_address(ctx, field)
			case "layers":
				return ec.fieldContext_NodeInfo_layers(ctx, field)
			case "reachable":
				return ec.fieldContext_NodeInfo_reachable(ctx, field)
			case "syncState":
				return ec.fieldContext_NodeInfo_syncState(ctx, field)
			case "version":
				return ec.fieldContext_NodeInfo_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodeHealthSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodeHealthSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().NodeHealthSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.NodeHealthSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.NodeHealthSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.NodeHealthSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.NodeHealthSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NodeHealthSummary)
	fc.Result = res
	return ec.marshalONodeHealthSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeHealthSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodeHealthSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "onlineNodes":
				return ec.fieldContext_NodeHealthSummary_onlineNodes(ctx, field)
			case "unscheduledNodes":
				return ec.fieldContext_NodeHealthSummary_unscheduledNodes(ctx, field)
			case "offlineNodes":
				return ec.fieldContext_NodeHealthSummary_offlineNodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeHealthSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_poreps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_poreps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Poreps(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Porep
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Porep
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Porep); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Porep`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Porep)
	fc.Result = res
	return ec.marshalOPorep2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_poreps(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Porep_id(ctx, field)
			case "spId":
				return ec.fieldContext_Porep_spId(ctx, field)
			case "sectorNumber":
				return ec.fieldContext_Porep_sectorNumber(ctx, field)
			case "createTime":
				return ec.fieldContext_Porep_createTime(ctx, field)
			case "regSealProof":
				return ec.fieldContext_Porep_regSealProof(ctx, field)
			case "ticketEpoch":
				return ec.fieldContext_Porep_ticketEpoch(ctx, field)
			case "ticketValue":
				return ec.fieldContext_Porep_ticketValue(ctx, field)
			case "taskIdSdr":
				return ec.fieldContext_Porep_taskIdSdr(ctx, field)
			case "afterSdr":
				return ec.fieldContext_Porep_afterSdr(ctx, field)
			case "treeDCid":
				return ec.fieldContext_Porep_treeDCid(ctx, field)
			case "taskIdTreeD":
				return ec.fieldContext_Porep_taskIdTreeD(ctx, field)
			case "afterTreeD":
				return ec.fieldContext_Porep_afterTreeD(ctx, field)
			case "taskIdTreeC":
				return ec.fieldContext_Porep_taskIdTreeC(ctx, field)
			case "afterTreeC":
				return ec.fieldContext_Porep_afterTreeC(ctx, field)
			case "treeRCid":
				return ec.fieldContext_Porep_treeRCid(ctx, field)
			case "taskIdTreeR":
				return ec.fieldContext_Porep_taskIdTreeR(ctx, field)
			case "afterTreeR":
				return ec.fieldContext_Porep_afterTreeR(ctx, field)
			case "precommitMsgCid":
				return ec.fieldContext_Porep_precommitMsgCid(ctx, field)
			case "taskIdPrecommitMsg":
				return ec.fieldContext_Porep_taskIdPrecommitMsg(ctx, field)
			case "afterPrecommitMsg":
				return ec.fieldContext_Porep_afterPrecommitMsg(ctx, field)
			case "seedEpoch":
				return ec.fieldContext_Porep_seedEpoch(ctx, field)
			case "precommitMsgTsk":
				return ec.fieldContext_Porep_precommitMsgTsk(ctx, field)
			case "afterPrecommitMsgSuccess":
				return ec.fieldContext_Porep_afterPrecommitMsgSuccess(ctx, field)
			case "seedValue":
				return ec.fieldContext_Porep_seedValue(ctx, field)
			case "taskIdPorep":
				return ec.fieldContext_Porep_taskIdPorep(ctx, field)
			case "porepProof":
				return ec.fieldContext_Porep_porepProof(ctx, field)
			case "afterPorep":
				return ec.fieldContext_Porep_afterPorep(ctx, field)
			case "taskIdFinalize":
				return ec.fieldContext_Porep_taskIdFinalize(ctx, field)
			case "afterFinalize":
				return ec.fieldContext_Porep_afterFinalize(ctx, field)
			case "taskIdMoveStorage":
				return ec.fieldContext_Porep_taskIdMoveStorage(ctx, field)
			case "afterMoveStorage":
				return ec.fieldContext_Porep_afterMoveStorage(ctx, field)
			case "commitMsgCid":
				return ec.fieldContext_Porep_commitMsgCid(ctx, field)
			case "taskIdCommitMsg":
				return ec.fieldContext_Porep_taskIdCommitMsg(ctx, field)
			case "afterCommitMsg":
				return ec.fieldContext_Porep_afterCommitMsg(ctx, field)
			case "commitMsgTsk":
				return ec.fieldContext_Porep_commitMsgTsk(ctx, field)
			case "afterCommitMsgSuccess":
				return ec.fieldContext_Porep_afterCommitMsgSuccess(ctx, field)
			case "failed":
				return ec.fieldContext_Porep_failed(ctx, field)
			case "failedAt":
				return ec.fieldContext_Porep_failedAt(ctx, field)
			case "failedReason":
				return ec.fieldContext_Porep_failedReason(ctx, field)
			case "failedReasonMsg":
				return ec.fieldContext_Porep_failedReasonMsg(ctx, field)
			case "taskIdSynth":
				return ec.fieldContext_Porep_taskIdSynth(ctx, field)
			case "afterSynth":
				return ec.fieldContext_Porep_afterSynth(ctx, field)
			case "userSectorDurationEpochs":
				return ec.fieldContext_Porep_userSectorDurationEpochs(ctx, field)
			case "precommitReadyAt":
				return ec.fieldContext_Porep_precommitReadyAt(ctx, field)
			case "commitReadyAt":
				return ec.fieldContext_Porep_commitReadyAt(ctx, field)
			case "status":
				return ec.fieldContext_Porep_status(ctx, field)
			case "stage":
				return ec.fieldContext_Porep_stage(ctx, field)
			case "currentTask":
				return ec.fieldContext_Porep_currentTask(ctx, field)
			case "compactStages":
				return ec.fieldContext_Porep_compactStages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Porep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_porep(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_porep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Porep(rctx, fc.Args["sp"].(types.Address), fc.Args["sectorNumber"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Porep
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Porep
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Porep); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Porep`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Porep)
	fc.Result = res
	return ec.marshalOPorep2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_porep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Porep_id(ctx, field)
			case "spId":
				return ec.fieldContext_Porep_spId(ctx, field)
			case "sectorNumber":
				return ec.fieldContext_Porep_sectorNumber(ctx, field)
			case "createTime":
				return ec.fieldContext_Porep_createTime(ctx, field)
			case "regSealProof":
				return ec.fieldContext_Porep_regSealProof(ctx, field)
			case "ticketEpoch":
				return ec.fieldContext_Porep_ticketEpoch(ctx, field)
			case "ticketValue":
				return ec.fieldContext_Porep_ticketValue(ctx, field)
			case "taskIdSdr":
				return ec.fieldContext_Porep_taskIdSdr(ctx, field)
			case "afterSdr":
				return ec.fieldContext_Porep_afterSdr(ctx, field)
			case "treeDCid":
				return ec.fieldContext_Porep_treeDCid(ctx, field)
			case "taskIdTreeD":
				return ec.fieldContext_Porep_taskIdTreeD(ctx, field)
			case "afterTreeD":
				return ec.fieldContext_Porep_afterTreeD(ctx, field)
			case "taskIdTreeC":
				return ec.fieldContext_Porep_taskIdTreeC(ctx, field)
			case "afterTreeC":
				return ec.fieldContext_Porep_afterTreeC(ctx, field)
			case "treeRCid":
				return ec.fieldContext_Porep_treeRCid(ctx, field)
			case "taskIdTreeR":
				return ec.fieldContext_Porep_taskIdTreeR(ctx, field)
			case "afterTreeR":
				return ec.fieldContext_Porep_afterTreeR(ctx, field)
			case "precommitMsgCid":
				return ec.fieldContext_Porep_precommitMsgCid(ctx, field)
			case "taskIdPrecommitMsg":
				return ec.fieldContext_Porep_taskIdPrecommitMsg(ctx, field)
			case "afterPrecommitMsg":
				return ec.fieldContext_Porep_afterPrecommitMsg(ctx, field)
			case "seedEpoch":
				return ec.fieldContext_Porep_seedEpoch(ctx, field)
			case "precommitMsgTsk":
				return ec.fieldContext_Porep_precommitMsgTsk(ctx, field)
			case "afterPrecommitMsgSuccess":
				return ec.fieldContext_Porep_afterPrecommitMsgSuccess(ctx, field)
			case "seedValue":
				return ec.fieldContext_Porep_seedValue(ctx, field)
			case "taskIdPorep":
				return ec.fieldContext_Porep_taskIdPorep(ctx, field)
			case "porepProof":
				return ec.fieldContext_Porep_porepProof(ctx, field)
			case "afterPorep":
				return ec.fieldContext_Porep_afterPorep(ctx, field)
			case "taskIdFinalize":
				return ec.fieldContext_Porep_taskIdFinalize(ctx, field)
			case "afterFinalize":
				return ec.fieldContext_Porep_afterFinalize(ctx, field)
			case "taskIdMoveStorage":
				return ec.fieldContext_Porep_taskIdMoveStorage(ctx, field)
			case "afterMoveStorage":
				return ec.fieldContext_Porep_afterMoveStorage(ctx, field)
			case "commitMsgCid":
				return ec.fieldContext_Porep_commitMsgCid(ctx, field)
			case "taskIdCommitMsg":
				return ec.fieldContext_Porep_taskIdCommitMsg(ctx, field)
			case "afterCommitMsg":
				return ec.fieldContext_Porep_afterCommitMsg(ctx, field)
			case "commitMsgTsk":
				return ec.fieldContext_Porep_commitMsgTsk(ctx, field)
			case "afterCommitMsgSuccess":
				return ec.fieldContext_Porep_afterCommitMsgSuccess(ctx, field)
			case "failed":
				return ec.fieldContext_Porep_failed(ctx, field)
			case "failedAt":
				return ec.fieldContext_Porep_failedAt(ctx, field)
			case "failedReason":
				return ec.fieldContext_Porep_failedReason(ctx, field)
			case "failedReasonMsg":
				return ec.fieldContext_Porep_failedReasonMsg(ctx, field)
			case "taskIdSynth":
				return ec.fieldContext_Porep_taskIdSynth(ctx, field)
			case "afterSynth":
				return ec.fieldContext_Porep_afterSynth(ctx, field)
			case "userSectorDurationEpochs":
				return ec.fieldContext_Porep_userSectorDurationEpochs(ctx, field)
			case "precommitReadyAt":
				return ec.fieldContext_Porep_precommitReadyAt(ctx, field)
			case "commitReadyAt":
				return ec.fieldContext_Porep_commitReadyAt(ctx, field)
			case "status":
				return ec.fieldContext_Porep_status(ctx, field)
			case "stage":
				return ec.fieldContext_Porep_stage(ctx, field)
			case "currentTask":
				return ec.fieldContext_Porep_currentTask(ctx, field)
			case "compactStages":
				return ec.fieldContext_Porep_compactStages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Porep", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_porep_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_pipelinesSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_pipelinesSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().PipelinesSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.PipelineSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.PipelineSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PipelineSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.PipelineSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PipelineSummary)
	fc.Result = res
	return ec.marshalOPipelineSummary2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPipelineSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_pipelinesSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PipelineSummary_id(ctx, field)
			case "sdr":
				return ec.fieldContext_PipelineSummary_sdr(ctx, field)
			case "trees":
				return ec.fieldContext_PipelineSummary_trees(ctx, field)
			case "precommitMsg":
				return ec.fieldContext_PipelineSummary_precommitMsg(ctx, field)
			case "waitSeed":
				return ec.fieldContext_PipelineSummary_waitSeed(ctx, field)
			case "porep":
				return ec.fieldContext_PipelineSummary_porep(ctx, field)
			case "commitMsg":
				return ec.fieldContext_PipelineSummary_commitMsg(ctx, field)
			case "done":
				return ec.fieldContext_PipelineSummary_done(ctx, field)
			case "failed":
				return ec.fieldContext_PipelineSummary_failed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PipelineSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_prometheusQuery(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_prometheusQuery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().PrometheusQuery(rctx, fc.Args["query"].(string), fc.Args["time"].(*time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.PrometheusResponse
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.PrometheusResponse
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PrometheusResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.PrometheusResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrometheusResponse)
	fc.Result = res
	return ec.marshalNPrometheusResponse2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPrometheusResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_prometheusQuery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_PrometheusResponse_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrometheusResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_prometheusQuery_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_prometheusQueryRange(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_prometheusQueryRange(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().PrometheusQueryRange(rctx, fc.Args["query"].(string), fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["step"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.PrometheusResponse
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.PrometheusResponse
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PrometheusResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.PrometheusResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrometheusResponse)
	fc.Result = res
	return ec.marshalNPrometheusResponse2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPrometheusResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_prometheusQueryRange(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_PrometheusResponse_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrometheusResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_prometheusQueryRange_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sectors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Sectors(rctx, fc.Args["actor"].(*types.Address), fc.Args["sectorNumber"].(*int), fc.Args["offset"].(int), fc.Args["limit"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Sector
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Sector
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Sector); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Sector`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Sector)
	fc.Result = res
	return ec.marshalOSector2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sectors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Sector_id(ctx, field)
			case "spID":
				return ec.fieldContext_Sector_spID(ctx, field)
			case "sectorNum":
				return ec.fieldContext_Sector_sectorNum(ctx, field)
			case "status":
				return ec.fieldContext_Sector_status(ctx, field)
			case "meta":
				return ec.fieldContext_Sector_meta(ctx, field)
			case "porep":
				return ec.fieldContext_Sector_porep(ctx, field)
			case "locations":
				return ec.fieldContext_Sector_locations(ctx, field)
			case "pieces":
				return ec.fieldContext_Sector_pieces(ctx, field)
			case "tasks":
				return ec.fieldContext_Sector_tasks(ctx, field)
			case "events":
				return ec.fieldContext_Sector_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Sector", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sectors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sectorsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sectorsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SectorsCount(rctx, fc.Args["actor"].(*types.Address))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sectorsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sectorsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sector(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sector(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Sector(rctx, fc.Args["actor"].(types.Address), fc.Args["sectorNumber"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Sector
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Sector
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Sector); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Sector`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Sector)
	fc.Result = res
	return ec.marshalOSector2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sector(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Sector_id(ctx, field)
			case "spID":
				return ec.fieldContext_Sector_spID(ctx, field)
			case "sectorNum":
				return ec.fieldContext_Sector_sectorNum(ctx, field)
			case "status":
				return ec.fieldContext_Sector_status(ctx, field)
			case "meta":
				return ec.fieldContext_Sector_meta(ctx, field)
			case "porep":
				return ec.fieldContext_Sector_porep(ctx, field)
			case "locations":
				return ec.fieldContext_Sector_locations(ctx, field)
			case "pieces":
				return ec.fieldContext_Sector_pieces(ctx, field)
			case "tasks":
				return ec.fieldContext_Sector_tasks(ctx, field)
			case "events":
				return ec.fieldContext_Sector_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Sector", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sector_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sectorSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sectorSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SectorSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.SectorSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.SectorSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SectorSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.SectorSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SectorSummary)
	fc.Result = res
	return ec.marshalOSectorSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sectorSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active":
				return ec.fieldContext_SectorSummary_active(ctx, field)
			case "sealing":
				return ec.fieldContext_SectorSummary_sealing(ctx, field)
			case "failed":
				return ec.fieldContext_SectorSummary_failed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SectorSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_storage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Storage(rctx, fc.Args["id"].(string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Storage
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Storage
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Storage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Storage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Storage)
	fc.Result = res
	return ec.marshalOStorage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_storage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Storage_id(ctx, field)
			case "path":
				return ec.fieldContext_Storage_path(ctx, field)
			case "liveness":
				return ec.fieldContext_Storage_liveness(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Storage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_storage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_storages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_storages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Storages(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Storage
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Storage
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Storage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Storage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Storage)
	fc.Result = res
	return ec.marshalNStorage2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_storages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Storage_id(ctx, field)
			case "path":
				return ec.fieldContext_Storage_path(ctx, field)
			case "liveness":
				return ec.fieldContext_Storage_liveness(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Storage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_storageStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_storageStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().StorageStats(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.StorageStats
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.StorageStats
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.StorageStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.StorageStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.StorageStats)
	fc.Result = res
	return ec.marshalOStorageStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_storageStats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_StorageStats_type(ctx, field)
			case "totalCapacity":
				return ec.fieldContext_StorageStats_totalCapacity(ctx, field)
			case "totalAvailable":
				return ec.fieldContext_StorageStats_totalAvailable(ctx, field)
			case "totalUsed":
				return ec.fieldContext_StorageStats_totalUsed(ctx, field)
			case "totalReserved":
				return ec.fieldContext_StorageStats_totalReserved(ctx, field)
			case "totalFsAvailable":
				return ec.fieldContext_StorageStats_totalFsAvailable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageStats", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Task(rctx, fc.Args["id"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Task
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Task
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Task)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_task_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Tasks(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.Task
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.Task
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasksCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasksCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TasksCount(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasksCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskHistories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskHistories(rctx, fc.Args["start"].(*time.Time), fc.Args["end"].(*time.Time), fc.Args["hostPort"].(*string), fc.Args["name"].(*string), fc.Args["result"].(*bool), fc.Args["offset"].(int), fc.Args["limit"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.TaskHistory
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.TaskHistory
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.TaskHistory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.TaskHistory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TaskHistory)
	fc.Result = res
	return ec.marshalOTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskHistories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistoriesCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskHistoriesCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskHistoriesCount(rctx, fc.Args["start"].(*time.Time), fc.Args["end"].(*time.Time), fc.Args["hostPort"].(*string), fc.Args["name"].(*string), fc.Args["result"].(*bool))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskHistoriesCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistoriesCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistoriesAggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskHistoriesAggregate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskHistoriesAggregate(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["interval"].(model.TaskHistoriesAggregateInterval))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.TaskAggregate
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.TaskAggregate
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.TaskAggregate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.TaskAggregate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TaskAggregate)
	fc.Result = res
	return ec.marshalOTaskAggregate2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskAggregate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskHistoriesAggregate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "time":
				return ec.fieldContext_TaskAggregate_time(ctx, field)
			case "total":
				return ec.fieldContext_TaskAggregate_total(ctx, field)
			case "success":
				return ec.fieldContext_TaskAggregate_success(ctx, field)
			case "failure":
				return ec.fieldContext_TaskAggregate_failure(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAggregate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistoriesAggregate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasksStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasksStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TasksStats(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time), fc.Args["machine"].(*string))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.TaskStats
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.TaskStats
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.TaskStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.TaskStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TaskStats)
	fc.Result = res
	return ec.marshalOTaskStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasksStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_TaskStats_name(ctx, field)
			case "total":
				return ec.fieldContext_TaskStats_total(ctx, field)
			case "success":
				return ec.fieldContext_TaskStats_success(ctx, field)
			case "failure":
				return ec.fieldContext_TaskStats_failure(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tasksStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskNames(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskNames(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []string
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []string
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskSuccessRate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskSuccessRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskSuccessRate(rctx, fc.Args["name"].(*string), fc.Args["start"].(time.Time), fc.Args["end"].(time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.TaskSuccessRate
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.TaskSuccessRate
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TaskSuccessRate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.TaskSuccessRate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TaskSuccessRate)
	fc.Result = res
	return ec.marshalOTaskSuccessRate2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskSuccessRate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskSuccessRate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_TaskSuccessRate_total(ctx, field)
			case "success":
				return ec.fieldContext_TaskSuccessRate_success(ctx, field)
			case "failure":
				return ec.fieldContext_TaskSuccessRate_failure(ctx, field)
			case "successRate":
				return ec.fieldContext_TaskSuccessRate_successRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSuccessRate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskSuccessRate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_runningTaskSummary(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runningTaskSummary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().RunningTaskSummary(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.RunningTaskSummary
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.RunningTaskSummary
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RunningTaskSummary); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.RunningTaskSummary`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RunningTaskSummary)
	fc.Result = res
	return ec.marshalORunningTaskSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRunningTaskSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runningTaskSummary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "running":
				return ec.fieldContext_RunningTaskSummary_running(ctx, field)
			case "queued":
				return ec.fieldContext_RunningTaskSummary_queued(ctx, field)
			case "averageWaitTime":
				return ec.fieldContext_RunningTaskSummary_averageWaitTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RunningTaskSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskDurationStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskDurationStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TaskDurationStats(rctx, fc.Args["name"].(string), fc.Args["start"].(time.Time), fc.Args["end"].(time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.TaskDurationStats
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.TaskDurationStats
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TaskDurationStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/web3tea/curio-dashboard/graph/model.TaskDurationStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TaskDurationStats)
	fc.Result = res
	return ec.marshalOTaskDurationStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskDurationStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_TaskDurationStats_name(ctx, field)
			case "totalTasks":
				return ec.fieldContext_TaskDurationStats_totalTasks(ctx, field)
			case "minDurationSeconds":
				return ec.fieldContext_TaskDurationStats_minDurationSeconds(ctx, field)
			case "maxDurationSeconds":
				return ec.fieldContext_TaskDurationStats_maxDurationSeconds(ctx, field)
			case "avgDurationSeconds":
				return ec.fieldContext_TaskDurationStats_avgDurationSeconds(ctx, field)
			case "medianDurationSeconds":
				return ec.fieldContext_TaskDurationStats_medianDurationSeconds(ctx, field)
			case "p90DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p90DurationSeconds(ctx, field)
			case "p95DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p95DurationSeconds(ctx, field)
			case "p99DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p99DurationSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskDurationStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskDurationStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasksDurationStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasksDurationStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TasksDurationStats(rctx, fc.Args["start"].(time.Time), fc.Args["end"].(time.Time))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal []*model.TaskDurationStats
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*model.TaskDurationStats
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.TaskDurationStats); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/web3tea/curio-dashboard/graph/model.TaskDurationStats`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskDurationStats)
	fc.Result = res
	return ec.marshalNTaskDurationStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStatsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasksDurationStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_TaskDurationStats_name(ctx, field)
			case "totalTasks":
				return ec.fieldContext_TaskDurationStats_totalTasks(ctx, field)
			case "minDurationSeconds":
				return ec.fieldContext_TaskDurationStats_minDurationSeconds(ctx, field)
			case "maxDurationSeconds":
				return ec.fieldContext_TaskDurationStats_maxDurationSeconds(ctx, field)
			case "avgDurationSeconds":
				return ec.fieldContext_TaskDurationStats_avgDurationSeconds(ctx, field)
			case "medianDurationSeconds":
				return ec.fieldContext_TaskDurationStats_medianDurationSeconds(ctx, field)
			case "p90DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p90DurationSeconds(ctx, field)
			case "p95DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p95DurationSeconds(ctx, field)
			case "p99DurationSeconds":
				return ec.fieldContext_TaskDurationStats_p99DurationSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskDurationStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tasksDurationStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wdpostProof(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wdpostProof(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WdpostProof(rctx, fc.Args["spId"].(types.Address), fc.Args["provingPeriodStart"].(int), fc.Args["deadline"].(int), fc.Args["partition"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WdpostProofs)
	fc.Result = res
	return ec.marshalOWdpostProofs2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wdpostProof(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WdpostProofs_id(ctx, field)
			case "spId":
				return ec.fieldContext_WdpostProofs_spId(ctx, field)
			case "provingPeriodStart":
				return ec.fieldContext_WdpostProofs_provingPeriodStart(ctx, field)
			case "deadline":
				return ec.fieldContext_WdpostProofs_deadline(ctx, field)
			case "partition":
				return ec.fieldContext_WdpostProofs_partition(ctx, field)
			case "submitAtEpoch":
				return ec.fieldContext_WdpostProofs_submitAtEpoch(ctx, field)
			case "submitByEpoch":
				return ec.fieldContext_WdpostProofs_submitByEpoch(ctx, field)
			case "proofParams":
				return ec.fieldContext_WdpostProofs_proofParams(ctx, field)
			case "submitTaskId":
				return ec.fieldContext_WdpostProofs_submitTaskId(ctx, field)
			case "messageCid":
				return ec.fieldContext_WdpostProofs_messageCid(ctx, field)
			case "testTaskId":
				return ec.fieldContext_WdpostProofs_testTaskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WdpostProofs", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wdpostProof_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wdpostProofs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wdpostProofs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WdpostProofs(rctx, fc.Args["spId"].(*types.Address), fc.Args["offset"].(int), fc.Args["limit"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WdpostProofs)
	fc.Result = res
	return ec.marshalNWdpostProofs2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wdpostProofs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WdpostProofs_id(ctx, field)
			case "spId":
				return ec.fieldContext_WdpostProofs_spId(ctx, field)
			case "provingPeriodStart":
				return ec.fieldContext_WdpostProofs_provingPeriodStart(ctx, field)
			case "deadline":
				return ec.fieldContext_WdpostProofs_deadline(ctx, field)
			case "partition":
				return ec.fieldContext_WdpostProofs_partition(ctx, field)
			case "submitAtEpoch":
				return ec.fieldContext_WdpostProofs_submitAtEpoch(ctx, field)
			case "submitByEpoch":
				return ec.fieldContext_WdpostProofs_submitByEpoch(ctx, field)
			case "proofParams":
				return ec.fieldContext_WdpostProofs_proofParams(ctx, field)
			case "submitTaskId":
				return ec.fieldContext_WdpostProofs_submitTaskId(ctx, field)
			case "messageCid":
				return ec.fieldContext_WdpostProofs_messageCid(ctx, field)
			case "testTaskId":
				return ec.fieldContext_WdpostProofs_testTaskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WdpostProofs", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wdpostProofs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wdpostProofsCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wdpostProofsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WdpostProofsCount(rctx, fc.Args["spId"].(*types.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wdpostProofsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wdpostProofsCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunningTaskSummary_running(ctx context.Context, field graphql.CollectedField, obj *model.RunningTaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunningTaskSummary_running(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Running, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunningTaskSummary_running(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunningTaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunningTaskSummary_queued(ctx context.Context, field graphql.CollectedField, obj *model.RunningTaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunningTaskSummary_queued(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Queued, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunningTaskSummary_queued(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunningTaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RunningTaskSummary_averageWaitTime(ctx context.Context, field graphql.CollectedField, obj *model.RunningTaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RunningTaskSummary_averageWaitTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageWaitTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RunningTaskSummary_averageWaitTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RunningTaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_id(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_spID(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_spID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_spID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_sectorNum(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_sectorNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_sectorNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_status(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TaskStatus)
	fc.Result = res
	return ec.marshalNTaskStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_meta(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_meta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Meta(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SectorMeta)
	fc.Result = res
	return ec.marshalOSectorMeta2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMeta(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_meta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SectorMeta_id(ctx, field)
			case "spId":
				return ec.fieldContext_SectorMeta_spId(ctx, field)
			case "sectorNum":
				return ec.fieldContext_SectorMeta_sectorNum(ctx, field)
			case "regSealProof":
				return ec.fieldContext_SectorMeta_regSealProof(ctx, field)
			case "ticketEpoch":
				return ec.fieldContext_SectorMeta_ticketEpoch(ctx, field)
			case "ticketValue":
				return ec.fieldContext_SectorMeta_ticketValue(ctx, field)
			case "origSealedCid":
				return ec.fieldContext_SectorMeta_origSealedCid(ctx, field)
			case "origUnsealedCid":
				return ec.fieldContext_SectorMeta_origUnsealedCid(ctx, field)
			case "curSealedCid":
				return ec.fieldContext_SectorMeta_curSealedCid(ctx, field)
			case "curUnsealedCid":
				return ec.fieldContext_SectorMeta_curUnsealedCid(ctx, field)
			case "msgCidPrecommit":
				return ec.fieldContext_SectorMeta_msgCidPrecommit(ctx, field)
			case "msgCidCommit":
				return ec.fieldContext_SectorMeta_msgCidCommit(ctx, field)
			case "msgCidUpdate":
				return ec.fieldContext_SectorMeta_msgCidUpdate(ctx, field)
			case "seedEpoch":
				return ec.fieldContext_SectorMeta_seedEpoch(ctx, field)
			case "seedValue":
				return ec.fieldContext_SectorMeta_seedValue(ctx, field)
			case "expirationEpoch":
				return ec.fieldContext_SectorMeta_expirationEpoch(ctx, field)
			case "isCC":
				return ec.fieldContext_SectorMeta_isCC(ctx, field)
			case "deadline":
				return ec.fieldContext_SectorMeta_deadline(ctx, field)
			case "partition":
				return ec.fieldContext_SectorMeta_partition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SectorMeta", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_porep(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_porep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Porep(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Porep)
	fc.Result = res
	return ec.marshalOPorep2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_porep(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Porep_id(ctx, field)
			case "spId":
				return ec.fieldContext_Porep_spId(ctx, field)
			case "sectorNumber":
				return ec.fieldContext_Porep_sectorNumber(ctx, field)
			case "createTime":
				return ec.fieldContext_Porep_createTime(ctx, field)
			case "regSealProof":
				return ec.fieldContext_Porep_regSealProof(ctx, field)
			case "ticketEpoch":
				return ec.fieldContext_Porep_ticketEpoch(ctx, field)
			case "ticketValue":
				return ec.fieldContext_Porep_ticketValue(ctx, field)
			case "taskIdSdr":
				return ec.fieldContext_Porep_taskIdSdr(ctx, field)
			case "afterSdr":
				return ec.fieldContext_Porep_afterSdr(ctx, field)
			case "treeDCid":
				return ec.fieldContext_Porep_treeDCid(ctx, field)
			case "taskIdTreeD":
				return ec.fieldContext_Porep_taskIdTreeD(ctx, field)
			case "afterTreeD":
				return ec.fieldContext_Porep_afterTreeD(ctx, field)
			case "taskIdTreeC":
				return ec.fieldContext_Porep_taskIdTreeC(ctx, field)
			case "afterTreeC":
				return ec.fieldContext_Porep_afterTreeC(ctx, field)
			case "treeRCid":
				return ec.fieldContext_Porep_treeRCid(ctx, field)
			case "taskIdTreeR":
				return ec.fieldContext_Porep_taskIdTreeR(ctx, field)
			case "afterTreeR":
				return ec.fieldContext_Porep_afterTreeR(ctx, field)
			case "precommitMsgCid":
				return ec.fieldContext_Porep_precommitMsgCid(ctx, field)
			case "taskIdPrecommitMsg":
				return ec.fieldContext_Porep_taskIdPrecommitMsg(ctx, field)
			case "afterPrecommitMsg":
				return ec.fieldContext_Porep_afterPrecommitMsg(ctx, field)
			case "seedEpoch":
				return ec.fieldContext_Porep_seedEpoch(ctx, field)
			case "precommitMsgTsk":
				return ec.fieldContext_Porep_precommitMsgTsk(ctx, field)
			case "afterPrecommitMsgSuccess":
				return ec.fieldContext_Porep_afterPrecommitMsgSuccess(ctx, field)
			case "seedValue":
				return ec.fieldContext_Porep_seedValue(ctx, field)
			case "taskIdPorep":
				return ec.fieldContext_Porep_taskIdPorep(ctx, field)
			case "porepProof":
				return ec.fieldContext_Porep_porepProof(ctx, field)
			case "afterPorep":
				return ec.fieldContext_Porep_afterPorep(ctx, field)
			case "taskIdFinalize":
				return ec.fieldContext_Porep_taskIdFinalize(ctx, field)
			case "afterFinalize":
				return ec.fieldContext_Porep_afterFinalize(ctx, field)
			case "taskIdMoveStorage":
				return ec.fieldContext_Porep_taskIdMoveStorage(ctx, field)
			case "afterMoveStorage":
				return ec.fieldContext_Porep_afterMoveStorage(ctx, field)
			case "commitMsgCid":
				return ec.fieldContext_Porep_commitMsgCid(ctx, field)
			case "taskIdCommitMsg":
				return ec.fieldContext_Porep_taskIdCommitMsg(ctx, field)
			case "afterCommitMsg":
				return ec.fieldContext_Porep_afterCommitMsg(ctx, field)
			case "commitMsgTsk":
				return ec.fieldContext_Porep_commitMsgTsk(ctx, field)
			case "afterCommitMsgSuccess":
				return ec.fieldContext_Porep_afterCommitMsgSuccess(ctx, field)
			case "failed":
				return ec.fieldContext_Porep_failed(ctx, field)
			case "failedAt":
				return ec.fieldContext_Porep_failedAt(ctx, field)
			case "failedReason":
				return ec.fieldContext_Porep_failedReason(ctx, field)
			case "failedReasonMsg":
				return ec.fieldContext_Porep_failedReasonMsg(ctx, field)
			case "taskIdSynth":
				return ec.fieldContext_Porep_taskIdSynth(ctx, field)
			case "afterSynth":
				return ec.fieldContext_Porep_afterSynth(ctx, field)
			case "userSectorDurationEpochs":
				return ec.fieldContext_Porep_userSectorDurationEpochs(ctx, field)
			case "precommitReadyAt":
				return ec.fieldContext_Porep_precommitReadyAt(ctx, field)
			case "commitReadyAt":
				return ec.fieldContext_Porep_commitReadyAt(ctx, field)
			case "status":
				return ec.fieldContext_Porep_status(ctx, field)
			case "stage":
				return ec.fieldContext_Porep_stage(ctx, field)
			case "currentTask":
				return ec.fieldContext_Porep_currentTask(ctx, field)
			case "compactStages":
				return ec.fieldContext_Porep_compactStages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Porep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_locations(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Locations(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SectorLocation)
	fc.Result = res
	return ec.marshalNSectorLocation2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "minerId":
				return ec.fieldContext_SectorLocation_minerId(ctx, field)
			case "sectorNum":
				return ec.fieldContext_SectorLocation_sectorNum(ctx, field)
			case "sectorFiletype":
				return ec.fieldContext_SectorLocation_sectorFiletype(ctx, field)
			case "storageId":
				return ec.fieldContext_SectorLocation_storageId(ctx, field)
			case "isPrimary":
				return ec.fieldContext_SectorLocation_isPrimary(ctx, field)
			case "readTs":
				return ec.fieldContext_SectorLocation_readTs(ctx, field)
			case "readRefs":
				return ec.fieldContext_SectorLocation_readRefs(ctx, field)
			case "writeTs":
				return ec.fieldContext_SectorLocation_writeTs(ctx, field)
			case "writeLockOwner":
				return ec.fieldContext_SectorLocation_writeLockOwner(ctx, field)
			case "storage":
				return ec.fieldContext_SectorLocation_storage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SectorLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_pieces(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_pieces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Pieces(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SectorMetaPiece)
	fc.Result = res
	return ec.marshalNSectorMetaPiece2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMetaPiece(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_pieces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spID":
				return ec.fieldContext_SectorMetaPiece_spID(ctx, field)
			case "sectorNum":
				return ec.fieldContext_SectorMetaPiece_sectorNum(ctx, field)
			case "pieceNum":
				return ec.fieldContext_SectorMetaPiece_pieceNum(ctx, field)
			case "pieceCID":
				return ec.fieldContext_SectorMetaPiece_pieceCID(ctx, field)
			case "pieceSize":
				return ec.fieldContext_SectorMetaPiece_pieceSize(ctx, field)
			case "requestedKeepData":
				return ec.fieldContext_SectorMetaPiece_requestedKeepData(ctx, field)
			case "rawDataSize":
				return ec.fieldContext_SectorMetaPiece_rawDataSize(ctx, field)
			case "startEpoch":
				return ec.fieldContext_SectorMetaPiece_startEpoch(ctx, field)
			case "origEndEpoch":
				return ec.fieldContext_SectorMetaPiece_origEndEpoch(ctx, field)
			case "f05DealID":
				return ec.fieldContext_SectorMetaPiece_f05DealID(ctx, field)
			case "ddoPam":
				return ec.fieldContext_SectorMetaPiece_ddoPam(ctx, field)
			case "f05DealProposal":
				return ec.fieldContext_SectorMetaPiece_f05DealProposal(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SectorMetaPiece", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Tasks(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Sector_events(ctx context.Context, field graphql.CollectedField, obj *model.Sector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Sector_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Sector().Events(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskHistory)
	fc.Result = res
	return ec.marshalNTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Sector_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Sector",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_minerId(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_minerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_minerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_sectorNum(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_sectorNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_sectorNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_sectorFiletype(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_sectorFiletype(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorFiletype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_sectorFiletype(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_storageId(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_storageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_storageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_isPrimary(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_isPrimary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrimary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullBool)
	fc.Result = res
	return ec.marshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_isPrimary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullBool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_readTs(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_readTs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadTs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_readTs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_readRefs(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_readRefs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadRefs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_readRefs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_writeTs(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_writeTs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WriteTs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_writeTs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_writeLockOwner(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_writeLockOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WriteLockOwner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_writeLockOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorLocation_storage(ctx context.Context, field graphql.CollectedField, obj *model.SectorLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorLocation_storage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SectorLocation().Storage(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Storage)
	fc.Result = res
	return ec.marshalOStorage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorLocation_storage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorLocation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Storage_id(ctx, field)
			case "path":
				return ec.fieldContext_Storage_path(ctx, field)
			case "liveness":
				return ec.fieldContext_Storage_liveness(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Storage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_id(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SectorMeta().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_spId(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_sectorNum(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_sectorNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_sectorNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_regSealProof(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_regSealProof(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegSealProof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_regSealProof(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_ticketEpoch(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_ticketEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_ticketEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_ticketValue(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_ticketValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_ticketValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_origSealedCid(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_origSealedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrigSealedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_origSealedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_origUnsealedCid(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_origUnsealedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrigUnsealedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_origUnsealedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_curSealedCid(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_curSealedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurSealedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_curSealedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_curUnsealedCid(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_curUnsealedCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurUnsealedCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_curUnsealedCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_msgCidPrecommit(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_msgCidPrecommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MsgCidPrecommit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_msgCidPrecommit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_msgCidCommit(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_msgCidCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MsgCidCommit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_msgCidCommit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_msgCidUpdate(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_msgCidUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MsgCidUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_msgCidUpdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_seedEpoch(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_seedEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeedEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_seedEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_seedValue(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_seedValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_seedValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_expirationEpoch(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_expirationEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpirationEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_expirationEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_isCC(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_isCC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_isCC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_deadline(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_deadline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deadline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_deadline(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMeta_partition(ctx context.Context, field graphql.CollectedField, obj *model.SectorMeta) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMeta_partition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Partition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMeta_partition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMeta",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_spID(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_spID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_spID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_sectorNum(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_sectorNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_sectorNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_pieceNum(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_pieceNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_pieceNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_pieceCID(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_pieceCID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_pieceCID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_pieceSize(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_pieceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PieceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_pieceSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_requestedKeepData(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_requestedKeepData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedKeepData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_requestedKeepData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_rawDataSize(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_rawDataSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawDataSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_rawDataSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_startEpoch(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_startEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_startEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_origEndEpoch(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_origEndEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrigEndEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_origEndEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_f05DealID(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_f05DealID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_f05DealID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_ddoPam(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_ddoPam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DdoPam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_ddoPam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorMetaPiece_f05DealProposal(ctx context.Context, field graphql.CollectedField, obj *model.SectorMetaPiece) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorMetaPiece_f05DealProposal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.F05DealProposal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*types.JSON)
	fc.Result = res
	return ec.marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorMetaPiece_f05DealProposal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorMetaPiece",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorSummary_active(ctx context.Context, field graphql.CollectedField, obj *model.SectorSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorSummary_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorSummary_active(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorSummary_sealing(ctx context.Context, field graphql.CollectedField, obj *model.SectorSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorSummary_sealing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sealing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorSummary_sealing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SectorSummary_failed(ctx context.Context, field graphql.CollectedField, obj *model.SectorSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SectorSummary_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SectorSummary_failed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SectorSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Storage_id(ctx context.Context, field graphql.CollectedField, obj *model.Storage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Storage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Storage_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Storage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Storage_path(ctx context.Context, field graphql.CollectedField, obj *model.Storage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Storage_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Storage().Path(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StoragePath)
	fc.Result = res
	return ec.marshalOStoragePath2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStoragePath(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Storage_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Storage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StoragePath_id(ctx, field)
			case "storageId":
				return ec.fieldContext_StoragePath_storageId(ctx, field)
			case "type":
				return ec.fieldContext_StoragePath_type(ctx, field)
			case "urls":
				return ec.fieldContext_StoragePath_urls(ctx, field)
			case "weight":
				return ec.fieldContext_StoragePath_weight(ctx, field)
			case "maxStorage":
				return ec.fieldContext_StoragePath_maxStorage(ctx, field)
			case "canSeal":
				return ec.fieldContext_StoragePath_canSeal(ctx, field)
			case "canStore":
				return ec.fieldContext_StoragePath_canStore(ctx, field)
			case "groups":
				return ec.fieldContext_StoragePath_groups(ctx, field)
			case "allowTo":
				return ec.fieldContext_StoragePath_allowTo(ctx, field)
			case "allowTypes":
				return ec.fieldContext_StoragePath_allowTypes(ctx, field)
			case "denyTypes":
				return ec.fieldContext_StoragePath_denyTypes(ctx, field)
			case "capacity":
				return ec.fieldContext_StoragePath_capacity(ctx, field)
			case "available":
				return ec.fieldContext_StoragePath_available(ctx, field)
			case "fsAvailable":
				return ec.fieldContext_StoragePath_fsAvailable(ctx, field)
			case "reserved":
				return ec.fieldContext_StoragePath_reserved(ctx, field)
			case "used":
				return ec.fieldContext_StoragePath_used(ctx, field)
			case "lastHeartbeat":
				return ec.fieldContext_StoragePath_lastHeartbeat(ctx, field)
			case "heartbeatErr":
				return ec.fieldContext_StoragePath_heartbeatErr(ctx, field)
			case "allowMiners":
				return ec.fieldContext_StoragePath_allowMiners(ctx, field)
			case "denyMiners":
				return ec.fieldContext_StoragePath_denyMiners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StoragePath", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Storage_liveness(ctx context.Context, field graphql.CollectedField, obj *model.Storage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Storage_liveness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Storage().Liveness(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StorageLiveness)
	fc.Result = res
	return ec.marshalOStorageLiveness2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageLiveness(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Storage_liveness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Storage",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "storageId":
				return ec.fieldContext_StorageLiveness_storageId(ctx, field)
			case "url":
				return ec.fieldContext_StorageLiveness_url(ctx, field)
			case "lastChecked":
				return ec.fieldContext_StorageLiveness_lastChecked(ctx, field)
			case "lastLive":
				return ec.fieldContext_StorageLiveness_lastLive(ctx, field)
			case "lastDead":
				return ec.fieldContext_StorageLiveness_lastDead(ctx, field)
			case "lastDeadReason":
				return ec.fieldContext_StorageLiveness_lastDeadReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StorageLiveness", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_storageId(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_storageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_storageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_url(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_lastChecked(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_lastChecked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastChecked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_lastChecked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_lastLive(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_lastLive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastLive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_lastLive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_lastDead(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_lastDead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_lastDead(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageLiveness_lastDeadReason(ctx context.Context, field graphql.CollectedField, obj *model.StorageLiveness) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageLiveness_lastDeadReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDeadReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageLiveness_lastDeadReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageLiveness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_id(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_storageId(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_storageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StorageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_storageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_type(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StoragePath().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StorageType)
	fc.Result = res
	return ec.marshalNStorageType2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StorageType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_urls(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Urls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_weight(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_weight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_maxStorage(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_maxStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_maxStorage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_canSeal(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_canSeal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanSeal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullBool)
	fc.Result = res
	return ec.marshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_canSeal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullBool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_canStore(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_canStore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanStore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullBool)
	fc.Result = res
	return ec.marshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_canStore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullBool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_groups(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_groups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_allowTo(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_allowTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_allowTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_allowTypes(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_allowTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_allowTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_denyTypes(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_denyTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DenyTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_denyTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_capacity(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_available(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_fsAvailable(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_fsAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_fsAvailable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_reserved(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_reserved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_reserved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_used(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullInt64)
	fc.Result = res
	return ec.marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullInt64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_lastHeartbeat(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_lastHeartbeat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastHeartbeat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullTime)
	fc.Result = res
	return ec.marshalNNullTime2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_lastHeartbeat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_heartbeatErr(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_heartbeatErr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeartbeatErr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_heartbeatErr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_allowMiners(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_allowMiners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowMiners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_allowMiners(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StoragePath_denyMiners(ctx context.Context, field graphql.CollectedField, obj *model.StoragePath) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StoragePath_denyMiners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DenyMiners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.NullString)
	fc.Result = res
	return ec.marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StoragePath_denyMiners(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StoragePath",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NullString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_type(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StorageType)
	fc.Result = res
	return ec.marshalNStorageType2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StorageType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_totalCapacity(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_totalCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_totalCapacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_totalAvailable(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_totalAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_totalAvailable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_totalUsed(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_totalUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_totalUsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_totalReserved(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_totalReserved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReserved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_totalReserved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageStats_totalFsAvailable(ctx context.Context, field graphql.CollectedField, obj *model.StorageStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageStats_totalFsAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalFsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageStats_totalFsAvailable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_time(ctx context.Context, field graphql.CollectedField, obj *model.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_available(ctx context.Context, field graphql.CollectedField, obj *model.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_used(ctx context.Context, field graphql.CollectedField, obj *model.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Used, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_reserved(ctx context.Context, field graphql.CollectedField, obj *model.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_reserved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_reserved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StorageUsage_fsAvailable(ctx context.Context, field graphql.CollectedField, obj *model.StorageUsage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StorageUsage_fsAvailable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StorageUsage_fsAvailable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StorageUsage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_alerts(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_alerts(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().Alerts(rctx, fc.Args["offset"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Alert
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Alert
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.Alert); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/web3tea/curio-dashboard/graph/model.Alert`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Alert):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAlert2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alert_id(ctx, field)
			case "machineName":
				return ec.fieldContext_Alert_machineName(ctx, field)
			case "message":
				return ec.fieldContext_Alert_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_chainHead(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_chainHead(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().ChainHead(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.ChainHead
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.ChainHead
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.ChainHead); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/web3tea/curio-dashboard/graph/model.ChainHead`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.ChainHead):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNChainHead2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐChainHead(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_chainHead(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "height":
				return ec.fieldContext_ChainHead_height(ctx, field)
			case "timestamp":
				return ec.fieldContext_ChainHead_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainHead", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_completedTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_completedTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().CompletedTask(rctx, fc.Args["machine"].(*string), fc.Args["last"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.TaskHistory
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.TaskHistory
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.TaskHistory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/web3tea/curio-dashboard/graph/model.TaskHistory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.TaskHistory):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_completedTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_completedTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_newTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_newTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().NewTask(rctx, fc.Args["machineID"].(*int), fc.Args["last"].(int))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx, "USER")
			if err != nil {
				var zeroVal *model.Task
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Task
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/web3tea/curio-dashboard/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Task):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_newTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "initiatedByID":
				return ec.fieldContext_Task_initiatedByID(ctx, field)
			case "initiatedBy":
				return ec.fieldContext_Task_initiatedBy(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "postedTime":
				return ec.fieldContext_Task_postedTime(ctx, field)
			case "ownerId":
				return ec.fieldContext_Task_ownerId(ctx, field)
			case "owner":
				return ec.fieldContext_Task_owner(ctx, field)
			case "addedByID":
				return ec.fieldContext_Task_addedByID(ctx, field)
			case "addedBy":
				return ec.fieldContext_Task_addedBy(ctx, field)
			case "previousTaskID":
				return ec.fieldContext_Task_previousTaskID(ctx, field)
			case "previousTask":
				return ec.fieldContext_Task_previousTask(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "histories":
				return ec.fieldContext_Task_histories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_newTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_initiatedByID(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_initiatedByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InitiatedByID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_initiatedByID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_initiatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_initiatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().InitiatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_initiatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_updateTime(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_updateTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_postedTime(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_postedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_postedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ownerId(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ownerId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ownerId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_owner(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_addedByID(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_addedByID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedByID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_addedByID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_addedBy(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_addedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().AddedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalNMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_addedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_previousTaskID(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_previousTaskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousTaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_previousTaskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_previousTask(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_previousTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().PreviousTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TaskHistory)
	fc.Result = res
	return ec.marshalOTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_previousTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_name(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_histories(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_histories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Histories(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TaskHistory)
	fc.Result = res
	return ec.marshalOTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_histories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskHistory_id(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskHistory_taskId(ctx, field)
			case "name":
				return ec.fieldContext_TaskHistory_name(ctx, field)
			case "posted":
				return ec.fieldContext_TaskHistory_posted(ctx, field)
			case "workStart":
				return ec.fieldContext_TaskHistory_workStart(ctx, field)
			case "workEnd":
				return ec.fieldContext_TaskHistory_workEnd(ctx, field)
			case "result":
				return ec.fieldContext_TaskHistory_result(ctx, field)
			case "err":
				return ec.fieldContext_TaskHistory_err(ctx, field)
			case "completedByHostAndPort":
				return ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
			case "completedBy":
				return ec.fieldContext_TaskHistory_completedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAggregate_time(ctx context.Context, field graphql.CollectedField, obj *model.TaskAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAggregate_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAggregate_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAggregate_total(ctx context.Context, field graphql.CollectedField, obj *model.TaskAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAggregate_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAggregate_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAggregate_success(ctx context.Context, field graphql.CollectedField, obj *model.TaskAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAggregate_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAggregate_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAggregate_failure(ctx context.Context, field graphql.CollectedField, obj *model.TaskAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAggregate_failure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAggregate_failure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskCompactStage_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskCompactStage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskCompactStage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskCompactStage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskCompactStage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskCompactStage_status(ctx context.Context, field graphql.CollectedField, obj *model.TaskCompactStage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskCompactStage_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TaskStatus)
	fc.Result = res
	return ec.marshalNTaskStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskCompactStage_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskCompactStage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskCompactStage_taskId(ctx context.Context, field graphql.CollectedField, obj *model.TaskCompactStage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskCompactStage_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskCompactStage_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskCompactStage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_totalTasks(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_totalTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_totalTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_minDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_minDurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_minDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_maxDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_maxDurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_maxDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_avgDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_avgDurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvgDurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_avgDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_medianDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_medianDurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MedianDurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_medianDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_p90DurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_p90DurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P90DurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_p90DurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_p95DurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_p95DurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P95DurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_p95DurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskDurationStats_p99DurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.TaskDurationStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskDurationStats_p99DurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P99DurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskDurationStats_p99DurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskDurationStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_taskId(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_posted(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_posted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_posted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_workStart(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_workStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_workStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_workEnd(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_workEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkEnd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_workEnd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_result(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_result(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_err(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_err(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Err, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_err(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_completedByHostAndPort(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_completedByHostAndPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedByHostAndPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_completedByHostAndPort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_completedBy(ctx context.Context, field graphql.CollectedField, obj *model.TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_completedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskHistory().CompletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Machine)
	fc.Result = res
	return ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_completedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Machine_id(ctx, field)
			case "lastContact":
				return ec.fieldContext_Machine_lastContact(ctx, field)
			case "hostAndPort":
				return ec.fieldContext_Machine_hostAndPort(ctx, field)
			case "cpu":
				return ec.fieldContext_Machine_cpu(ctx, field)
			case "ram":
				return ec.fieldContext_Machine_ram(ctx, field)
			case "gpu":
				return ec.fieldContext_Machine_gpu(ctx, field)
			case "detail":
				return ec.fieldContext_Machine_detail(ctx, field)
			case "tasks":
				return ec.fieldContext_Machine_tasks(ctx, field)
			case "taskHistories":
				return ec.fieldContext_Machine_taskHistories(ctx, field)
			case "storages":
				return ec.fieldContext_Machine_storages(ctx, field)
			case "metrics":
				return ec.fieldContext_Machine_metrics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Machine", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskNameAggregate_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskNameAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskNameAggregate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskNameAggregate_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskNameAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskNameAggregate_total(ctx context.Context, field graphql.CollectedField, obj *model.TaskNameAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskNameAggregate_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskNameAggregate_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskNameAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskNameAggregate_success(ctx context.Context, field graphql.CollectedField, obj *model.TaskNameAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskNameAggregate_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskNameAggregate_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskNameAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskNameAggregate_failure(ctx context.Context, field graphql.CollectedField, obj *model.TaskNameAggregate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskNameAggregate_failure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskNameAggregate_failure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskNameAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_total(ctx context.Context, field graphql.CollectedField, obj *model.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_success(ctx context.Context, field graphql.CollectedField, obj *model.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_failure(ctx context.Context, field graphql.CollectedField, obj *model.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_failure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_failure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSuccessRate_total(ctx context.Context, field graphql.CollectedField, obj *model.TaskSuccessRate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSuccessRate_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSuccessRate_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSuccessRate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSuccessRate_success(ctx context.Context, field graphql.CollectedField, obj *model.TaskSuccessRate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSuccessRate_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSuccessRate_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSuccessRate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSuccessRate_failure(ctx context.Context, field graphql.CollectedField, obj *model.TaskSuccessRate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSuccessRate_failure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSuccessRate_failure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSuccessRate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSuccessRate_successRate(ctx context.Context, field graphql.CollectedField, obj *model.TaskSuccessRate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSuccessRate_successRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuccessRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSuccessRate_successRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSuccessRate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummary_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummary_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummary_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummary_trueCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummary_trueCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrueCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummary_trueCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummary_falseCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummary_falseCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FalseCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummary_falseCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummary_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummary_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummary_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummaryDay_day(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummaryDay_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummaryDay_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummaryDay_trueCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummaryDay_trueCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrueCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummaryDay_trueCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummaryDay_falseCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummaryDay_falseCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FalseCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummaryDay_falseCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSummaryDay_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskSummaryDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSummaryDay_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSummaryDay_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSummaryDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletBalance_address(ctx context.Context, field graphql.CollectedField, obj *model.WalletBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletBalance_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletBalance_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletBalance_balance(ctx context.Context, field graphql.CollectedField, obj *model.WalletBalance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletBalance_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.FIL)
	fc.Result = res
	return ec.marshalNFIL2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐFIL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletBalance_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletBalance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FIL does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_id(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.WdpostProofs().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_spId(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_spId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_spId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_provingPeriodStart(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_provingPeriodStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvingPeriodStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_provingPeriodStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_deadline(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_deadline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deadline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_deadline(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_partition(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_partition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Partition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_partition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_submitAtEpoch(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_submitAtEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmitAtEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_submitAtEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_submitByEpoch(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_submitByEpoch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmitByEpoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_submitByEpoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_proofParams(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_proofParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProofParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_proofParams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_submitTaskId(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_submitTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmitTaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_submitTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_messageCid(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_messageCid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MessageCid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_messageCid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WdpostProofs_testTaskId(ctx context.Context, field graphql.CollectedField, obj *model.WdpostProofs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WdpostProofs_testTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestTaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WdpostProofs_testTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WdpostProofs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputClientFilterInput(ctx context.Context, obj any) (model.ClientFilterInput, error) {
	var it model.ClientFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "active", "wallets", "peers", "pricingFilters", "maxDealsPerHour", "maxDealSizePerHour", "info"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "active":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "wallets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wallets"))
			data, err := ec.unmarshalNAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Wallets = data
		case "peers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("peers"))
			data, err := ec.unmarshalNPeerID2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Peers = data
		case "pricingFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pricingFilters"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PricingFilters = data
		case "maxDealsPerHour":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDealsPerHour"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDealsPerHour = data
		case "maxDealSizePerHour":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDealSizePerHour"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDealSizePerHour = data
		case "info":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("info"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Info = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMarketMk12DealFilterInput(ctx context.Context, obj any) (model.MarketMk12DealFilterInput, error) {
	var it model.MarketMk12DealFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spId", "uuid", "signedProposalCid", "proposalCid", "pieceCid"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
			data, err := ec.unmarshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpID = data
		case "uuid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uuid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UUID = data
		case "signedProposalCid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signedProposalCid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignedProposalCid = data
		case "proposalCid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proposalCid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProposalCid = data
		case "pieceCid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pieceCid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PieceCid = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMarketMk12StorageAskInput(ctx context.Context, obj any) (model.MarketMk12StorageAskInput, error) {
	var it model.MarketMk12StorageAskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spId", "price", "verifiedPrice", "minSize", "maxSize", "expiry"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spId"))
			data, err := ec.unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpID = data
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Price = data
		case "verifiedPrice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("verifiedPrice"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.VerifiedPrice = data
		case "minSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinSize = data
		case "maxSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSize = data
		case "expiry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiry"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiry = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPriceFilterInput(ctx context.Context, obj any) (model.PriceFilterInput, error) {
	var it model.PriceFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "minDurationDays", "maxDurationDays", "minimumSize", "maximumSize", "price", "verified"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "minDurationDays":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDurationDays"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDurationDays = data
		case "maxDurationDays":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDurationDays"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDurationDays = data
		case "minimumSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumSize = data
		case "maximumSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximumSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaximumSize = data
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Price = data
		case "verified":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("verified"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Verified = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actorImplementors = []string{"Actor"}

func (ec *executionContext) _Actor(ctx context.Context, sel ast.SelectionSet, obj *model.Actor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Actor")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "address":
			out.Values[i] = ec._Actor_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "layers":
			out.Values[i] = ec._Actor_layers(ctx, field, obj)
		case "qualityAdjustedPower":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_qualityAdjustedPower(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rawBytePower":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_rawBytePower(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "actorBalance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_actorBalance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "actorAvailableBalance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_actorAvailableBalance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workerBalance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_workerBalance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deadlines":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Actor_deadlines(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var actorDeadlineImplementors = []string{"ActorDeadline"}

func (ec *executionContext) _ActorDeadline(ctx context.Context, sel ast.SelectionSet, obj *model.ActorDeadline) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actorDeadlineImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActorDeadline")
		case "empty":
			out.Values[i] = ec._ActorDeadline_empty(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "current":
			out.Values[i] = ec._ActorDeadline_current(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proven":
			out.Values[i] = ec._ActorDeadline_proven(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "partFaulty":
			out.Values[i] = ec._ActorDeadline_partFaulty(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faulty":
			out.Values[i] = ec._ActorDeadline_faulty(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertImplementors = []string{"Alert"}

func (ec *executionContext) _Alert(ctx context.Context, sel ast.SelectionSet, obj *model.Alert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alert")
		case "id":
			out.Values[i] = ec._Alert_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "machineName":
			out.Values[i] = ec._Alert_machineName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Alert_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chainHeadImplementors = []string{"ChainHead"}

func (ec *executionContext) _ChainHead(ctx context.Context, sel ast.SelectionSet, obj *model.ChainHead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainHeadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainHead")
		case "height":
			out.Values[i] = ec._ChainHead_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ChainHead_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cidGravityStatusImplementors = []string{"CidGravityStatus"}

func (ec *executionContext) _CidGravityStatus(ctx context.Context, sel ast.SelectionSet, obj *model.CidGravityStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cidGravityStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CidGravityStatus")
		case "miner":
			out.Values[i] = ec._CidGravityStatus_miner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._CidGravityStatus_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientFilterImplementors = []string{"ClientFilter"}

func (ec *executionContext) _ClientFilter(ctx context.Context, sel ast.SelectionSet, obj *model.ClientFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientFilter")
		case "name":
			out.Values[i] = ec._ClientFilter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "active":
			out.Values[i] = ec._ClientFilter_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wallets":
			out.Values[i] = ec._ClientFilter_wallets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peers":
			out.Values[i] = ec._ClientFilter_peers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pricingFilters":
			out.Values[i] = ec._ClientFilter_pricingFilters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDealsPerHour":
			out.Values[i] = ec._ClientFilter_maxDealsPerHour(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDealSizePerHour":
			out.Values[i] = ec._ClientFilter_maxDealSizePerHour(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "info":
			out.Values[i] = ec._ClientFilter_info(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var configImplementors = []string{"Config"}

func (ec *executionContext) _Config(ctx context.Context, sel ast.SelectionSet, obj *model.Config) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Config")
		case "id":
			out.Values[i] = ec._Config_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Config_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "config":
			out.Values[i] = ec._Config_config(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "usedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Config_usedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dealCountSummaryImplementors = []string{"DealCountSummary"}

func (ec *executionContext) _DealCountSummary(ctx context.Context, sel ast.SelectionSet, obj *model.DealCountSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dealCountSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DealCountSummary")
		case "boost":
			out.Values[i] = ec._DealCountSummary_boost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "direct":
			out.Values[i] = ec._DealCountSummary_direct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legacy":
			out.Values[i] = ec._DealCountSummary_legacy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dealInfoImplementors = []string{"DealInfo"}

func (ec *executionContext) _DealInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DealInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dealInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DealInfo")
		case "id":
			out.Values[i] = ec._DealInfo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spId":
			out.Values[i] = ec._DealInfo_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sector":
			out.Values[i] = ec._DealInfo_sector(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DealInfo_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signedProposalCid":
			out.Values[i] = ec._DealInfo_signedProposalCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "offline":
			out.Values[i] = ec._DealInfo_offline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verified":
			out.Values[i] = ec._DealInfo_verified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startEpoch":
			out.Values[i] = ec._DealInfo_startEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endEpoch":
			out.Values[i] = ec._DealInfo_endEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientPeerId":
			out.Values[i] = ec._DealInfo_clientPeerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chainDealId":
			out.Values[i] = ec._DealInfo_chainDealId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "publishCid":
			out.Values[i] = ec._DealInfo_publishCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceCid":
			out.Values[i] = ec._DealInfo_pieceCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceSize":
			out.Values[i] = ec._DealInfo_pieceSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fastRetrieval":
			out.Values[i] = ec._DealInfo_fastRetrieval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "announceToIpni":
			out.Values[i] = ec._DealInfo_announceToIpni(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._DealInfo_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urls":
			out.Values[i] = ec._DealInfo_urls(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlHeaders":
			out.Values[i] = ec._DealInfo_urlHeaders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._DealInfo_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "miner":
			out.Values[i] = ec._DealInfo_miner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isLegacy":
			out.Values[i] = ec._DealInfo_isLegacy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indexed":
			out.Values[i] = ec._DealInfo_indexed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDdo":
			out.Values[i] = ec._DealInfo_isDdo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var defaultFilterBehaviourImplementors = []string{"DefaultFilterBehaviour"}

func (ec *executionContext) _DefaultFilterBehaviour(ctx context.Context, sel ast.SelectionSet, obj *model.DefaultFilterBehaviour) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, defaultFilterBehaviourImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DefaultFilterBehaviour")
		case "allowDealsFromUnknownClients":
			out.Values[i] = ec._DefaultFilterBehaviour_allowDealsFromUnknownClients(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDealRejectedWhenCidGravityNotReachable":
			out.Values[i] = ec._DefaultFilterBehaviour_isDealRejectedWhenCidGravityNotReachable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isCidGravityEnabled":
			out.Values[i] = ec._DefaultFilterBehaviour_isCidGravityEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gaugeCountValueImplementors = []string{"GaugeCountValue"}

func (ec *executionContext) _GaugeCountValue(ctx context.Context, sel ast.SelectionSet, obj *model.GaugeCountValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gaugeCountValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GaugeCountValue")
		case "key":
			out.Values[i] = ec._GaugeCountValue_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._GaugeCountValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNIAdvertisementImplementors = []string{"IPNIAdvertisement"}

func (ec *executionContext) _IPNIAdvertisement(ctx context.Context, sel ast.SelectionSet, obj *model.IPNIAdvertisement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNIAdvertisementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNIAdvertisement")
		case "orderNumber":
			out.Values[i] = ec._IPNIAdvertisement_orderNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pieceCid":
			out.Values[i] = ec._IPNIAdvertisement_pieceCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "adCid":
			out.Values[i] = ec._IPNIAdvertisement_adCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "previous":
			out.Values[i] = ec._IPNIAdvertisement_previous(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "contextId":
			out.Values[i] = ec._IPNIAdvertisement_contextId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pieceSize":
			out.Values[i] = ec._IPNIAdvertisement_pieceSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIAdvertisement_provider(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "providerPeerID":
			out.Values[i] = ec._IPNIAdvertisement_providerPeerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "entries":
			out.Values[i] = ec._IPNIAdvertisement_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "addresses":
			out.Values[i] = ec._IPNIAdvertisement_addresses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isSkip":
			out.Values[i] = ec._IPNIAdvertisement_isSkip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isRm":
			out.Values[i] = ec._IPNIAdvertisement_isRm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signature":
			out.Values[i] = ec._IPNIAdvertisement_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNIHeadImplementors = []string{"IPNIHead"}

func (ec *executionContext) _IPNIHead(ctx context.Context, sel ast.SelectionSet, obj *model.IPNIHead) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNIHeadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNIHead")
		case "head":
			out.Values[i] = ec._IPNIHead_head(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "provider":
			out.Values[i] = ec._IPNIHead_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNIPeerIDImplementors = []string{"IPNIPeerID"}

func (ec *executionContext) _IPNIPeerID(ctx context.Context, sel ast.SelectionSet, obj *model.IPNIPeerID) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNIPeerIDImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNIPeerID")
		case "peerID":
			out.Values[i] = ec._IPNIPeerID_peerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spID":
			out.Values[i] = ec._IPNIPeerID_spID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNIProviderImplementors = []string{"IPNIProvider"}

func (ec *executionContext) _IPNIProvider(ctx context.Context, sel ast.SelectionSet, obj *model.IPNIProvider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNIProviderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNIProvider")
		case "spID":
			out.Values[i] = ec._IPNIProvider_spID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "peerID":
			out.Values[i] = ec._IPNIProvider_peerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "head":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIProvider_head(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "adCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIProvider_adCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIProvider_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNIStatsImplementors = []string{"IPNIStats"}

func (ec *executionContext) _IPNIStats(ctx context.Context, sel ast.SelectionSet, obj *model.IPNIStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNIStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNIStats")
		case "totalAdvertisements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_totalAdvertisements(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousTotalAdvertisements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_previousTotalAdvertisements(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "providers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_providers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousProviders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_previousProviders(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "indexed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_indexed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousIndexed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_previousIndexed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skipped":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_skipped(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousSkipped":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_previousSkipped(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pendingTasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_pendingTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousPendingTasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IPNIStats_previousPendingTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iPNITaskImplementors = []string{"IPNITask"}

func (ec *executionContext) _IPNITask(ctx context.Context, sel ast.SelectionSet, obj *model.IPNITask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iPNITaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IPNITask")
		case "taskId":
			out.Values[i] = ec._IPNITask_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "contextId":
			out.Values[i] = ec._IPNITask_contextId(ctx, field, obj)
		case "complete":
			out.Values[i] = ec._IPNITask_complete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRm":
			out.Values[i] = ec._IPNITask_isRm(ctx, field, obj)
		case "sector":
			out.Values[i] = ec._IPNITask_sector(ctx, field, obj)
		case "sectorOffset":
			out.Values[i] = ec._IPNITask_sectorOffset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spId":
			out.Values[i] = ec._IPNITask_spId(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._IPNITask_provider(ctx, field, obj)
		case "regSealProof":
			out.Values[i] = ec._IPNITask_regSealProof(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._IPNITask_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var machineImplementors = []string{"Machine"}

func (ec *executionContext) _Machine(ctx context.Context, sel ast.SelectionSet, obj *model.Machine) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, machineImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Machine")
		case "id":
			out.Values[i] = ec._Machine_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastContact":
			out.Values[i] = ec._Machine_lastContact(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostAndPort":
			out.Values[i] = ec._Machine_hostAndPort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cpu":
			out.Values[i] = ec._Machine_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ram":
			out.Values[i] = ec._Machine_ram(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gpu":
			out.Values[i] = ec._Machine_gpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "detail":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Machine_detail(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Machine_tasks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskHistories":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Machine_taskHistories(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "storages":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Machine_storages(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "metrics":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Machine_metrics(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var machineDetailImplementors = []string{"MachineDetail"}

func (ec *executionContext) _MachineDetail(ctx context.Context, sel ast.SelectionSet, obj *model.MachineDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, machineDetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MachineDetail")
		case "id":
			out.Values[i] = ec._MachineDetail_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "machineName":
			out.Values[i] = ec._MachineDetail_machineName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tasks":
			out.Values[i] = ec._MachineDetail_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tasksArray":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineDetail_tasksArray(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "layers":
			out.Values[i] = ec._MachineDetail_layers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "layersArray":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineDetail_layersArray(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startupTime":
			out.Values[i] = ec._MachineDetail_startupTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "miners":
			out.Values[i] = ec._MachineDetail_miners(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minersArray":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineDetail_minersArray(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "machineId":
			out.Values[i] = ec._MachineDetail_machineId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var machineMetricsImplementors = []string{"MachineMetrics"}

func (ec *executionContext) _MachineMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.MachineMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, machineMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MachineMetrics")
		case "cpuUsage":
			out.Values[i] = ec._MachineMetrics_cpuUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gpuUsage":
			out.Values[i] = ec._MachineMetrics_gpuUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ramUsage":
			out.Values[i] = ec._MachineMetrics_ramUsage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activeTasks":
			out.Values[i] = ec._MachineMetrics_activeTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addedTasks":
			out.Values[i] = ec._MachineMetrics_addedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasksCompleted":
			out.Values[i] = ec._MachineMetrics_tasksCompleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasksStarted":
			out.Values[i] = ec._MachineMetrics_tasksStarted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goRoutines":
			out.Values[i] = ec._MachineMetrics_goRoutines(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goVersion":
			out.Values[i] = ec._MachineMetrics_goVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goThreads":
			out.Values[i] = ec._MachineMetrics_goThreads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processCpuSecondsTotal":
			out.Values[i] = ec._MachineMetrics_processCpuSecondsTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processStartTimeSeconds":
			out.Values[i] = ec._MachineMetrics_processStartTimeSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processVirtualMemoryBytes":
			out.Values[i] = ec._MachineMetrics_processVirtualMemoryBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processResidentMemoryBytes":
			out.Values[i] = ec._MachineMetrics_processResidentMemoryBytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processOpenFds":
			out.Values[i] = ec._MachineMetrics_processOpenFds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processMaxFds":
			out.Values[i] = ec._MachineMetrics_processMaxFds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var machineSummaryImplementors = []string{"MachineSummary"}

func (ec *executionContext) _MachineSummary(ctx context.Context, sel ast.SelectionSet, obj *model.MachineSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, machineSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MachineSummary")
		case "total":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_total(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_totalUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalDown":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_totalDown(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "uniqueHostsTotal":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_uniqueHostsTotal(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "uniqueHostsUp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_uniqueHostsUp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "uniqueHostsDown":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_uniqueHostsDown(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalRam":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_totalRam(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalCpu":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_totalCpu(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalGpu":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_totalGpu(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MachineSummary_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var marketAllowFilterImplementors = []string{"MarketAllowFilter"}

func (ec *executionContext) _MarketAllowFilter(ctx context.Context, sel ast.SelectionSet, obj *model.MarketAllowFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, marketAllowFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketAllowFilter")
		case "wallet":
			out.Values[i] = ec._MarketAllowFilter_wallet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._MarketAllowFilter_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var marketBalanceImplementors = []string{"MarketBalance"}

func (ec *executionContext) _MarketBalance(ctx context.Context, sel ast.SelectionSet, obj *model.MarketBalance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, marketBalanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketBalance")
		case "miner":
			out.Values[i] = ec._MarketBalance_miner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "balance":
			out.Values[i] = ec._MarketBalance_balance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "balances":
			out.Values[i] = ec._MarketBalance_balances(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var marketMk12DealImplementors = []string{"MarketMk12Deal"}

func (ec *executionContext) _MarketMk12Deal(ctx context.Context, sel ast.SelectionSet, obj *model.MarketMk12Deal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, marketMk12DealImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketMk12Deal")
		case "uuid":
			out.Values[i] = ec._MarketMk12Deal_uuid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spId":
			out.Values[i] = ec._MarketMk12Deal_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MarketMk12Deal_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signedProposalCid":
			out.Values[i] = ec._MarketMk12Deal_signedProposalCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proposalSignature":
			out.Values[i] = ec._MarketMk12Deal_proposalSignature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proposal":
			out.Values[i] = ec._MarketMk12Deal_proposal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "offline":
			out.Values[i] = ec._MarketMk12Deal_offline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verified":
			out.Values[i] = ec._MarketMk12Deal_verified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startEpoch":
			out.Values[i] = ec._MarketMk12Deal_startEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endEpoch":
			out.Values[i] = ec._MarketMk12Deal_endEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientPeerId":
			out.Values[i] = ec._MarketMk12Deal_clientPeerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chainDealId":
			out.Values[i] = ec._MarketMk12Deal_chainDealId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "publishCid":
			out.Values[i] = ec._MarketMk12Deal_publishCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceCid":
			out.Values[i] = ec._MarketMk12Deal_pieceCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceSize":
			out.Values[i] = ec._MarketMk12Deal_pieceSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fastRetrieval":
			out.Values[i] = ec._MarketMk12Deal_fastRetrieval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "announceToIpni":
			out.Values[i] = ec._MarketMk12Deal_announceToIpni(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._MarketMk12Deal_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlHeaders":
			out.Values[i] = ec._MarketMk12Deal_urlHeaders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._MarketMk12Deal_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "label":
			out.Values[i] = ec._MarketMk12Deal_label(ctx, field, obj)
		case "proposalCid":
			out.Values[i] = ec._MarketMk12Deal_proposalCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var marketMk12StorageAskImplementors = []string{"MarketMk12StorageAsk"}

func (ec *executionContext) _MarketMk12StorageAsk(ctx context.Context, sel ast.SelectionSet, obj *model.MarketMk12StorageAsk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, marketMk12StorageAskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketMk12StorageAsk")
		case "spId":
			out.Values[i] = ec._MarketMk12StorageAsk_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "price":
			out.Values[i] = ec._MarketMk12StorageAsk_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verifiedPrice":
			out.Values[i] = ec._MarketMk12StorageAsk_verifiedPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minSize":
			out.Values[i] = ec._MarketMk12StorageAsk_minSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxSize":
			out.Values[i] = ec._MarketMk12StorageAsk_maxSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._MarketMk12StorageAsk_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiry":
			out.Values[i] = ec._MarketMk12StorageAsk_expiry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sequence":
			out.Values[i] = ec._MarketMk12StorageAsk_sequence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var messageSendImplementors = []string{"MessageSend"}

func (ec *executionContext) _MessageSend(ctx context.Context, sel ast.SelectionSet, obj *model.MessageSend) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, messageSendImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MessageSend")
		case "fromKey":
			out.Values[i] = ec._MessageSend_fromKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "toAddr":
			out.Values[i] = ec._MessageSend_toAddr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sendReason":
			out.Values[i] = ec._MessageSend_sendReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sendTaskId":
			out.Values[i] = ec._MessageSend_sendTaskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsignedData":
			out.Values[i] = ec._MessageSend_unsignedData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsignedCid":
			out.Values[i] = ec._MessageSend_unsignedCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nonce":
			out.Values[i] = ec._MessageSend_nonce(ctx, field, obj)
		case "signedData":
			out.Values[i] = ec._MessageSend_signedData(ctx, field, obj)
		case "signedJson":
			out.Values[i] = ec._MessageSend_signedJson(ctx, field, obj)
		case "signedCid":
			out.Values[i] = ec._MessageSend_signedCid(ctx, field, obj)
		case "sendTime":
			out.Values[i] = ec._MessageSend_sendTime(ctx, field, obj)
		case "sendSuccess":
			out.Values[i] = ec._MessageSend_sendSuccess(ctx, field, obj)
		case "sendError":
			out.Values[i] = ec._MessageSend_sendError(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var messageWaitImplementors = []string{"MessageWait"}

func (ec *executionContext) _MessageWait(ctx context.Context, sel ast.SelectionSet, obj *model.MessageWait) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, messageWaitImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MessageWait")
		case "signedMessageCid":
			out.Values[i] = ec._MessageWait_signedMessageCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "waiterMachineId":
			out.Values[i] = ec._MessageWait_waiterMachineId(ctx, field, obj)
		case "waiterMachine":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MessageWait_waiterMachine(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "executedTskCid":
			out.Values[i] = ec._MessageWait_executedTskCid(ctx, field, obj)
		case "executedTskEpoch":
			out.Values[i] = ec._MessageWait_executedTskEpoch(ctx, field, obj)
		case "executedMsgCid":
			out.Values[i] = ec._MessageWait_executedMsgCid(ctx, field, obj)
		case "executedMsgData":
			out.Values[i] = ec._MessageWait_executedMsgData(ctx, field, obj)
		case "executedRcptExitcode":
			out.Values[i] = ec._MessageWait_executedRcptExitcode(ctx, field, obj)
		case "executedRcptReturn":
			out.Values[i] = ec._MessageWait_executedRcptReturn(ctx, field, obj)
		case "executedRcptGasUsed":
			out.Values[i] = ec._MessageWait_executedRcptGasUsed(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._MessageWait_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var metadataImplementors = []string{"Metadata"}

func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *model.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "networkName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Metadata_networkName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "genesisTimestamp":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Metadata_genesisTimestamp(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerImplementors = []string{"Miner"}

func (ec *executionContext) _Miner(ctx context.Context, sel ast.SelectionSet, obj *model.Miner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Miner")
		case "id":
			out.Values[i] = ec._Miner_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "info":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Miner_info(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "power":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Miner_power(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "balance":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Miner_balance(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerBalanceImplementors = []string{"MinerBalance"}

func (ec *executionContext) _MinerBalance(ctx context.Context, sel ast.SelectionSet, obj *model.MinerBalance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerBalanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MinerBalance")
		case "id":
			out.Values[i] = ec._MinerBalance_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "balance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MinerBalance_balance(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "available":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MinerBalance_available(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "initialPledge":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MinerBalance_initialPledge(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vesting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MinerBalance_vesting(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "preCommitDeposits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MinerBalance_preCommitDeposits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerBeneficiaryTermImplementors = []string{"MinerBeneficiaryTerm"}

func (ec *executionContext) _MinerBeneficiaryTerm(ctx context.Context, sel ast.SelectionSet, obj *model.MinerBeneficiaryTerm) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerBeneficiaryTermImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MinerBeneficiaryTerm")
		case "quota":
			out.Values[i] = ec._MinerBeneficiaryTerm_quota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usedQuota":
			out.Values[i] = ec._MinerBeneficiaryTerm_usedQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expiration":
			out.Values[i] = ec._MinerBeneficiaryTerm_expiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerInfoImplementors = []string{"MinerInfo"}

func (ec *executionContext) _MinerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.MinerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MinerInfo")
		case "owner":
			out.Values[i] = ec._MinerInfo_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worker":
			out.Values[i] = ec._MinerInfo_worker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newWorker":
			out.Values[i] = ec._MinerInfo_newWorker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "controlAddresses":
			out.Values[i] = ec._MinerInfo_controlAddresses(ctx, field, obj)
		case "workerChangeEpoch":
			out.Values[i] = ec._MinerInfo_workerChangeEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "peerId":
			out.Values[i] = ec._MinerInfo_peerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "multiAddrs":
			out.Values[i] = ec._MinerInfo_multiAddrs(ctx, field, obj)
		case "windowPoStProofType":
			out.Values[i] = ec._MinerInfo_windowPoStProofType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sectorSize":
			out.Values[i] = ec._MinerInfo_sectorSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "windowPoStPartitionSectors":
			out.Values[i] = ec._MinerInfo_windowPoStPartitionSectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consensusFaultElapsed":
			out.Values[i] = ec._MinerInfo_consensusFaultElapsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pendingOwnerAddress":
			out.Values[i] = ec._MinerInfo_pendingOwnerAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "beneficiary":
			out.Values[i] = ec._MinerInfo_beneficiary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "beneficiaryTerm":
			out.Values[i] = ec._MinerInfo_beneficiaryTerm(ctx, field, obj)
		case "pendingBeneficiaryChange":
			out.Values[i] = ec._MinerInfo_pendingBeneficiaryChange(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerPendingBeneficiaryChangeImplementors = []string{"MinerPendingBeneficiaryChange"}

func (ec *executionContext) _MinerPendingBeneficiaryChange(ctx context.Context, sel ast.SelectionSet, obj *model.MinerPendingBeneficiaryChange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerPendingBeneficiaryChangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MinerPendingBeneficiaryChange")
		case "newBeneficiary":
			out.Values[i] = ec._MinerPendingBeneficiaryChange_newBeneficiary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newQuota":
			out.Values[i] = ec._MinerPendingBeneficiaryChange_newQuota(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newExpiration":
			out.Values[i] = ec._MinerPendingBeneficiaryChange_newExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approvedByBeneficiary":
			out.Values[i] = ec._MinerPendingBeneficiaryChange_approvedByBeneficiary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approvedByNominee":
			out.Values[i] = ec._MinerPendingBeneficiaryChange_approvedByNominee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var minerPowerImplementors = []string{"MinerPower"}

func (ec *executionContext) _MinerPower(ctx context.Context, sel ast.SelectionSet, obj *model.MinerPower) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, minerPowerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MinerPower")
		case "id":
			out.Values[i] = ec._MinerPower_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minerPower":
			out.Values[i] = ec._MinerPower_minerPower(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalPower":
			out.Values[i] = ec._MinerPower_totalPower(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasMinPower":
			out.Values[i] = ec._MinerPower_hasMinPower(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningCountImplementors = []string{"MiningCount"}

func (ec *executionContext) _MiningCount(ctx context.Context, sel ast.SelectionSet, obj *model.MiningCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningCount")
		case "include":
			out.Values[i] = ec._MiningCount_include(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exclude":
			out.Values[i] = ec._MiningCount_exclude(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningCountAggregatedImplementors = []string{"MiningCountAggregated"}

func (ec *executionContext) _MiningCountAggregated(ctx context.Context, sel ast.SelectionSet, obj *model.MiningCountAggregated) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningCountAggregatedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningCountAggregated")
		case "time":
			out.Values[i] = ec._MiningCountAggregated_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MiningCountAggregated_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "won":
			out.Values[i] = ec._MiningCountAggregated_won(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "included":
			out.Values[i] = ec._MiningCountAggregated_included(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningCountSummaryImplementors = []string{"MiningCountSummary"}

func (ec *executionContext) _MiningCountSummary(ctx context.Context, sel ast.SelectionSet, obj *model.MiningCountSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningCountSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningCountSummary")
		case "start":
			out.Values[i] = ec._MiningCountSummary_start(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "end":
			out.Values[i] = ec._MiningCountSummary_end(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "total":
			out.Values[i] = ec._MiningCountSummary_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "won":
			out.Values[i] = ec._MiningCountSummary_won(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "included":
			out.Values[i] = ec._MiningCountSummary_included(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "actor":
			out.Values[i] = ec._MiningCountSummary_actor(ctx, field, obj)
		case "previous":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MiningCountSummary_previous(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningStatusSummayImplementors = []string{"MiningStatusSummay"}

func (ec *executionContext) _MiningStatusSummay(ctx context.Context, sel ast.SelectionSet, obj *model.MiningStatusSummay) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningStatusSummayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningStatusSummay")
		case "total":
			out.Values[i] = ec._MiningStatusSummay_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "won":
			out.Values[i] = ec._MiningStatusSummay_won(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "included":
			out.Values[i] = ec._MiningStatusSummay_included(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wonChangeRate":
			out.Values[i] = ec._MiningStatusSummay_wonChangeRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastMinedAt":
			out.Values[i] = ec._MiningStatusSummay_lastMinedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningSummaryDayImplementors = []string{"MiningSummaryDay"}

func (ec *executionContext) _MiningSummaryDay(ctx context.Context, sel ast.SelectionSet, obj *model.MiningSummaryDay) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningSummaryDayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningSummaryDay")
		case "day":
			out.Values[i] = ec._MiningSummaryDay_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "miner":
			out.Values[i] = ec._MiningSummaryDay_miner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wonBlock":
			out.Values[i] = ec._MiningSummaryDay_wonBlock(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var miningTaskImplementors = []string{"MiningTask"}

func (ec *executionContext) _MiningTask(ctx context.Context, sel ast.SelectionSet, obj *model.MiningTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miningTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiningTask")
		case "taskId":
			out.Values[i] = ec._MiningTask_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spId":
			out.Values[i] = ec._MiningTask_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "epoch":
			out.Values[i] = ec._MiningTask_epoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "baseComputeTime":
			out.Values[i] = ec._MiningTask_baseComputeTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "won":
			out.Values[i] = ec._MiningTask_won(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minedCid":
			out.Values[i] = ec._MiningTask_minedCid(ctx, field, obj)
		case "minedHeader":
			out.Values[i] = ec._MiningTask_minedHeader(ctx, field, obj)
		case "minedAt":
			out.Values[i] = ec._MiningTask_minedAt(ctx, field, obj)
		case "submittedAt":
			out.Values[i] = ec._MiningTask_submittedAt(ctx, field, obj)
		case "included":
			out.Values[i] = ec._MiningTask_included(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createConfig":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createConfig(ctx, field)
			})
		case "updateConfig":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateConfig(ctx, field)
			})
		case "removeConfig":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeConfig(ctx, field)
			})
		case "dealSealNow":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_dealSealNow(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketAddBalance":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketAddBalance(ctx, field)
			})
		case "updateMarketMk12StorageAsk":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMarketMk12StorageAsk(ctx, field)
			})
		case "marketAddPriceFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketAddPriceFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketUpdatePriceFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketUpdatePriceFilter(ctx, field)
			})
		case "marketDeletePriceFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketDeletePriceFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketAddClientFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketAddClientFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketUpdateClientFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketUpdateClientFilter(ctx, field)
			})
		case "marketDeleteClientFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketDeleteClientFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketToggleClientFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketToggleClientFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketSetAllowFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketSetAllowFilter(ctx, field)
			})
		case "marketDeleteAllowFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketDeleteAllowFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marketToggleAllowFilter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_marketToggleAllowFilter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeSector":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeSector(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartSector":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartSector(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartAllFailedSectors":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartAllFailedSectors(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nodeHealthSummaryImplementors = []string{"NodeHealthSummary"}

func (ec *executionContext) _NodeHealthSummary(ctx context.Context, sel ast.SelectionSet, obj *model.NodeHealthSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeHealthSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeHealthSummary")
		case "onlineNodes":
			out.Values[i] = ec._NodeHealthSummary_onlineNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduledNodes":
			out.Values[i] = ec._NodeHealthSummary_unscheduledNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "offlineNodes":
			out.Values[i] = ec._NodeHealthSummary_offlineNodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nodeInfoImplementors = []string{"NodeInfo"}

func (ec *executionContext) _NodeInfo(ctx context.Context, sel ast.SelectionSet, obj *model.NodeInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeInfo")
		case "id":
			out.Values[i] = ec._NodeInfo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "address":
			out.Values[i] = ec._NodeInfo_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layers":
			out.Values[i] = ec._NodeInfo_layers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reachable":
			out.Values[i] = ec._NodeInfo_reachable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "syncState":
			out.Values[i] = ec._NodeInfo_syncState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._NodeInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var openSectorPieceImplementors = []string{"OpenSectorPiece"}

func (ec *executionContext) _OpenSectorPiece(ctx context.Context, sel ast.SelectionSet, obj *model.OpenSectorPiece) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, openSectorPieceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpenSectorPiece")
		case "spID":
			out.Values[i] = ec._OpenSectorPiece_spID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sectorNumber":
			out.Values[i] = ec._OpenSectorPiece_sectorNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceIndex":
			out.Values[i] = ec._OpenSectorPiece_pieceIndex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceCID":
			out.Values[i] = ec._OpenSectorPiece_pieceCID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceSize":
			out.Values[i] = ec._OpenSectorPiece_pieceSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dataURL":
			out.Values[i] = ec._OpenSectorPiece_dataURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dataHeaders":
			out.Values[i] = ec._OpenSectorPiece_dataHeaders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dataRawSize":
			out.Values[i] = ec._OpenSectorPiece_dataRawSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dataDeleteOnFinalize":
			out.Values[i] = ec._OpenSectorPiece_dataDeleteOnFinalize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "f05PublishCID":
			out.Values[i] = ec._OpenSectorPiece_f05PublishCID(ctx, field, obj)
		case "f05DealID":
			out.Values[i] = ec._OpenSectorPiece_f05DealID(ctx, field, obj)
		case "f05DealProposal":
			out.Values[i] = ec._OpenSectorPiece_f05DealProposal(ctx, field, obj)
		case "f05DealStartEpoch":
			out.Values[i] = ec._OpenSectorPiece_f05DealStartEpoch(ctx, field, obj)
		case "f05DealEndEpoch":
			out.Values[i] = ec._OpenSectorPiece_f05DealEndEpoch(ctx, field, obj)
		case "directStartEpoch":
			out.Values[i] = ec._OpenSectorPiece_directStartEpoch(ctx, field, obj)
		case "directEndEpoch":
			out.Values[i] = ec._OpenSectorPiece_directEndEpoch(ctx, field, obj)
		case "directPieceActivationManifest":
			out.Values[i] = ec._OpenSectorPiece_directPieceActivationManifest(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._OpenSectorPiece_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isSnap":
			out.Values[i] = ec._OpenSectorPiece_isSnap(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pipelineSummaryImplementors = []string{"PipelineSummary"}

func (ec *executionContext) _PipelineSummary(ctx context.Context, sel ast.SelectionSet, obj *model.PipelineSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pipelineSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PipelineSummary")
		case "id":
			out.Values[i] = ec._PipelineSummary_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sdr":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_sdr(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trees":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_trees(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "precommitMsg":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_precommitMsg(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waitSeed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_waitSeed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "porep":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_porep(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "commitMsg":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_commitMsg(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "done":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_done(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "failed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PipelineSummary_failed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var porepImplementors = []string{"Porep"}

func (ec *executionContext) _Porep(ctx context.Context, sel ast.SelectionSet, obj *model.Porep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, porepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Porep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Porep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "spId":
			out.Values[i] = ec._Porep_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sectorNumber":
			out.Values[i] = ec._Porep_sectorNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Porep_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "regSealProof":
			out.Values[i] = ec._Porep_regSealProof(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ticketEpoch":
			out.Values[i] = ec._Porep_ticketEpoch(ctx, field, obj)
		case "ticketValue":
			out.Values[i] = ec._Porep_ticketValue(ctx, field, obj)
		case "taskIdSdr":
			out.Values[i] = ec._Porep_taskIdSdr(ctx, field, obj)
		case "afterSdr":
			out.Values[i] = ec._Porep_afterSdr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "treeDCid":
			out.Values[i] = ec._Porep_treeDCid(ctx, field, obj)
		case "taskIdTreeD":
			out.Values[i] = ec._Porep_taskIdTreeD(ctx, field, obj)
		case "afterTreeD":
			out.Values[i] = ec._Porep_afterTreeD(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskIdTreeC":
			out.Values[i] = ec._Porep_taskIdTreeC(ctx, field, obj)
		case "afterTreeC":
			out.Values[i] = ec._Porep_afterTreeC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "treeRCid":
			out.Values[i] = ec._Porep_treeRCid(ctx, field, obj)
		case "taskIdTreeR":
			out.Values[i] = ec._Porep_taskIdTreeR(ctx, field, obj)
		case "afterTreeR":
			out.Values[i] = ec._Porep_afterTreeR(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "precommitMsgCid":
			out.Values[i] = ec._Porep_precommitMsgCid(ctx, field, obj)
		case "taskIdPrecommitMsg":
			out.Values[i] = ec._Porep_taskIdPrecommitMsg(ctx, field, obj)
		case "afterPrecommitMsg":
			out.Values[i] = ec._Porep_afterPrecommitMsg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "seedEpoch":
			out.Values[i] = ec._Porep_seedEpoch(ctx, field, obj)
		case "precommitMsgTsk":
			out.Values[i] = ec._Porep_precommitMsgTsk(ctx, field, obj)
		case "afterPrecommitMsgSuccess":
			out.Values[i] = ec._Porep_afterPrecommitMsgSuccess(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "seedValue":
			out.Values[i] = ec._Porep_seedValue(ctx, field, obj)
		case "taskIdPorep":
			out.Values[i] = ec._Porep_taskIdPorep(ctx, field, obj)
		case "porepProof":
			out.Values[i] = ec._Porep_porepProof(ctx, field, obj)
		case "afterPorep":
			out.Values[i] = ec._Porep_afterPorep(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskIdFinalize":
			out.Values[i] = ec._Porep_taskIdFinalize(ctx, field, obj)
		case "afterFinalize":
			out.Values[i] = ec._Porep_afterFinalize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskIdMoveStorage":
			out.Values[i] = ec._Porep_taskIdMoveStorage(ctx, field, obj)
		case "afterMoveStorage":
			out.Values[i] = ec._Porep_afterMoveStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitMsgCid":
			out.Values[i] = ec._Porep_commitMsgCid(ctx, field, obj)
		case "taskIdCommitMsg":
			out.Values[i] = ec._Porep_taskIdCommitMsg(ctx, field, obj)
		case "afterCommitMsg":
			out.Values[i] = ec._Porep_afterCommitMsg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitMsgTsk":
			out.Values[i] = ec._Porep_commitMsgTsk(ctx, field, obj)
		case "afterCommitMsgSuccess":
			out.Values[i] = ec._Porep_afterCommitMsgSuccess(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failed":
			out.Values[i] = ec._Porep_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failedAt":
			out.Values[i] = ec._Porep_failedAt(ctx, field, obj)
		case "failedReason":
			out.Values[i] = ec._Porep_failedReason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failedReasonMsg":
			out.Values[i] = ec._Porep_failedReasonMsg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskIdSynth":
			out.Values[i] = ec._Porep_taskIdSynth(ctx, field, obj)
		case "afterSynth":
			out.Values[i] = ec._Porep_afterSynth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userSectorDurationEpochs":
			out.Values[i] = ec._Porep_userSectorDurationEpochs(ctx, field, obj)
		case "precommitReadyAt":
			out.Values[i] = ec._Porep_precommitReadyAt(ctx, field, obj)
		case "commitReadyAt":
			out.Values[i] = ec._Porep_commitReadyAt(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Porep_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stage":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Porep_stage(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "currentTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Porep_currentTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "compactStages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Porep_compactStages(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var powerClaimImplementors = []string{"PowerClaim"}

func (ec *executionContext) _PowerClaim(ctx context.Context, sel ast.SelectionSet, obj *model.PowerClaim) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, powerClaimImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PowerClaim")
		case "rawBytePower":
			out.Values[i] = ec._PowerClaim_rawBytePower(ctx, field, obj)
		case "qualityAdjPower":
			out.Values[i] = ec._PowerClaim_qualityAdjPower(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var priceFilterImplementors = []string{"PriceFilter"}

func (ec *executionContext) _PriceFilter(ctx context.Context, sel ast.SelectionSet, obj *model.PriceFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, priceFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PriceFilter")
		case "name":
			out.Values[i] = ec._PriceFilter_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minDurationDays":
			out.Values[i] = ec._PriceFilter_minDurationDays(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDurationDays":
			out.Values[i] = ec._PriceFilter_maxDurationDays(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minimumSize":
			out.Values[i] = ec._PriceFilter_minimumSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maximumSize":
			out.Values[i] = ec._PriceFilter_maximumSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "price":
			out.Values[i] = ec._PriceFilter_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "verified":
			out.Values[i] = ec._PriceFilter_verified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var prometheusResponseImplementors = []string{"PrometheusResponse"}

func (ec *executionContext) _PrometheusResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PrometheusResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prometheusResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrometheusResponse")
		case "data":
			out.Values[i] = ec._PrometheusResponse_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "actors":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_actors(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "actor":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_actor(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_alerts(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "config":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_config(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "configs":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_configs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketMk12Deals":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketMk12Deals(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketMk12DealsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketMk12DealsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketDealInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketDealInfo(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketDealCountSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketDealCountSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dealsPending":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dealsPending(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniAdvertisement":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniAdvertisement(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniAdvertisements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniAdvertisements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniAdvertisementsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniAdvertisementsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniTask(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniTasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniTasksCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniTasksCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ipniProviders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ipniProviders(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "machine":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_machine(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "machineByHostAndPort":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_machineByHostAndPort(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "machines":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_machines(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "machineSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_machineSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketBalance":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketBalance(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketBalances":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketBalances(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketMk12StorageAsks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketMk12StorageAsks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketMk12StorageAsk":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketMk12StorageAsk(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketMk12StorageAsksCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketMk12StorageAsksCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "makretPriceFilters":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_makretPriceFilters(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketPriceFilter":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketPriceFilter(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketCheckPriceFilter":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketCheckPriceFilter(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketClientFilters":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketClientFilters(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketClientFilter":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketClientFilter(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketCheckClientFilter":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketCheckClientFilter(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketAllowFilters":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketAllowFilters(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketAllowFilter":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketAllowFilter(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "marketDefaultFilterBehaviour":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketDefaultFilterBehaviour(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageSends":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageSends(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageSendsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageSendsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageSend":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageSend(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageWaits":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageWaits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageWaitsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageWaitsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "messageWait":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_messageWait(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "metadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_metadata(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miner":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miner(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "minerPower":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_minerPower(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningSummaryByDay":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningSummaryByDay(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningWins":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningWins(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningWinsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningWinsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningCountSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningCountSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningCountAggregate":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningCountAggregate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "miningStatusSummay":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_miningStatusSummay(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodesInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodesInfo(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodeHealthSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodeHealthSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "poreps":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_poreps(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "porep":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_porep(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "pipelinesSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pipelinesSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "prometheusQuery":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_prometheusQuery(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "prometheusQueryRange":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_prometheusQueryRange(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sectors":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sectors(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sectorsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sectorsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sector":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sector(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sectorSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sectorSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "storage":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_storage(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "storages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_storages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "storageStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_storageStats(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tasksCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasksCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistories":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistories(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistoriesCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistoriesCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistoriesAggregate":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistoriesAggregate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tasksStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasksStats(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskNames":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskNames(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskSuccessRate":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskSuccessRate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "runningTaskSummary":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_runningTaskSummary(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskDurationStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskDurationStats(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tasksDurationStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasksDurationStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wdpostProof":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wdpostProof(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wdpostProofs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wdpostProofs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wdpostProofsCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wdpostProofsCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runningTaskSummaryImplementors = []string{"RunningTaskSummary"}

func (ec *executionContext) _RunningTaskSummary(ctx context.Context, sel ast.SelectionSet, obj *model.RunningTaskSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runningTaskSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RunningTaskSummary")
		case "running":
			out.Values[i] = ec._RunningTaskSummary_running(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queued":
			out.Values[i] = ec._RunningTaskSummary_queued(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "averageWaitTime":
			out.Values[i] = ec._RunningTaskSummary_averageWaitTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sectorImplementors = []string{"Sector"}

func (ec *executionContext) _Sector(ctx context.Context, sel ast.SelectionSet, obj *model.Sector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Sector")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "spID":
			out.Values[i] = ec._Sector_spID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sectorNum":
			out.Values[i] = ec._Sector_sectorNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "meta":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_meta(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "porep":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_porep(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "locations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_locations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pieces":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_pieces(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Sector_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sectorLocationImplementors = []string{"SectorLocation"}

func (ec *executionContext) _SectorLocation(ctx context.Context, sel ast.SelectionSet, obj *model.SectorLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sectorLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SectorLocation")
		case "minerId":
			out.Values[i] = ec._SectorLocation_minerId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sectorNum":
			out.Values[i] = ec._SectorLocation_sectorNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sectorFiletype":
			out.Values[i] = ec._SectorLocation_sectorFiletype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "storageId":
			out.Values[i] = ec._SectorLocation_storageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isPrimary":
			out.Values[i] = ec._SectorLocation_isPrimary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "readTs":
			out.Values[i] = ec._SectorLocation_readTs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "readRefs":
			out.Values[i] = ec._SectorLocation_readRefs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "writeTs":
			out.Values[i] = ec._SectorLocation_writeTs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "writeLockOwner":
			out.Values[i] = ec._SectorLocation_writeLockOwner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "storage":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SectorLocation_storage(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sectorMetaImplementors = []string{"SectorMeta"}

func (ec *executionContext) _SectorMeta(ctx context.Context, sel ast.SelectionSet, obj *model.SectorMeta) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sectorMetaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SectorMeta")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SectorMeta_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "spId":
			out.Values[i] = ec._SectorMeta_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sectorNum":
			out.Values[i] = ec._SectorMeta_sectorNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "regSealProof":
			out.Values[i] = ec._SectorMeta_regSealProof(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ticketEpoch":
			out.Values[i] = ec._SectorMeta_ticketEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ticketValue":
			out.Values[i] = ec._SectorMeta_ticketValue(ctx, field, obj)
		case "origSealedCid":
			out.Values[i] = ec._SectorMeta_origSealedCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "origUnsealedCid":
			out.Values[i] = ec._SectorMeta_origUnsealedCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "curSealedCid":
			out.Values[i] = ec._SectorMeta_curSealedCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "curUnsealedCid":
			out.Values[i] = ec._SectorMeta_curUnsealedCid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "msgCidPrecommit":
			out.Values[i] = ec._SectorMeta_msgCidPrecommit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "msgCidCommit":
			out.Values[i] = ec._SectorMeta_msgCidCommit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "msgCidUpdate":
			out.Values[i] = ec._SectorMeta_msgCidUpdate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "seedEpoch":
			out.Values[i] = ec._SectorMeta_seedEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "seedValue":
			out.Values[i] = ec._SectorMeta_seedValue(ctx, field, obj)
		case "expirationEpoch":
			out.Values[i] = ec._SectorMeta_expirationEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isCC":
			out.Values[i] = ec._SectorMeta_isCC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deadline":
			out.Values[i] = ec._SectorMeta_deadline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "partition":
			out.Values[i] = ec._SectorMeta_partition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sectorMetaPieceImplementors = []string{"SectorMetaPiece"}

func (ec *executionContext) _SectorMetaPiece(ctx context.Context, sel ast.SelectionSet, obj *model.SectorMetaPiece) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sectorMetaPieceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SectorMetaPiece")
		case "spID":
			out.Values[i] = ec._SectorMetaPiece_spID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sectorNum":
			out.Values[i] = ec._SectorMetaPiece_sectorNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceNum":
			out.Values[i] = ec._SectorMetaPiece_pieceNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceCID":
			out.Values[i] = ec._SectorMetaPiece_pieceCID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pieceSize":
			out.Values[i] = ec._SectorMetaPiece_pieceSize(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestedKeepData":
			out.Values[i] = ec._SectorMetaPiece_requestedKeepData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawDataSize":
			out.Values[i] = ec._SectorMetaPiece_rawDataSize(ctx, field, obj)
		case "startEpoch":
			out.Values[i] = ec._SectorMetaPiece_startEpoch(ctx, field, obj)
		case "origEndEpoch":
			out.Values[i] = ec._SectorMetaPiece_origEndEpoch(ctx, field, obj)
		case "f05DealID":
			out.Values[i] = ec._SectorMetaPiece_f05DealID(ctx, field, obj)
		case "ddoPam":
			out.Values[i] = ec._SectorMetaPiece_ddoPam(ctx, field, obj)
		case "f05DealProposal":
			out.Values[i] = ec._SectorMetaPiece_f05DealProposal(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sectorSummaryImplementors = []string{"SectorSummary"}

func (ec *executionContext) _SectorSummary(ctx context.Context, sel ast.SelectionSet, obj *model.SectorSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sectorSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SectorSummary")
		case "active":
			out.Values[i] = ec._SectorSummary_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sealing":
			out.Values[i] = ec._SectorSummary_sealing(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failed":
			out.Values[i] = ec._SectorSummary_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storageImplementors = []string{"Storage"}

func (ec *executionContext) _Storage(ctx context.Context, sel ast.SelectionSet, obj *model.Storage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Storage")
		case "id":
			out.Values[i] = ec._Storage_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "path":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Storage_path(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "liveness":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Storage_liveness(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storageLivenessImplementors = []string{"StorageLiveness"}

func (ec *executionContext) _StorageLiveness(ctx context.Context, sel ast.SelectionSet, obj *model.StorageLiveness) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageLivenessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageLiveness")
		case "storageId":
			out.Values[i] = ec._StorageLiveness_storageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._StorageLiveness_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastChecked":
			out.Values[i] = ec._StorageLiveness_lastChecked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastLive":
			out.Values[i] = ec._StorageLiveness_lastLive(ctx, field, obj)
		case "lastDead":
			out.Values[i] = ec._StorageLiveness_lastDead(ctx, field, obj)
		case "lastDeadReason":
			out.Values[i] = ec._StorageLiveness_lastDeadReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storagePathImplementors = []string{"StoragePath"}

func (ec *executionContext) _StoragePath(ctx context.Context, sel ast.SelectionSet, obj *model.StoragePath) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storagePathImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StoragePath")
		case "id":
			out.Values[i] = ec._StoragePath_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "storageId":
			out.Values[i] = ec._StoragePath_storageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StoragePath_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			out.Values[i] = ec._StoragePath_urls(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "weight":
			out.Values[i] = ec._StoragePath_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxStorage":
			out.Values[i] = ec._StoragePath_maxStorage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canSeal":
			out.Values[i] = ec._StoragePath_canSeal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canStore":
			out.Values[i] = ec._StoragePath_canStore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "groups":
			out.Values[i] = ec._StoragePath_groups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "allowTo":
			out.Values[i] = ec._StoragePath_allowTo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "allowTypes":
			out.Values[i] = ec._StoragePath_allowTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "denyTypes":
			out.Values[i] = ec._StoragePath_denyTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "capacity":
			out.Values[i] = ec._StoragePath_capacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "available":
			out.Values[i] = ec._StoragePath_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fsAvailable":
			out.Values[i] = ec._StoragePath_fsAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reserved":
			out.Values[i] = ec._StoragePath_reserved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "used":
			out.Values[i] = ec._StoragePath_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastHeartbeat":
			out.Values[i] = ec._StoragePath_lastHeartbeat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "heartbeatErr":
			out.Values[i] = ec._StoragePath_heartbeatErr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "allowMiners":
			out.Values[i] = ec._StoragePath_allowMiners(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "denyMiners":
			out.Values[i] = ec._StoragePath_denyMiners(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storageStatsImplementors = []string{"StorageStats"}

func (ec *executionContext) _StorageStats(ctx context.Context, sel ast.SelectionSet, obj *model.StorageStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageStats")
		case "type":
			out.Values[i] = ec._StorageStats_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCapacity":
			out.Values[i] = ec._StorageStats_totalCapacity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalAvailable":
			out.Values[i] = ec._StorageStats_totalAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalUsed":
			out.Values[i] = ec._StorageStats_totalUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalReserved":
			out.Values[i] = ec._StorageStats_totalReserved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalFsAvailable":
			out.Values[i] = ec._StorageStats_totalFsAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var storageUsageImplementors = []string{"StorageUsage"}

func (ec *executionContext) _StorageUsage(ctx context.Context, sel ast.SelectionSet, obj *model.StorageUsage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, storageUsageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageUsage")
		case "time":
			out.Values[i] = ec._StorageUsage_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "available":
			out.Values[i] = ec._StorageUsage_available(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "used":
			out.Values[i] = ec._StorageUsage_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reserved":
			out.Values[i] = ec._StorageUsage_reserved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fsAvailable":
			out.Values[i] = ec._StorageUsage_fsAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "alerts":
		return ec._Subscription_alerts(ctx, fields[0])
	case "chainHead":
		return ec._Subscription_chainHead(ctx, fields[0])
	case "completedTask":
		return ec._Subscription_completedTask(ctx, fields[0])
	case "newTask":
		return ec._Subscription_newTask(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "initiatedByID":
			out.Values[i] = ec._Task_initiatedByID(ctx, field, obj)
		case "initiatedBy":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_initiatedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updateTime":
			out.Values[i] = ec._Task_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "postedTime":
			out.Values[i] = ec._Task_postedTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ownerId":
			out.Values[i] = ec._Task_ownerId(ctx, field, obj)
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "addedByID":
			out.Values[i] = ec._Task_addedByID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "addedBy":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_addedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousTaskID":
			out.Values[i] = ec._Task_previousTaskID(ctx, field, obj)
		case "previousTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_previousTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._Task_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "histories":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_histories(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskAggregateImplementors = []string{"TaskAggregate"}

func (ec *executionContext) _TaskAggregate(ctx context.Context, sel ast.SelectionSet, obj *model.TaskAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskAggregate")
		case "time":
			out.Values[i] = ec._TaskAggregate_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._TaskAggregate_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._TaskAggregate_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failure":
			out.Values[i] = ec._TaskAggregate_failure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskCompactStageImplementors = []string{"TaskCompactStage"}

func (ec *executionContext) _TaskCompactStage(ctx context.Context, sel ast.SelectionSet, obj *model.TaskCompactStage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskCompactStageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskCompactStage")
		case "name":
			out.Values[i] = ec._TaskCompactStage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TaskCompactStage_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TaskCompactStage_taskId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskDurationStatsImplementors = []string{"TaskDurationStats"}

func (ec *executionContext) _TaskDurationStats(ctx context.Context, sel ast.SelectionSet, obj *model.TaskDurationStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskDurationStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskDurationStats")
		case "name":
			out.Values[i] = ec._TaskDurationStats_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTasks":
			out.Values[i] = ec._TaskDurationStats_totalTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minDurationSeconds":
			out.Values[i] = ec._TaskDurationStats_minDurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDurationSeconds":
			out.Values[i] = ec._TaskDurationStats_maxDurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avgDurationSeconds":
			out.Values[i] = ec._TaskDurationStats_avgDurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "medianDurationSeconds":
			out.Values[i] = ec._TaskDurationStats_medianDurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "p90DurationSeconds":
			out.Values[i] = ec._TaskDurationStats_p90DurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "p95DurationSeconds":
			out.Values[i] = ec._TaskDurationStats_p95DurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "p99DurationSeconds":
			out.Values[i] = ec._TaskDurationStats_p99DurationSeconds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryImplementors = []string{"TaskHistory"}

func (ec *executionContext) _TaskHistory(ctx context.Context, sel ast.SelectionSet, obj *model.TaskHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistory")
		case "id":
			out.Values[i] = ec._TaskHistory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskId":
			out.Values[i] = ec._TaskHistory_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TaskHistory_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "posted":
			out.Values[i] = ec._TaskHistory_posted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workStart":
			out.Values[i] = ec._TaskHistory_workStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workEnd":
			out.Values[i] = ec._TaskHistory_workEnd(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "result":
			out.Values[i] = ec._TaskHistory_result(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "err":
			out.Values[i] = ec._TaskHistory_err(ctx, field, obj)
		case "completedByHostAndPort":
			out.Values[i] = ec._TaskHistory_completedByHostAndPort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "completedBy":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskHistory_completedBy(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskNameAggregateImplementors = []string{"TaskNameAggregate"}

func (ec *executionContext) _TaskNameAggregate(ctx context.Context, sel ast.SelectionSet, obj *model.TaskNameAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskNameAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskNameAggregate")
		case "name":
			out.Values[i] = ec._TaskNameAggregate_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._TaskNameAggregate_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._TaskNameAggregate_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failure":
			out.Values[i] = ec._TaskNameAggregate_failure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskStatsImplementors = []string{"TaskStats"}

func (ec *executionContext) _TaskStats(ctx context.Context, sel ast.SelectionSet, obj *model.TaskStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskStats")
		case "name":
			out.Values[i] = ec._TaskStats_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._TaskStats_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._TaskStats_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failure":
			out.Values[i] = ec._TaskStats_failure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSuccessRateImplementors = []string{"TaskSuccessRate"}

func (ec *executionContext) _TaskSuccessRate(ctx context.Context, sel ast.SelectionSet, obj *model.TaskSuccessRate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSuccessRateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSuccessRate")
		case "total":
			out.Values[i] = ec._TaskSuccessRate_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._TaskSuccessRate_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failure":
			out.Values[i] = ec._TaskSuccessRate_failure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successRate":
			out.Values[i] = ec._TaskSuccessRate_successRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSummaryImplementors = []string{"TaskSummary"}

func (ec *executionContext) _TaskSummary(ctx context.Context, sel ast.SelectionSet, obj *model.TaskSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSummary")
		case "name":
			out.Values[i] = ec._TaskSummary_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "trueCount":
			out.Values[i] = ec._TaskSummary_trueCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "falseCount":
			out.Values[i] = ec._TaskSummary_falseCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TaskSummary_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSummaryDayImplementors = []string{"TaskSummaryDay"}

func (ec *executionContext) _TaskSummaryDay(ctx context.Context, sel ast.SelectionSet, obj *model.TaskSummaryDay) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSummaryDayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSummaryDay")
		case "day":
			out.Values[i] = ec._TaskSummaryDay_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "trueCount":
			out.Values[i] = ec._TaskSummaryDay_trueCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "falseCount":
			out.Values[i] = ec._TaskSummaryDay_falseCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TaskSummaryDay_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletBalanceImplementors = []string{"WalletBalance"}

func (ec *executionContext) _WalletBalance(ctx context.Context, sel ast.SelectionSet, obj *model.WalletBalance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletBalanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletBalance")
		case "address":
			out.Values[i] = ec._WalletBalance_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "balance":
			out.Values[i] = ec._WalletBalance_balance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var wdpostProofsImplementors = []string{"WdpostProofs"}

func (ec *executionContext) _WdpostProofs(ctx context.Context, sel ast.SelectionSet, obj *model.WdpostProofs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, wdpostProofsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WdpostProofs")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WdpostProofs_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "spId":
			out.Values[i] = ec._WdpostProofs_spId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provingPeriodStart":
			out.Values[i] = ec._WdpostProofs_provingPeriodStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deadline":
			out.Values[i] = ec._WdpostProofs_deadline(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "partition":
			out.Values[i] = ec._WdpostProofs_partition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "submitAtEpoch":
			out.Values[i] = ec._WdpostProofs_submitAtEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "submitByEpoch":
			out.Values[i] = ec._WdpostProofs_submitByEpoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proofParams":
			out.Values[i] = ec._WdpostProofs_proofParams(ctx, field, obj)
		case "submitTaskId":
			out.Values[i] = ec._WdpostProofs_submitTaskId(ctx, field, obj)
		case "messageCid":
			out.Values[i] = ec._WdpostProofs_messageCid(ctx, field, obj)
		case "testTaskId":
			out.Values[i] = ec._WdpostProofs_testTaskId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx context.Context, v any) (types.ActorID, error) {
	var res types.ActorID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNActorID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx context.Context, sel ast.SelectionSet, v types.ActorID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, v any) (types.Address, error) {
	var res types.Address
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, sel ast.SelectionSet, v types.Address) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx context.Context, v any) ([]*types.Address, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*types.Address, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx context.Context, sel ast.SelectionSet, v []*types.Address) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, v any) (*types.Address, error) {
	var res = new(types.Address)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, sel ast.SelectionSet, v *types.Address) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNAlert2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx context.Context, sel ast.SelectionSet, v model.Alert) graphql.Marshaler {
	return ec._Alert(ctx, sel, &v)
}

func (ec *executionContext) marshalNAlert2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBigInt2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, v any) (types.BigInt, error) {
	var res types.BigInt
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigInt2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, sel ast.SelectionSet, v types.BigInt) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, v any) (*types.BigInt, error) {
	var res = new(types.BigInt)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, sel ast.SelectionSet, v *types.BigInt) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx context.Context, v any) (types.Bytes, error) {
	var res types.Bytes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx context.Context, sel ast.SelectionSet, v types.Bytes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNChainHead2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐChainHead(ctx context.Context, sel ast.SelectionSet, v model.ChainHead) graphql.Marshaler {
	return ec._ChainHead(ctx, sel, &v)
}

func (ec *executionContext) marshalNChainHead2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐChainHead(ctx context.Context, sel ast.SelectionSet, v *model.ChainHead) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChainHead(ctx, sel, v)
}

func (ec *executionContext) marshalNCidGravityStatus2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐCidGravityStatusᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CidGravityStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCidGravityStatus2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐCidGravityStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCidGravityStatus2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐCidGravityStatus(ctx context.Context, sel ast.SelectionSet, v *model.CidGravityStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CidGravityStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNClientFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilter(ctx context.Context, sel ast.SelectionSet, v *model.ClientFilter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ClientFilter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNClientFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilterInput(ctx context.Context, v any) (model.ClientFilterInput, error) {
	res, err := ec.unmarshalInputClientFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFIL2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐFIL(ctx context.Context, v any) (types.FIL, error) {
	var res types.FIL
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFIL2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐFIL(ctx context.Context, sel ast.SelectionSet, v types.FIL) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGaugeCountValue2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx context.Context, sel ast.SelectionSet, v []*model.GaugeCountValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGaugeCountValue2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIPNIAdvertisement2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisementᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.IPNIAdvertisement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIPNIAdvertisement2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIPNIAdvertisement2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisement(ctx context.Context, sel ast.SelectionSet, v *model.IPNIAdvertisement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IPNIAdvertisement(ctx, sel, v)
}

func (ec *executionContext) marshalNIPNIProvider2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProviderᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.IPNIProvider) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIPNIProvider2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIPNIProvider2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProvider(ctx context.Context, sel ast.SelectionSet, v *model.IPNIProvider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IPNIProvider(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIPNIProviderStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProviderStatus(ctx context.Context, v any) (model.IPNIProviderStatus, error) {
	var res model.IPNIProviderStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIPNIProviderStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIProviderStatus(ctx context.Context, sel ast.SelectionSet, v model.IPNIProviderStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNIPNIStats2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIStats(ctx context.Context, sel ast.SelectionSet, v model.IPNIStats) graphql.Marshaler {
	return ec._IPNIStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNIPNIStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIStats(ctx context.Context, sel ast.SelectionSet, v *model.IPNIStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IPNIStats(ctx, sel, v)
}

func (ec *executionContext) marshalNIPNITask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.IPNITask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIPNITask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIPNITask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITask(ctx context.Context, sel ast.SelectionSet, v *model.IPNITask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IPNITask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx context.Context, v any) (types.JSON, error) {
	var res types.JSON
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx context.Context, sel ast.SelectionSet, v types.JSON) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMachine2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx context.Context, sel ast.SelectionSet, v model.Machine) graphql.Marshaler {
	return ec._Machine(ctx, sel, &v)
}

func (ec *executionContext) marshalNMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx context.Context, sel ast.SelectionSet, v *model.Machine) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Machine(ctx, sel, v)
}

func (ec *executionContext) marshalNMachineDetail2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineDetail(ctx context.Context, sel ast.SelectionSet, v []*model.MachineDetail) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMachineDetail2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineDetail(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNMarketAllowFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilter(ctx context.Context, sel ast.SelectionSet, v *model.MarketAllowFilter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MarketAllowFilter(ctx, sel, v)
}

func (ec *executionContext) marshalNMarketBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalance(ctx context.Context, sel ast.SelectionSet, v *model.MarketBalance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MarketBalance(ctx, sel, v)
}

func (ec *executionContext) marshalNMarketMk12Deal2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12Dealᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MarketMk12Deal) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarketMk12Deal2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12Deal(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMarketMk12Deal2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12Deal(ctx context.Context, sel ast.SelectionSet, v *model.MarketMk12Deal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MarketMk12Deal(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMarketMk12DealFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12DealFilterInput(ctx context.Context, v any) (model.MarketMk12DealFilterInput, error) {
	res, err := ec.unmarshalInputMarketMk12DealFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMarketMk12StorageAskInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAskInput(ctx context.Context, v any) (model.MarketMk12StorageAskInput, error) {
	res, err := ec.unmarshalInputMarketMk12StorageAskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMetadata2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v model.Metadata) graphql.Marshaler {
	return ec._Metadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNMetadata2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v *model.Metadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Metadata(ctx, sel, v)
}

func (ec *executionContext) marshalNMiningCount2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCount(ctx context.Context, sel ast.SelectionSet, v model.MiningCount) graphql.Marshaler {
	return ec._MiningCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNMiningCount2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCount(ctx context.Context, sel ast.SelectionSet, v *model.MiningCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MiningCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMiningTaskAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTaskAggregateInterval(ctx context.Context, v any) (model.MiningTaskAggregateInterval, error) {
	var res model.MiningTaskAggregateInterval
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMiningTaskAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTaskAggregateInterval(ctx context.Context, sel ast.SelectionSet, v model.MiningTaskAggregateInterval) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx context.Context, v any) (types.NullBool, error) {
	var res types.NullBool
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNullBool2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullBool(ctx context.Context, sel ast.SelectionSet, v types.NullBool) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx context.Context, v any) (types.NullInt64, error) {
	var res types.NullInt64
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNullInt642githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullInt64(ctx context.Context, sel ast.SelectionSet, v types.NullInt64) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx context.Context, v any) (types.NullString, error) {
	var res types.NullString
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNullString2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullString(ctx context.Context, sel ast.SelectionSet, v types.NullString) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNullTime2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullTime(ctx context.Context, v any) (types.NullTime, error) {
	var res types.NullTime
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNullTime2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐNullTime(ctx context.Context, sel ast.SelectionSet, v types.NullTime) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPeerID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx context.Context, v any) (types.PeerID, error) {
	var res types.PeerID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeerID2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx context.Context, sel ast.SelectionSet, v types.PeerID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPeerID2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerIDᚄ(ctx context.Context, v any) ([]*types.PeerID, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*types.PeerID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPeerID2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerIDᚄ(ctx context.Context, sel ast.SelectionSet, v []*types.PeerID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx context.Context, v any) (*types.PeerID, error) {
	var res = new(types.PeerID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐPeerID(ctx context.Context, sel ast.SelectionSet, v *types.PeerID) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNPorepStage2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorepStage(ctx context.Context, v any) (model.PorepStage, error) {
	var res model.PorepStage
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPorepStage2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorepStage(ctx context.Context, sel ast.SelectionSet, v model.PorepStage) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPowerClaim2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPowerClaim(ctx context.Context, sel ast.SelectionSet, v *model.PowerClaim) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PowerClaim(ctx, sel, v)
}

func (ec *executionContext) marshalNPriceFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilter(ctx context.Context, sel ast.SelectionSet, v *model.PriceFilter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PriceFilter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPriceFilterInput2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilterInput(ctx context.Context, v any) (model.PriceFilterInput, error) {
	res, err := ec.unmarshalInputPriceFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPrometheusResponse2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPrometheusResponse(ctx context.Context, sel ast.SelectionSet, v model.PrometheusResponse) graphql.Marshaler {
	return ec._PrometheusResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPrometheusResponse2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPrometheusResponse(ctx context.Context, sel ast.SelectionSet, v *model.PrometheusResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrometheusResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx context.Context, v any) (model.Role, error) {
	var res model.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRole(ctx context.Context, sel ast.SelectionSet, v model.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSectorLocation2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorLocation(ctx context.Context, sel ast.SelectionSet, v []*model.SectorLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSectorLocation2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNSectorMetaPiece2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMetaPiece(ctx context.Context, sel ast.SelectionSet, v []*model.SectorMetaPiece) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSectorMetaPiece2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMetaPiece(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNStorage2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Storage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStorage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStorage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorage(ctx context.Context, sel ast.SelectionSet, v *model.Storage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Storage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStorageType2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageType(ctx context.Context, v any) (model.StorageType, error) {
	var res model.StorageType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStorageType2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageType(ctx context.Context, sel ast.SelectionSet, v model.StorageType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v model.Task) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v []*model.Task) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v *model.Task) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskCompactStage2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskCompactStageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TaskCompactStage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskCompactStage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskCompactStage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskCompactStage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskCompactStage(ctx context.Context, sel ast.SelectionSet, v *model.TaskCompactStage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskCompactStage(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskDurationStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStatsᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TaskDurationStats) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskDurationStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskDurationStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStats(ctx context.Context, sel ast.SelectionSet, v *model.TaskDurationStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskDurationStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskHistoriesAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistoriesAggregateInterval(ctx context.Context, v any) (model.TaskHistoriesAggregateInterval, error) {
	var res model.TaskHistoriesAggregateInterval
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoriesAggregateInterval2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistoriesAggregateInterval(ctx context.Context, sel ast.SelectionSet, v model.TaskHistoriesAggregateInterval) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTaskHistory2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v model.TaskHistory) graphql.Marshaler {
	return ec._TaskHistory(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v []*model.TaskHistory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v *model.TaskHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStatus(ctx context.Context, v any) (model.TaskStatus, error) {
	var res model.TaskStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskStatus2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStatus(ctx context.Context, sel ast.SelectionSet, v model.TaskStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v any) (uint64, error) {
	res, err := graphql.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	res := graphql.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNWalletBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWalletBalance(ctx context.Context, sel ast.SelectionSet, v *model.WalletBalance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletBalance(ctx, sel, v)
}

func (ec *executionContext) marshalNWdpostProofs2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofsᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WdpostProofs) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWdpostProofs2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofs(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWdpostProofs2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofs(ctx context.Context, sel ast.SelectionSet, v *model.WdpostProofs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WdpostProofs(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOActor2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActor(ctx context.Context, sel ast.SelectionSet, v []*model.Actor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOActor2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOActor2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActor(ctx context.Context, sel ast.SelectionSet, v *model.Actor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Actor(ctx, sel, v)
}

func (ec *executionContext) marshalOActorDeadline2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActorDeadline(ctx context.Context, sel ast.SelectionSet, v []*model.ActorDeadline) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOActorDeadline2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActorDeadline(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOActorDeadline2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐActorDeadline(ctx context.Context, sel ast.SelectionSet, v *model.ActorDeadline) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ActorDeadline(ctx, sel, v)
}

func (ec *executionContext) unmarshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx context.Context, v any) (*types.ActorID, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.ActorID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOActorID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐActorID(ctx context.Context, sel ast.SelectionSet, v *types.ActorID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx context.Context, v any) ([]*types.Address, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*types.Address, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAddress2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddressᚄ(ctx context.Context, sel ast.SelectionSet, v []*types.Address) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, v any) (*types.Address, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.Address)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐAddress(ctx context.Context, sel ast.SelectionSet, v *types.Address) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAlert2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx context.Context, sel ast.SelectionSet, v []*model.Alert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAlert2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAlert2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, v any) (*types.BigInt, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.BigInt)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBigInt2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBigInt(ctx context.Context, sel ast.SelectionSet, v *types.BigInt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx context.Context, v any) (types.Bytes, error) {
	if v == nil {
		return nil, nil
	}
	var res types.Bytes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBytes2githubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐBytes(ctx context.Context, sel ast.SelectionSet, v types.Bytes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOClientFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ClientFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClientFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐClientFilter(ctx context.Context, sel ast.SelectionSet, v *model.ClientFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClientFilter(ctx, sel, v)
}

func (ec *executionContext) marshalOConfig2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx context.Context, sel ast.SelectionSet, v []*model.Config) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOConfig2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐConfig(ctx context.Context, sel ast.SelectionSet, v *model.Config) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Config(ctx, sel, v)
}

func (ec *executionContext) marshalODealCountSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDealCountSummary(ctx context.Context, sel ast.SelectionSet, v *model.DealCountSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DealCountSummary(ctx, sel, v)
}

func (ec *executionContext) marshalODealInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDealInfo(ctx context.Context, sel ast.SelectionSet, v *model.DealInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DealInfo(ctx, sel, v)
}

func (ec *executionContext) marshalODefaultFilterBehaviour2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐDefaultFilterBehaviour(ctx context.Context, sel ast.SelectionSet, v *model.DefaultFilterBehaviour) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DefaultFilterBehaviour(ctx, sel, v)
}

func (ec *executionContext) marshalOGaugeCountValue2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐGaugeCountValue(ctx context.Context, sel ast.SelectionSet, v *model.GaugeCountValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GaugeCountValue(ctx, sel, v)
}

func (ec *executionContext) marshalOIPNIAdvertisement2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIAdvertisement(ctx context.Context, sel ast.SelectionSet, v *model.IPNIAdvertisement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IPNIAdvertisement(ctx, sel, v)
}

func (ec *executionContext) marshalOIPNIPeerID2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNIPeerID(ctx context.Context, sel ast.SelectionSet, v *model.IPNIPeerID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IPNIPeerID(ctx, sel, v)
}

func (ec *executionContext) marshalOIPNITask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐIPNITask(ctx context.Context, sel ast.SelectionSet, v *model.IPNITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IPNITask(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt642ᚖint64(ctx context.Context, v any) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) unmarshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx context.Context, v any) (*types.JSON, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(types.JSON)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋtypesᚐJSON(ctx context.Context, sel ast.SelectionSet, v *types.JSON) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOMachine2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx context.Context, sel ast.SelectionSet, v []*model.Machine) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMachine2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachine(ctx context.Context, sel ast.SelectionSet, v *model.Machine) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Machine(ctx, sel, v)
}

func (ec *executionContext) marshalOMachineDetail2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineDetail(ctx context.Context, sel ast.SelectionSet, v *model.MachineDetail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MachineDetail(ctx, sel, v)
}

func (ec *executionContext) marshalOMachineMetrics2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineMetrics(ctx context.Context, sel ast.SelectionSet, v *model.MachineMetrics) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MachineMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalOMachineSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMachineSummary(ctx context.Context, sel ast.SelectionSet, v *model.MachineSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MachineSummary(ctx, sel, v)
}

func (ec *executionContext) marshalOMarketAllowFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MarketAllowFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarketAllowFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMarketAllowFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketAllowFilter(ctx context.Context, sel ast.SelectionSet, v *model.MarketAllowFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MarketAllowFilter(ctx, sel, v)
}

func (ec *executionContext) marshalOMarketBalance2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MarketBalance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarketBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMarketBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketBalance(ctx context.Context, sel ast.SelectionSet, v *model.MarketBalance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MarketBalance(ctx, sel, v)
}

func (ec *executionContext) marshalOMarketMk12StorageAsk2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx context.Context, sel ast.SelectionSet, v []*model.MarketMk12StorageAsk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMarketMk12StorageAsk2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMarketMk12StorageAsk2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMarketMk12StorageAsk(ctx context.Context, sel ast.SelectionSet, v *model.MarketMk12StorageAsk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MarketMk12StorageAsk(ctx, sel, v)
}

func (ec *executionContext) marshalOMessageSend2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageSend(ctx context.Context, sel ast.SelectionSet, v []*model.MessageSend) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMessageSend2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageSend(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMessageSend2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageSend(ctx context.Context, sel ast.SelectionSet, v *model.MessageSend) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MessageSend(ctx, sel, v)
}

func (ec *executionContext) marshalOMessageWait2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageWait(ctx context.Context, sel ast.SelectionSet, v []*model.MessageWait) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMessageWait2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageWait(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMessageWait2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMessageWait(ctx context.Context, sel ast.SelectionSet, v *model.MessageWait) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MessageWait(ctx, sel, v)
}

func (ec *executionContext) marshalOMiner2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiner(ctx context.Context, sel ast.SelectionSet, v *model.Miner) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Miner(ctx, sel, v)
}

func (ec *executionContext) marshalOMinerBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerBalance(ctx context.Context, sel ast.SelectionSet, v *model.MinerBalance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MinerBalance(ctx, sel, v)
}

func (ec *executionContext) marshalOMinerBeneficiaryTerm2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerBeneficiaryTerm(ctx context.Context, sel ast.SelectionSet, v *model.MinerBeneficiaryTerm) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MinerBeneficiaryTerm(ctx, sel, v)
}

func (ec *executionContext) marshalOMinerInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerInfo(ctx context.Context, sel ast.SelectionSet, v *model.MinerInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MinerInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOMinerPendingBeneficiaryChange2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerPendingBeneficiaryChange(ctx context.Context, sel ast.SelectionSet, v *model.MinerPendingBeneficiaryChange) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MinerPendingBeneficiaryChange(ctx, sel, v)
}

func (ec *executionContext) marshalOMinerPower2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMinerPower(ctx context.Context, sel ast.SelectionSet, v *model.MinerPower) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MinerPower(ctx, sel, v)
}

func (ec *executionContext) marshalOMiningCountAggregated2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountAggregated(ctx context.Context, sel ast.SelectionSet, v []*model.MiningCountAggregated) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMiningCountAggregated2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountAggregated(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMiningCountAggregated2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountAggregated(ctx context.Context, sel ast.SelectionSet, v *model.MiningCountAggregated) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MiningCountAggregated(ctx, sel, v)
}

func (ec *executionContext) marshalOMiningCountSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningCountSummary(ctx context.Context, sel ast.SelectionSet, v *model.MiningCountSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MiningCountSummary(ctx, sel, v)
}

func (ec *executionContext) marshalOMiningStatusSummay2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningStatusSummay(ctx context.Context, sel ast.SelectionSet, v *model.MiningStatusSummay) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MiningStatusSummay(ctx, sel, v)
}

func (ec *executionContext) marshalOMiningSummaryDay2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningSummaryDay(ctx context.Context, sel ast.SelectionSet, v []*model.MiningSummaryDay) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMiningSummaryDay2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningSummaryDay(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMiningSummaryDay2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningSummaryDay(ctx context.Context, sel ast.SelectionSet, v *model.MiningSummaryDay) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MiningSummaryDay(ctx, sel, v)
}

func (ec *executionContext) marshalOMiningTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTask(ctx context.Context, sel ast.SelectionSet, v []*model.MiningTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMiningTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMiningTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐMiningTask(ctx context.Context, sel ast.SelectionSet, v *model.MiningTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MiningTask(ctx, sel, v)
}

func (ec *executionContext) marshalONodeHealthSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeHealthSummary(ctx context.Context, sel ast.SelectionSet, v *model.NodeHealthSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NodeHealthSummary(ctx, sel, v)
}

func (ec *executionContext) marshalONodeInfo2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeInfo(ctx context.Context, sel ast.SelectionSet, v []*model.NodeInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONodeInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONodeInfo2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐNodeInfo(ctx context.Context, sel ast.SelectionSet, v *model.NodeInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NodeInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOOpenSectorPiece2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐOpenSectorPiece(ctx context.Context, sel ast.SelectionSet, v []*model.OpenSectorPiece) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOpenSectorPiece2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐOpenSectorPiece(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOpenSectorPiece2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐOpenSectorPiece(ctx context.Context, sel ast.SelectionSet, v *model.OpenSectorPiece) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OpenSectorPiece(ctx, sel, v)
}

func (ec *executionContext) marshalOPipelineSummary2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPipelineSummary(ctx context.Context, sel ast.SelectionSet, v []*model.PipelineSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPipelineSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPipelineSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPipelineSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPipelineSummary(ctx context.Context, sel ast.SelectionSet, v *model.PipelineSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PipelineSummary(ctx, sel, v)
}

func (ec *executionContext) marshalOPorep2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx context.Context, sel ast.SelectionSet, v []*model.Porep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPorep2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPorep2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPorep(ctx context.Context, sel ast.SelectionSet, v *model.Porep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Porep(ctx, sel, v)
}

func (ec *executionContext) marshalOPriceFilter2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PriceFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPriceFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPriceFilter2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐPriceFilter(ctx context.Context, sel ast.SelectionSet, v *model.PriceFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PriceFilter(ctx, sel, v)
}

func (ec *executionContext) marshalORunningTaskSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐRunningTaskSummary(ctx context.Context, sel ast.SelectionSet, v *model.RunningTaskSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RunningTaskSummary(ctx, sel, v)
}

func (ec *executionContext) marshalOSector2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSector(ctx context.Context, sel ast.SelectionSet, v []*model.Sector) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSector2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSector(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSector2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSector(ctx context.Context, sel ast.SelectionSet, v *model.Sector) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Sector(ctx, sel, v)
}

func (ec *executionContext) marshalOSectorLocation2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorLocation(ctx context.Context, sel ast.SelectionSet, v *model.SectorLocation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SectorLocation(ctx, sel, v)
}

func (ec *executionContext) marshalOSectorMeta2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMeta(ctx context.Context, sel ast.SelectionSet, v *model.SectorMeta) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SectorMeta(ctx, sel, v)
}

func (ec *executionContext) marshalOSectorMetaPiece2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorMetaPiece(ctx context.Context, sel ast.SelectionSet, v *model.SectorMetaPiece) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SectorMetaPiece(ctx, sel, v)
}

func (ec *executionContext) marshalOSectorSummary2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐSectorSummary(ctx context.Context, sel ast.SelectionSet, v *model.SectorSummary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SectorSummary(ctx, sel, v)
}

func (ec *executionContext) marshalOStorage2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorage(ctx context.Context, sel ast.SelectionSet, v *model.Storage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Storage(ctx, sel, v)
}

func (ec *executionContext) marshalOStorageLiveness2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageLiveness(ctx context.Context, sel ast.SelectionSet, v *model.StorageLiveness) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StorageLiveness(ctx, sel, v)
}

func (ec *executionContext) marshalOStoragePath2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStoragePath(ctx context.Context, sel ast.SelectionSet, v []*model.StoragePath) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStoragePath2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStoragePath(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOStoragePath2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStoragePath(ctx context.Context, sel ast.SelectionSet, v *model.StoragePath) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StoragePath(ctx, sel, v)
}

func (ec *executionContext) marshalOStorageStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageStats(ctx context.Context, sel ast.SelectionSet, v []*model.StorageStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStorageStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOStorageStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐStorageStats(ctx context.Context, sel ast.SelectionSet, v *model.StorageStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StorageStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTask2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v []*model.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTask2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v *model.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskAggregate2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskAggregate(ctx context.Context, sel ast.SelectionSet, v []*model.TaskAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTaskAggregate2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTaskAggregate2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskAggregate(ctx context.Context, sel ast.SelectionSet, v *model.TaskAggregate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskAggregate(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskDurationStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskDurationStats(ctx context.Context, sel ast.SelectionSet, v *model.TaskDurationStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskDurationStats(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskHistory2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v []*model.TaskHistory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTaskHistory2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v *model.TaskHistory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskHistory(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskStats2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStats(ctx context.Context, sel ast.SelectionSet, v []*model.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTaskStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStats(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTaskStats2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskStats(ctx context.Context, sel ast.SelectionSet, v *model.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskStats(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskSuccessRate2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐTaskSuccessRate(ctx context.Context, sel ast.SelectionSet, v *model.TaskSuccessRate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskSuccessRate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOWalletBalance2ᚕᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWalletBalanceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WalletBalance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWalletBalance2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWalletBalance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWdpostProofs2ᚖgithubᚗcomᚋweb3teaᚋcurioᚑdashboardᚋgraphᚋmodelᚐWdpostProofs(ctx context.Context, sel ast.SelectionSet, v *model.WdpostProofs) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WdpostProofs(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
