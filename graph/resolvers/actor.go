package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"math/big"
	"time"

	"github.com/filecoin-project/lotus/chain/types"
	"github.com/strahe/curio-dashboard/graph"
	"github.com/strahe/curio-dashboard/graph/cachecontrol"
	"github.com/strahe/curio-dashboard/graph/model"
	types1 "github.com/strahe/curio-dashboard/types"
)

// ID is the resolver for the id field.
func (r *actorResolver) ID(ctx context.Context, obj *model.Actor) (string, error) {
	return obj.Address.String(), nil
}

// QualityAdjustedPower is the resolver for the qualityAdjustedPower field.
func (r *actorResolver) QualityAdjustedPower(ctx context.Context, obj *model.Actor) (*types1.BigInt, error) {
	p, err := obj.Power(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	if p.HasMinPower {
		return &types1.BigInt{Int: p.MinerPower.QualityAdjPower.Int}, nil
	}
	return &types1.BigInt{Int: big.NewInt(0)}, nil
}

// RawBytePower is the resolver for the rawBytePower field.
func (r *actorResolver) RawBytePower(ctx context.Context, obj *model.Actor) (*types1.BigInt, error) {
	p, err := obj.Power(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	if p.HasMinPower {
		return &types1.BigInt{Int: p.MinerPower.RawBytePower.Int}, nil
	}
	return &types1.BigInt{Int: big.NewInt(0)}, nil
}

// ActorBalance is the resolver for the actorBalance field.
func (r *actorResolver) ActorBalance(ctx context.Context, obj *model.Actor) (*types1.BigInt, error) {
	actor, err := obj.ChainActor(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	return &types1.BigInt{Int: actor.Balance.Int}, nil
}

// ActorAvailableBalance is the resolver for the actorAvailableBalance field.
func (r *actorResolver) ActorAvailableBalance(ctx context.Context, obj *model.Actor) (*types1.BigInt, error) {
	ms, err := obj.MinerState(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	actor, err := obj.ChainActor(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	avail, err := ms.AvailableBalance(actor.Balance)
	if err != nil {
		return nil, err
	}
	return &types1.BigInt{Int: avail.Int}, nil
}

// WorkerBalance is the resolver for the workerBalance field.
func (r *actorResolver) WorkerBalance(ctx context.Context, obj *model.Actor) (*types1.BigInt, error) {
	ms, err := obj.MinerState(ctx, r.fullNode)
	if err != nil {
		return nil, err
	}
	mi, err := ms.Info()
	if err != nil {
		return nil, fmt.Errorf("getting miner info: %w", err)
	}
	wb, err := r.fullNode.WalletBalance(ctx, mi.Worker)
	if err != nil {
		return nil, fmt.Errorf("getting worker balance: %w", err)
	}
	return &types1.BigInt{Int: wb.Int}, nil
}

// Deadlines is the resolver for the deadlines field.
func (r *actorResolver) Deadlines(ctx context.Context, obj *model.Actor) ([]*model.ActorDeadline, error) {
	dls, err := r.fullNode.StateMinerDeadlines(ctx, obj.Address.Address, types.EmptyTSK)
	if err != nil {
		return nil, err
	}

	var outDls []*model.ActorDeadline
	for idx := range dls {
		p, err := r.fullNode.StateMinerPartitions(ctx, obj.Address.Address, uint64(idx), types.EmptyTSK)
		if err != nil {
			return nil, err
		}
		dl := &model.ActorDeadline{
			Empty:      false,
			Current:    false,
			Proven:     false,
			PartFaulty: false,
			Faulty:     false,
		}

		var live, faulty uint64

		for _, part := range p {
			l, err := part.LiveSectors.Count()
			if err != nil {
				return nil, fmt.Errorf("getting live sectors: %w", err)
			}
			live += l

			f, err := part.FaultySectors.Count()
			if err != nil {
				return nil, fmt.Errorf("getting faulty sectors: %w", err)
			}
			faulty += f
		}

		dl.Empty = live == 0
		dl.Proven = live > 0 && faulty == 0
		dl.PartFaulty = faulty > 0
		dl.Faulty = faulty > 0 && faulty == live

		outDls = append(outDls, dl)
	}
	return outDls, nil
}

// Actors is the resolver for the actors field.
func (r *queryResolver) Actors(ctx context.Context) ([]*model.Actor, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, time.Minute*5)
	return r.loader.Actors(ctx)
}

// Actor is the resolver for the actor field.
func (r *queryResolver) Actor(ctx context.Context, address types1.Address) (*model.Actor, error) {
	return r.loader.Actor(ctx, address)
}

// Actor returns graph.ActorResolver implementation.
func (r *Resolver) Actor() graph.ActorResolver { return &actorResolver{r} }

type actorResolver struct{ *Resolver }
