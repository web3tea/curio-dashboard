package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	io_prometheus_client "github.com/prometheus/client_model/go"
	"github.com/prometheus/common/expfmt"
	"github.com/samber/lo"
	"github.com/web3tea/curio-dashboard/graph"
	"github.com/web3tea/curio-dashboard/graph/cachecontrol"
	"github.com/web3tea/curio-dashboard/graph/model"
)

// Detail is the resolver for the detail field.
func (r *machineResolver) Detail(ctx context.Context, obj *model.Machine) (*model.MachineDetail, error) {
	var out model.MachineDetail
	if err := r.db.QueryRow(ctx, `SELECT
    id,
    machine_name,
    tasks,
    layers,
    startup_time,
    miners,
    machine_id
FROM harmony_machine_details
WHERE machine_id = $1`, obj.ID).
		Scan(&out.ID, &out.MachineName, &out.Tasks, &out.Layers, &out.StartupTime, &out.Miners, &out.MachineID); err != nil {
		return nil, err
	}
	return &out, nil
}

// Tasks is the resolver for the tasks field.
func (r *machineResolver) Tasks(ctx context.Context, obj *model.Machine) ([]*model.Task, error) {
	var out []*model.Task
	if err := r.db.Select(ctx, &out, `SELECT
    id,
    initiated_by,
    update_time,
    posted_time,
    owner_id,
    added_by,
    previous_task,
    name
FROM
    harmony_task
WHERE owner_id = $1`, obj.ID); err != nil {
		return nil, err
	}
	return out, nil
}

// TaskHistories is the resolver for the taskHistories field.
func (r *machineResolver) TaskHistories(ctx context.Context, obj *model.Machine, last int) ([]*model.TaskHistory, error) {
	var out []*model.TaskHistory
	if err := r.db.Select(ctx, &out, `SELECT
    id,
    task_id,
    name,
    posted,
    work_start,
    work_end,
    result,
    err,
    completed_by_host_and_port
FROM
    harmony_task_history
WHERE work_end > CURRENT_TIMESTAMP - INTERVAL '24 hours'
  AND completed_by_host_and_port = $1
ORDER BY work_end DESC LIMIT $2`, obj.HostAndPort, last); err != nil {
		return nil, err
	}
	return out, nil
}

// Storages is the resolver for the storages field.
func (r *machineResolver) Storages(ctx context.Context, obj *model.Machine) ([]*model.StoragePath, error) {
	ss, err := r.loader.MachineStorages(ctx, obj.HostAndPort)
	if err != nil {
		return nil, err
	}
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, time.Minute)
	return ss, nil
}

// Metrics is the resolver for the metrics field.
func (r *machineResolver) Metrics(ctx context.Context, obj *model.Machine) (*model.MachineMetrics, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, fmt.Sprintf("http://%s/debug/metrics", obj.HostAndPort), nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatalf("Error fetching metrics: %v", err)
	}
	defer resp.Body.Close() // nolint: errcheck

	var parser expfmt.TextParser
	metrics, err := parser.TextToMetricFamilies(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error parsing metrics: %v", err)
	}

	var result model.MachineMetrics

	parserFunc := func(name string, m *io_prometheus_client.Metric) {
		switch name {
		case "go_info":
			for _, label := range m.Label {
				if label.GetName() == "version" {
					result.GoVersion = label.GetValue()
				}
			}
		case "go_goroutines":
			result.GoRoutines = int(m.GetGauge().GetValue())
		case "process_cpu_seconds_total":
			result.ProcessCPUSecondsTotal = int(m.GetCounter().GetValue())
		case "process_start_time_seconds":
			result.ProcessStartTimeSeconds = int(m.GetGauge().GetValue())
		case "process_virtual_memory_bytes":
			result.ProcessVirtualMemoryBytes = int(m.GetGauge().GetValue())
		case "process_resident_memory_bytes":
			result.ProcessResidentMemoryBytes = int(m.GetGauge().GetValue())
		case "process_open_fds":
			result.ProcessOpenFds = int(m.GetGauge().GetValue())
		case "process_max_fds":
			result.ProcessMaxFds = int(m.GetGauge().GetValue())
		case "go_threads":
			result.GoThreads = int(m.GetGauge().GetValue())
		case "curio_harmonytask_cpu_usage":
			result.CPUUsage = m.GetGauge().GetValue()
		case "curio_harmonytask_ram_usage":
			result.RAMUsage = m.GetGauge().GetValue()
		case "curio_harmonytask_gpu_usage":
			result.GpuUsage = m.GetGauge().GetValue()
		case "curio_harmonytask_active_tasks":
			for _, label := range m.Label {
				result.ActiveTasks = append(result.ActiveTasks, &model.GaugeCountValue{
					Key:   label.GetValue(),
					Value: int(m.GetGauge().GetValue()),
				})
			}
		case "curio_harmonytask_added_tasks":
			for _, label := range m.Label {
				result.AddedTasks = append(result.AddedTasks, &model.GaugeCountValue{
					Key:   label.GetValue(),
					Value: int(m.GetGauge().GetValue()),
				})
			}
		case "curio_harmonytask_tasks_completed":
			for _, label := range m.Label {
				result.TasksCompleted = append(result.TasksCompleted, &model.GaugeCountValue{
					Key:   label.GetValue(),
					Value: int(m.GetGauge().GetValue()),
				})
			}
		case "curio_harmonytask_tasks_started":
			for _, label := range m.Label {
				result.TasksStarted = append(result.TasksStarted, &model.GaugeCountValue{
					Key:   label.GetValue(),
					Value: int(m.GetGauge().GetValue()),
				})
			}
		}
	}

	// var result []metric
	for name, mf := range metrics {
		for _, m := range mf.Metric {
			parserFunc(name, m)
		}
	}
	return &result, nil
}

// TasksArray is the resolver for the tasksArray field.
func (r *machineDetailResolver) TasksArray(ctx context.Context, obj *model.MachineDetail) ([]string, error) {
	return strings.Split(obj.Tasks.String, ","), nil
}

// LayersArray is the resolver for the layersArray field.
func (r *machineDetailResolver) LayersArray(ctx context.Context, obj *model.MachineDetail) ([]string, error) {
	return strings.Split(obj.Layers.String, ","), nil
}

// MinersArray is the resolver for the minersArray field.
func (r *machineDetailResolver) MinersArray(ctx context.Context, obj *model.MachineDetail) ([]string, error) {
	return strings.Split(obj.Miners.String, ","), nil
}

// Total is the resolver for the total field.
func (r *machineSummaryResolver) Total(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var total int
	err := r.db.QueryRow(ctx, "SELECT COUNT(*) FROM harmony_machines").Scan(&total)
	return total, err
}

// TotalUp is the resolver for the totalUp field.
func (r *machineSummaryResolver) TotalUp(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var totalUp int
	err := r.db.QueryRow(ctx, "SELECT COUNT(*) FROM harmony_machines WHERE last_contact > NOW() - INTERVAL '5 MINUTES' ").Scan(&totalUp)
	return totalUp, err
}

// TotalDown is the resolver for the totalDown field.
func (r *machineSummaryResolver) TotalDown(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var totalDown int
	err := r.db.QueryRow(ctx, "SELECT COUNT(*) FROM harmony_machines WHERE last_contact < NOW() - INTERVAL '5 MINUTES' ").Scan(&totalDown)
	return totalDown, err
}

// UniqueHostsTotal is the resolver for the uniqueHostsTotal field.
func (r *machineSummaryResolver) UniqueHostsTotal(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var total int
	err := r.db.QueryRow(ctx, `SELECT
    COUNT(DISTINCT SPLIT_PART(host_and_port, ':', 1)) AS unique_host_count
FROM
    harmony_machines;`).Scan(&total)
	return total, err
}

// UniqueHostsUp is the resolver for the uniqueHostsUp field.
func (r *machineSummaryResolver) UniqueHostsUp(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var totalUp int
	err := r.db.QueryRow(ctx, `SELECT
    COUNT(DISTINCT SPLIT_PART(host_and_port, ':', 1)) AS unique_host_count
FROM
    harmony_machines
WHERE
    last_contact > NOW() - INTERVAL '5 MINUTES'`).Scan(&totalUp)
	return totalUp, err
}

// UniqueHostsDown is the resolver for the uniqueHostsDown field.
func (r *machineSummaryResolver) UniqueHostsDown(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var totalDown int
	err := r.db.QueryRow(ctx, `SELECT
    COUNT(DISTINCT SPLIT_PART(host_and_port, ':', 1)) AS unique_host_count
FROM
    harmony_machines
WHERE
    last_contact <= NOW() - INTERVAL '5 MINUTES'`).Scan(&totalDown)
	return totalDown, err
}

// TotalRAM is the resolver for the totalRam field.
func (r *machineSummaryResolver) TotalRAM(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var total int
	err := r.db.QueryRow(ctx, "SELECT SUM(ram) FROM harmony_machines").Scan(&total)
	return total, err
}

// TotalCPU is the resolver for the totalCpu field.
func (r *machineSummaryResolver) TotalCPU(ctx context.Context, obj *model.MachineSummary) (int, error) {
	var total int
	err := r.db.QueryRow(ctx, "SELECT SUM(cpu) FROM harmony_machines").Scan(&total)
	return total, err
}

// TotalGpu is the resolver for the totalGpu field.
func (r *machineSummaryResolver) TotalGpu(ctx context.Context, obj *model.MachineSummary) (float64, error) {
	var total float64
	err := r.db.QueryRow(ctx, "SELECT SUM(gpu) FROM harmony_machines").Scan(&total)
	return total, err
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *machineSummaryResolver) UpdatedAt(ctx context.Context, obj *model.MachineSummary) (*time.Time, error) {
	return lo.ToPtr(time.Now()), nil
}

// Machine is the resolver for the machine field.
func (r *queryResolver) Machine(ctx context.Context, id int) (*model.Machine, error) {
	return r.loader.Machine(ctx, id)
}

// MachineByHostAndPort is the resolver for the machineByHostAndPort field.
func (r *queryResolver) MachineByHostAndPort(ctx context.Context, hostAndPort string) (*model.Machine, error) {
	return r.loader.MachineByHostPort(ctx, hostAndPort)
}

// Machines is the resolver for the machines field.
func (r *queryResolver) Machines(ctx context.Context) ([]*model.Machine, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, time.Minute)
	return r.loader.Machines(ctx)
}

// MachineSummary is the resolver for the machineSummary field.
func (r *queryResolver) MachineSummary(ctx context.Context) (*model.MachineSummary, error) {
	return &model.MachineSummary{}, nil
}

// Machine returns graph.MachineResolver implementation.
func (r *Resolver) Machine() graph.MachineResolver { return &machineResolver{r} }

// MachineDetail returns graph.MachineDetailResolver implementation.
func (r *Resolver) MachineDetail() graph.MachineDetailResolver { return &machineDetailResolver{r} }

// MachineSummary returns graph.MachineSummaryResolver implementation.
func (r *Resolver) MachineSummary() graph.MachineSummaryResolver { return &machineSummaryResolver{r} }

type machineResolver struct{ *Resolver }
type machineDetailResolver struct{ *Resolver }
type machineSummaryResolver struct{ *Resolver }
