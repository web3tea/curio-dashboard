package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"time"

	"github.com/filecoin-project/curio/web/api/webrpc"
	"github.com/samber/lo"
	"github.com/web3tea/curio-dashboard/graph/cachecontrol"
	"github.com/web3tea/curio-dashboard/graph/loaders"
	"github.com/web3tea/curio-dashboard/graph/model"
	"github.com/web3tea/curio-dashboard/graph/utils"
	"github.com/web3tea/curio-dashboard/types"
)

// MarketAddBalance is the resolver for the marketAddBalance field.
func (r *mutationResolver) MarketAddBalance(ctx context.Context, miner types.Address, wallet types.Address, amount types.FIL) (*model.MarketBalance, error) {
	_, err := r.curioAPI.MoveBalanceToEscrow(ctx, miner.String(), amount.String(), wallet.String())
	if err != nil {
		return nil, fmt.Errorf("failed to move balance to escrow: %w", err)
	}
	return r.Resolver.Query().MarketBalance(ctx, miner)
}

// UpdateMarketMk12StorageAsk is the resolver for the updateMarketMk12StorageAsk field.
func (r *mutationResolver) UpdateMarketMk12StorageAsk(ctx context.Context, input model.MarketMk12StorageAskInput) (*model.MarketMk12StorageAsk, error) {
	if input.Price < 0 {
		return nil, fmt.Errorf("invalid Price: must be non-negative")
	}
	if input.VerifiedPrice < 0 {
		return nil, fmt.Errorf("invalid VerifiedPrice: must be non-negative")
	}
	if !utils.IsValidPieceSize(uint64(input.MinSize)) {
		return nil, fmt.Errorf("invalid MinSize: must be a valid piece size")
	}
	if !utils.IsValidPieceSize(uint64(input.MaxSize)) {
		return nil, fmt.Errorf("invalid MaxSize: must be a valid piece size")
	}
	if input.MaxSize < input.MinSize {
		return nil, fmt.Errorf("invalid size range: MaxSize must be greater than or equal to MinSize")
	}
	if _, err := r.Query().Actor(ctx, input.SpID); err != nil {
		return nil, fmt.Errorf("invalid SpID: %w", err)
	}
	ask := webrpc.StorageAsk{
		SpID:          int64(lo.FromPtr(input.SpID.ID())),
		Price:         int64(input.Price),
		VerifiedPrice: int64(input.VerifiedPrice),
		MinSize:       int64(input.MinSize),
		MaxSize:       int64(input.MaxSize),
		CreatedAt:     time.Now().Unix(),
		Expiry:        int64(input.Expiry),
	}
	if ask.Expiry == 0 {
		ask.Expiry = time.Now().Add(time.Hour * 24 * 365).Unix()
	}
	err := r.curioAPI.SetStorageAsk(ctx, &ask)
	if err != nil {
		return nil, err
	}
	return r.Resolver.Query().MarketMk12StorageAsk(ctx, input.SpID)
}

// MarketAddPriceFilter is the resolver for the marketAddPriceFilter field.
func (r *mutationResolver) MarketAddPriceFilter(ctx context.Context, input model.PriceFilterInput) (bool, error) {
	err := r.curioAPI.AddPriceFilters(ctx, input.Name, input.MinDurationDays, input.MaxDurationDays, int64(input.MinimumSize), int64(input.MaximumSize), int64(input.Price), input.Verified)
	if err != nil {
		return false, err
	}

	return true, nil
}

// MarketUpdatePriceFilter is the resolver for the marketUpdatePriceFilter field.
func (r *mutationResolver) MarketUpdatePriceFilter(ctx context.Context, input model.PriceFilterInput) (*model.PriceFilter, error) {
	err := r.curioAPI.SetPriceFilters(ctx, input.Name, input.MinDurationDays, input.MaxDurationDays, int64(input.MinimumSize), int64(input.MaximumSize), int64(input.Price), input.Verified)
	if err != nil {
		return nil, err
	}

	return r.Query().MarketPriceFilter(ctx, input.Name)
}

// MarketDeletePriceFilter is the resolver for the marketDeletePriceFilter field.
func (r *mutationResolver) MarketDeletePriceFilter(ctx context.Context, name string) (bool, error) {
	err := r.curioAPI.RemovePricingFilter(ctx, name)
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketAddClientFilter is the resolver for the marketAddClientFilter field.
func (r *mutationResolver) MarketAddClientFilter(ctx context.Context, input model.ClientFilterInput) (bool, error) {
	err := r.curioAPI.AddClientFilters(ctx,
		input.Name,
		input.Active,
		lo.Map(input.Wallets, func(item *types.Address, index int) string {
			return item.String()
		}),
		lo.Map(input.Peers, func(item *types.PeerID, index int) string {
			return item.String()
		}),
		input.PricingFilters,
		int64(input.MaxDealsPerHour),
		int64(input.MaxDealSizePerHour),
		input.Info,
	)
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketUpdateClientFilter is the resolver for the marketUpdateClientFilter field.
func (r *mutationResolver) MarketUpdateClientFilter(ctx context.Context, input model.ClientFilterInput) (*model.ClientFilter, error) {
	err := r.curioAPI.SetClientFilters(ctx,
		input.Name,
		input.Active,
		lo.Map(input.Wallets, func(item *types.Address, index int) string {
			return item.String()
		}),
		lo.Map(input.Peers, func(item *types.PeerID, index int) string {
			return item.String()
		}),
		input.PricingFilters,
		int64(input.MaxDealsPerHour),
		int64(input.MaxDealSizePerHour),
		input.Info,
	)
	if err != nil {
		return nil, err
	}
	return r.Query().MarketClientFilter(ctx, input.Name)
}

// MarketDeleteClientFilter is the resolver for the marketDeleteClientFilter field.
func (r *mutationResolver) MarketDeleteClientFilter(ctx context.Context, name string) (bool, error) {
	err := r.curioAPI.RemoveClientFilter(ctx, name)
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketToggleClientFilter is the resolver for the marketToggleClientFilter field.
func (r *mutationResolver) MarketToggleClientFilter(ctx context.Context, name string) (bool, error) {
	filter, err := r.loader.MarketMk12ClientFilter(ctx, name)
	if err != nil {
		return false, err
	}
	err = r.curioAPI.SetClientFilters(ctx,
		filter.Name,
		!filter.Active,
		filter.Wallets,
		filter.Peers,
		filter.PricingFilters,
		int64(filter.MaxDealsPerHour),
		int64(filter.MaxDealSizePerHour),
		filter.Info)
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketSetAllowFilter is the resolver for the marketSetAllowFilter field.
func (r *mutationResolver) MarketSetAllowFilter(ctx context.Context, wallet types.Address, status bool) (*model.MarketAllowFilter, error) {
	_, err := r.Query().MarketAllowFilter(ctx, wallet)
	switch err {
	case nil: // filter exists, update
		err = r.curioAPI.SetAllowDenyList(ctx, wallet.String(), status)
	case loaders.ErrorNotFound: // filter does not exist, add
		err = r.curioAPI.AddAllowDenyList(ctx, wallet.String(), status)
	default:
	}
	if err != nil {
		return nil, err
	}
	return r.Query().MarketAllowFilter(ctx, wallet)
}

// MarketDeleteAllowFilter is the resolver for the marketDeleteAllowFilter field.
func (r *mutationResolver) MarketDeleteAllowFilter(ctx context.Context, wallet types.Address) (bool, error) {
	_, err := r.Query().MarketAllowFilter(ctx, wallet)
	switch err {
	case nil: // filter exists, delete
		err = r.curioAPI.RemoveAllowFilter(ctx, wallet.String())
	case loaders.ErrorNotFound: // filter does not exist
		err = fmt.Errorf("filter does not exist")
	default:
	}
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketToggleAllowFilter is the resolver for the marketToggleAllowFilter field.
func (r *mutationResolver) MarketToggleAllowFilter(ctx context.Context, wallet types.Address) (bool, error) {
	filter, err := r.Query().MarketAllowFilter(ctx, wallet)
	switch err {
	case nil: // filter exists, toggle
		err = r.curioAPI.SetAllowDenyList(ctx, wallet.String(), !filter.Status)
	case loaders.ErrorNotFound: // filter does not exist
		err = fmt.Errorf("filter does not exist")
	default:
	}
	if err != nil {
		return false, err
	}
	return true, nil
}

// MarketBalance is the resolver for the marketBalance field.
func (r *queryResolver) MarketBalance(ctx context.Context, miner types.Address) (*model.MarketBalance, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	balances, err := r.MarketBalances(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get market balances: %w", err)
	}
	for _, b := range balances {
		if b.Miner == miner {
			return b, nil
		}
	}
	return nil, fmt.Errorf("miner %s not found", miner)
}

// MarketBalances is the resolver for the marketBalances field.
func (r *queryResolver) MarketBalances(ctx context.Context) (res []*model.MarketBalance, err error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	cacheKey := "marketBalances"
	if val, ok := r.cache.Get(cacheKey); ok {
		return val.([]*model.MarketBalance), nil
	}

	balances, err := r.curioAPI.MarketBalance(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get market balances: %w", err)
	}
	for _, b := range balances {
		res = append(res, &model.MarketBalance{
			Miner:   types.MustParseAddress(b.Miner),
			Balance: types.MustParseFIL(b.MarketBalance),
			Balances: lo.Map(b.Balances, func(x webrpc.WalletBalances, index int) *model.WalletBalance {
				return &model.WalletBalance{
					Address: types.MustParseAddress(x.Address),
					Balance: types.MustParseFIL(x.Balance),
				}
			}),
		})
	}
	r.cache.Add(cacheKey, res)
	return res, nil
}

// MarketMk12StorageAsks is the resolver for the marketMk12StorageAsks field.
func (r *queryResolver) MarketMk12StorageAsks(ctx context.Context) ([]*model.MarketMk12StorageAsk, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	return r.loader.MarketLoader.MarketMk12StorageAsks(ctx)
}

// MarketMk12StorageAsk is the resolver for the marketMk12StorageAsk field.
func (r *queryResolver) MarketMk12StorageAsk(ctx context.Context, spID types.Address) (*model.MarketMk12StorageAsk, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	return r.loader.MarketLoader.MarketMk12StorageAsk(ctx, lo.FromPtr(spID.ID()))
}

// MarketMk12StorageAsksCount is the resolver for the marketMk12StorageAsksCount field.
func (r *queryResolver) MarketMk12StorageAsksCount(ctx context.Context) (int, error) {
	cachecontrol.SetHint(ctx, cachecontrol.ScopePrivate, marketDefaultCacheAge)
	return r.loader.MarketLoader.MarketMk12StorageAsksCount(ctx)
}

// MakretPriceFilters is the resolver for the makretPriceFilters field.
func (r *queryResolver) MakretPriceFilters(ctx context.Context) ([]*model.PriceFilter, error) {
	res, err := r.curioAPI.GetPriceFilters(ctx)
	if err != nil {
		return nil, err
	}
	return lo.Map(res, func(item webrpc.PriceFilter, index int) *model.PriceFilter {
		return &model.PriceFilter{
			Name:            item.Name,
			MinDurationDays: item.MinDur,
			MaxDurationDays: item.MaxDur,
			MinimumSize:     int(item.MinSize),
			MaximumSize:     int(item.MaxSize),
			Price:           int(item.Price),
			Verified:        item.Verified,
		}
	}), nil
}

// MarketPriceFilter is the resolver for the marketPriceFilter field.
func (r *queryResolver) MarketPriceFilter(ctx context.Context, name string) (*model.PriceFilter, error) {
	res, err := r.loader.MarketMk12PriceFilter(ctx, name)
	if err != nil {
		return nil, err
	}
	return &model.PriceFilter{
		Name:            res.Name,
		MinDurationDays: res.MinDur,
		MaxDurationDays: res.MaxDur,
		MinimumSize:     int(res.MinSize),
		MaximumSize:     int(res.MaxSize),
		Price:           int(res.Price),
		Verified:        res.Verified,
	}, nil
}

// MarketCheckPriceFilter is the resolver for the marketCheckPriceFilter field.
func (r *queryResolver) MarketCheckPriceFilter(ctx context.Context, name string) (bool, error) {
	res, _ := r.MarketPriceFilter(ctx, name) // nolint: errcheck
	return res != nil, nil
}

// MarketClientFilters is the resolver for the marketClientFilters field.
func (r *queryResolver) MarketClientFilters(ctx context.Context) ([]*model.ClientFilter, error) {
	filters, err := r.curioAPI.GetClientFilters(ctx)
	if err != nil {
		return nil, err
	}
	return lo.Map(filters, func(item webrpc.ClientFilter, index int) *model.ClientFilter {
		return &model.ClientFilter{
			Name:   item.Name,
			Active: item.Active,
			Wallets: lo.Map(item.Wallets, func(x string, index int) *types.Address {
				addr := types.MustParseAddress(x)
				return &addr
			}),
			Peers: lo.Map(item.Peers, func(x string, index int) *types.PeerID {
				peer := types.MustParsePeerID(x)
				return &peer
			}),
			PricingFilters:     item.PricingFilters,
			MaxDealsPerHour:    int(item.MaxDealsPerHour),
			MaxDealSizePerHour: int(item.MaxDealSizePerHour),
			Info:               item.Info,
		}
	}), nil
}

// MarketClientFilter is the resolver for the marketClientFilter field.
func (r *queryResolver) MarketClientFilter(ctx context.Context, name string) (*model.ClientFilter, error) {
	filter, err := r.loader.MarketMk12ClientFilter(ctx, name)
	if err != nil {
		return nil, err
	}
	return &model.ClientFilter{
		Name:   filter.Name,
		Active: filter.Active,
		Wallets: lo.Map(filter.Wallets, func(item string, index int) *types.Address {
			addr := types.MustParseAddress(item)
			return &addr
		}),
		Peers: lo.Map(filter.Peers, func(item string, index int) *types.PeerID {
			peer := types.MustParsePeerID(item)
			return &peer
		}),
		PricingFilters:     filter.PricingFilters,
		MaxDealsPerHour:    int(filter.MaxDealsPerHour),
		MaxDealSizePerHour: int(filter.MaxDealSizePerHour),
		Info:               filter.Info,
	}, nil
}

// MarketCheckClientFilter is the resolver for the marketCheckClientFilter field.
func (r *queryResolver) MarketCheckClientFilter(ctx context.Context, name string) (bool, error) {
	f, _ := r.MarketClientFilter(ctx, name) // nolint: errcheck
	return f != nil, nil
}

// MarketAllowFilters is the resolver for the marketAllowFilters field.
func (r *queryResolver) MarketAllowFilters(ctx context.Context) ([]*model.MarketAllowFilter, error) {
	filters, err := r.curioAPI.GetAllowDenyList(ctx)
	if err != nil {
		return nil, err
	}
	return lo.Map(filters, func(item webrpc.AllowDeny, index int) *model.MarketAllowFilter {
		return &model.MarketAllowFilter{
			Wallet: types.MustParseAddress(item.Wallet),
			Status: item.Status,
		}
	}), nil
}

// MarketAllowFilter is the resolver for the marketAllowFilter field.
func (r *queryResolver) MarketAllowFilter(ctx context.Context, wallet types.Address) (*model.MarketAllowFilter, error) {
	return r.loader.MarketAllowFilter(ctx, wallet)
}

// MarketDefaultFilterBehaviour is the resolver for the marketDefaultFilterBehaviour field.
func (r *queryResolver) MarketDefaultFilterBehaviour(ctx context.Context) (*model.DefaultFilterBehaviour, error) {
	df, err := r.curioAPI.DefaultFilterBehaviour(ctx)
	if err != nil {
		return nil, err
	}
	return &model.DefaultFilterBehaviour{
		AllowDealsFromUnknownClients:             df.AllowDealsFromUnknownClients,
		IsDealRejectedWhenCidGravityNotReachable: df.IsDealRejectedWhenCidGravityNotReachable,
		IsCidGravityEnabled: lo.MapToSlice(df.IsCidGravityEnabled, func(key string, value bool) *model.CidGravityStatus {
			return &model.CidGravityStatus{
				Miner:  types.MustParseAddress(key),
				Status: value,
			}
		}),
	}, nil
}
